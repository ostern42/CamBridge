===== FILE: src\CamBridge.Infrastructure\Services\ExifToolReader.cs =====
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core.Entities;
using CamBridge.Core.ValueObjects;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Reads EXIF metadata from JPEG files using ExifTool
    /// Specifically handles Ricoh G900SE II barcode field
    /// </summary>
    public class ExifToolReader
    {
        private readonly ILogger<ExifToolReader> _logger;
        private readonly string _exifToolPath;
        private readonly int _timeoutMs;

        /// <summary>
        /// Creates a new ExifToolReader instance
        /// This constructor matches what ServiceCollectionExtensions expects
        /// </summary>
        /// <param name="logger">Logger for diagnostics</param>
        /// <param name="timeoutMs">Timeout for ExifTool execution in milliseconds</param>
        public ExifToolReader(ILogger<ExifToolReader> logger, int timeoutMs = 5000)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _timeoutMs = timeoutMs;

            // Try to find ExifTool in various locations
            var possiblePaths = new[]
            {
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Tools", "exiftool.exe"),
                Path.Combine(Directory.GetCurrentDirectory(), "Tools", "exiftool.exe"),
                @"Tools\exiftool.exe",
                @"C:\Tools\exiftool.exe"
            };

            foreach (var path in possiblePaths)
            {
                if (File.Exists(path))
                {
                    _exifToolPath = path;
                    _logger.LogInformation("Found ExifTool at: {Path}", path);
                    break;
                }
            }

            if (string.IsNullOrEmpty(_exifToolPath))
            {
                throw new FileNotFoundException("ExifTool not found in any expected location");
            }
        }

        /// <summary>
        /// Extracts complete metadata from a JPEG file
        /// This method name matches what FileProcessor expects
        /// </summary>
        public async Task<ImageMetadata> ExtractMetadataAsync(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException($"File not found: {filePath}");
            }

            _logger.LogDebug("Extracting metadata from: {FilePath}", filePath);

            try
            {
                // Run ExifTool and get all EXIF data
                var output = await RunExifToolAsync(filePath);
                var exifData = ParseExifToolOutput(output);

                // Log what we found
                if (exifData.TryGetValue("Barcode", out var barcode))
                {
                    _logger.LogInformation("Found Ricoh barcode data: '{Barcode}'", barcode);
                }
                if (exifData.TryGetValue("UserComment", out var userComment))
                {
                    _logger.LogDebug("UserComment field: '{UserComment}'", userComment);
                }

                // Look for QRBridge data in the Barcode field (Ricoh-specific)
                string? barcodeData = null;
                if (exifData.TryGetValue("Barcode", out var barcodeValue))
                {
                    barcodeData = barcodeValue;
                    _logger.LogInformation("Found barcode data in Barcode field: '{BarcodeData}'", barcodeData);
                }
                else if (exifData.TryGetValue("UserComment", out var userCommentValue) &&
                         userCommentValue != "GCM_TAG" &&
                         userCommentValue.Contains("|"))
                {
                    // Fallback to UserComment if it contains pipe-delimited data
                    barcodeData = userCommentValue;
                    _logger.LogInformation("Found barcode data in UserComment field: '{BarcodeData}'", barcodeData);
                }
                else
                {
                    _logger.LogWarning("No barcode data found in EXIF");
                }

                // Parse patient and study info from barcode
                PatientInfo patientInfo;
                StudyInfo studyInfo;

                if (!string.IsNullOrEmpty(barcodeData))
                {
                    (patientInfo, studyInfo) = ParseBarcodeData(barcodeData);
                }
                else
                {
                    (patientInfo, studyInfo) = CreateDefaultPatientAndStudy();
                }

                // Extract technical data
                var technicalData = new ImageTechnicalData
                {
                    ImageWidth = GetIntValue(exifData, "ImageWidth", "ExifImageWidth"),
                    ImageHeight = GetIntValue(exifData, "ImageHeight", "ExifImageHeight"),
                    BitsPerSample = GetIntValue(exifData, "BitsPerSample") ?? 8,
                    ColorSpace = exifData.GetValueOrDefault("ColorSpace", "RGB"),
                    Manufacturer = exifData.GetValueOrDefault("Make", "Unknown"),
                    Model = exifData.GetValueOrDefault("Model", "Unknown"),
                    Software = exifData.GetValueOrDefault("Software", "Unknown"),
                    Compression = exifData.GetValueOrDefault("Compression"),
                    Orientation = GetIntValue(exifData, "Orientation")
                };

                // Get capture date/time
                var captureDateTime = GetDateTime(exifData, "DateTimeOriginal", "CreateDate", "DateTime") ?? DateTime.Now;

                // Generate instance UID
                var instanceUid = GenerateUid();

                // Create and return metadata using the proper constructor
                return new ImageMetadata(
                    sourceFilePath: filePath,
                    captureDateTime: captureDateTime,
                    patient: patientInfo,
                    study: studyInfo,
                    technicalData: technicalData,
                    userComment: exifData.GetValueOrDefault("UserComment"),
                    barcodeData: barcodeData,
                    instanceNumber: 1,
                    instanceUid: instanceUid,
                    exifData: new Dictionary<string, string>(exifData) // Create a copy to ensure no issues
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to extract metadata from {FilePath}", filePath);
                throw new InvalidOperationException($"Failed to extract metadata from {filePath}: {ex.Message}", ex);
            }
        }

        private async Task<string> RunExifToolAsync(string filePath)
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = _exifToolPath,
                Arguments = $"-s -a -u -charset exiftool=UTF8 -charset filename=UTF8 \"{filePath}\"", // Force UTF-8
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true,
                StandardOutputEncoding = Encoding.UTF8
            };

            using var process = new Process { StartInfo = startInfo };
            using var cts = new CancellationTokenSource(_timeoutMs);

            var outputBuilder = new StringBuilder();
            var errorBuilder = new StringBuilder();

            process.OutputDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                    outputBuilder.AppendLine(e.Data);
            };

            process.ErrorDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                    errorBuilder.AppendLine(e.Data);
            };

            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            try
            {
                await process.WaitForExitAsync(cts.Token);
            }
            catch (OperationCanceledException)
            {
                process.Kill();
                throw new TimeoutException($"ExifTool timed out after {_timeoutMs}ms");
            }

            if (process.ExitCode != 0)
            {
                var error = errorBuilder.ToString();
                _logger.LogWarning("ExifTool returned exit code {ExitCode}. Error: {Error}",
                    process.ExitCode, error);
            }

            return outputBuilder.ToString();
        }

        private Dictionary<string, string> ParseExifToolOutput(string output)
        {
            var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            if (string.IsNullOrWhiteSpace(output))
                return result;

            var lines = output.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);

            foreach (var line in lines)
            {
                var colonIndex = line.IndexOf(':');
                if (colonIndex > 0 && colonIndex < line.Length - 1)
                {
                    var key = line.Substring(0, colonIndex).Trim();
                    var value = line.Substring(colonIndex + 1).Trim();

                    if (!string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
                    {
                        // Skip keys that are just encoding artifacts
                        if (key.Length == 1 && (key[0] == '�' || key[0] < 32 || key[0] > 126))
                        {
                            _logger.LogDebug("Skipping invalid key: {Key} (char code: {Code})", key, (int)key[0]);
                            continue;
                        }

                        // Handle duplicate keys by making them unique
                        var finalKey = key;
                        var counter = 1;
                        while (result.ContainsKey(finalKey))
                        {
                            finalKey = $"{key}_{counter}";
                            counter++;
                            _logger.LogDebug("Duplicate key found: {Key}, renamed to: {FinalKey}", key, finalKey);
                        }

                        result[finalKey] = value;
                    }
                }
            }

            return result;
        }

        private (PatientInfo, StudyInfo) ParseBarcodeData(string barcodeData)
        {
            if (string.IsNullOrWhiteSpace(barcodeData))
            {
                _logger.LogWarning("Barcode data is empty or null");
                return CreateDefaultPatientAndStudy();
            }

            // Clean the barcode data first
            var cleanedData = CleanBarcodeData(barcodeData);
            _logger.LogDebug("Parsing cleaned barcode data: '{CleanedData}'", cleanedData);

            var parts = cleanedData.Split('|');

            // QRBridge format validation
            if (parts.Length < 3)
            {
                _logger.LogWarning("Invalid barcode format. Expected at least 3 fields, got {Count}", parts.Length);
                return CreateDefaultPatientAndStudy();
            }

            // Log each field for debugging
            for (int i = 0; i < parts.Length; i++)
            {
                _logger.LogDebug("Barcode field [{Index}]: '{Value}'", i, parts[i]);
            }

            try
            {
                // Parse patient info
                var examId = parts[0].Trim();
                var patientName = parts[1].Trim();

                // Parse birth date - handle various formats
                DateTime? birthDate = null;
                if (parts.Length > 2 && !string.IsNullOrWhiteSpace(parts[2]))
                {
                    var dateStr = parts[2].Trim();
                    if (DateTime.TryParseExact(dateStr, "yyyy-MM-dd", null, DateTimeStyles.None, out var date1))
                        birthDate = date1;
                    else if (DateTime.TryParseExact(dateStr, "dd.MM.yyyy", null, DateTimeStyles.None, out var date2))
                        birthDate = date2;
                    else if (DateTime.TryParse(dateStr, out var date3))
                        birthDate = date3;
                    else
                        _logger.LogWarning("Could not parse birth date: '{DateStr}'", dateStr);
                }

                // Parse gender
                Gender gender = Gender.Other;
                if (parts.Length > 3 && !string.IsNullOrWhiteSpace(parts[3]))
                {
                    var genderStr = parts[3].Trim().ToUpperInvariant();
                    gender = genderStr switch
                    {
                        "M" => Gender.Male,
                        "F" => Gender.Female,
                        "W" => Gender.Female, // German: Weiblich
                        _ => Gender.Other
                    };
                }

                // Parse study description
                string? studyDescription = null;
                if (parts.Length > 4 && !string.IsNullOrWhiteSpace(parts[4]))
                {
                    studyDescription = parts[4].Trim();
                }

                // Create patient info
                var patientInfo = new PatientInfo(
                    id: new PatientId(examId),
                    name: patientName,
                    birthDate: birthDate,
                    gender: gender
                );

                // Create study info
                var studyInfo = new StudyInfo(
                    studyId: new StudyId($"S{examId.Substring(0, Math.Min(examId.Length, 14))}"), // Max 16 chars
                    examId: examId,
                    description: studyDescription ?? "Clinical Photography",
                    modality: "VL", // Visible Light photography
                    studyDate: DateTime.Now
                );

                _logger.LogInformation("Successfully parsed barcode: ExamId={ExamId}, Patient={PatientName}, Study={StudyDescription}",
                    examId, patientName, studyDescription);

                return (patientInfo, studyInfo);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error parsing barcode data");
                return CreateDefaultPatientAndStudy();
            }
        }

        /// <summary>
        /// Cleans barcode data by fixing common encoding issues from Ricoh cameras
        /// </summary>
        private string CleanBarcodeData(string barcodeData)
        {
            if (string.IsNullOrEmpty(barcodeData))
                return barcodeData;

            // Ricoh G900 II specific character replacements
            // The camera seems to use Windows-1252 encoding
            var cleaned = barcodeData;

            // Apply replacements one by one to avoid dictionary key conflicts
            // Common German umlauts
            cleaned = cleaned.Replace("�", "ö");    // Most common encoding issue
            cleaned = cleaned.Replace("÷", "ö");    // Alternative encoding
            cleaned = cleaned.Replace("õ", "ä");
            cleaned = cleaned.Replace("³", "ü");
            cleaned = cleaned.Replace("Í", "Ö");
            cleaned = cleaned.Replace("─", "Ä");
            cleaned = cleaned.Replace("▄", "Ü");
            cleaned = cleaned.Replace("á", "ß");

            // French characters
            cleaned = cleaned.Replace("Ó", "à");
            cleaned = cleaned.Replace("Þ", "è");
            cleaned = cleaned.Replace("Ú", "é");
            cleaned = cleaned.Replace("Û", "ê");
            cleaned = cleaned.Replace("¶", "ç");

            // Spanish/Portuguese
            cleaned = cleaned.Replace("±", "ñ");
            cleaned = cleaned.Replace("ã", "ã");
            cleaned = cleaned.Replace("Ž", "õ");

            // Other common replacements
            cleaned = cleaned.Replace("Æ", "°");    // degree symbol
            cleaned = cleaned.Replace("º", "€");    // Euro symbol

            // Remove any control characters
            cleaned = Regex.Replace(cleaned, @"[\x00-\x1F\x7F]", "");

            // Trim whitespace
            cleaned = cleaned.Trim();

            if (cleaned != barcodeData)
            {
                _logger.LogDebug("Cleaned barcode data: '{Original}' -> '{Cleaned}'", barcodeData, cleaned);
            }

            return cleaned;
        }

        private (PatientInfo, StudyInfo) CreateDefaultPatientAndStudy()
        {
            var timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
            var shortTimestamp = DateTime.Now.ToString("MMddHHmm"); // Shorter for StudyId

            var patientInfo = new PatientInfo(
                id: new PatientId($"AUTO_{timestamp}"),
                name: "Unknown Patient",
                birthDate: null,
                gender: Gender.Other
            );

            var studyInfo = new StudyInfo(
                studyId: new StudyId($"S{shortTimestamp}"), // Max 16 chars
                examId: $"AUTO_{timestamp}",
                description: "Unidentified Clinical Photography",
                modality: "VL",
                studyDate: DateTime.Now
            );

            _logger.LogWarning("Created default patient/study info with ID: AUTO_{Timestamp}", timestamp);

            return (patientInfo, studyInfo);
        }

        private int? GetIntValue(Dictionary<string, string> exifData, params string[] keys)
        {
            foreach (var key in keys)
            {
                if (exifData.TryGetValue(key, out var value))
                {
                    // Handle values like "8 8 8" for BitsPerSample
                    var firstValue = value.Split(' ')[0];

                    if (int.TryParse(firstValue, out var result))
                        return result;
                }
            }
            return null;
        }

        private DateTime? GetDateTime(Dictionary<string, string> exifData, params string[] keys)
        {
            foreach (var key in keys)
            {
                if (exifData.TryGetValue(key, out var value))
                {
                    // EXIF datetime format: "yyyy:MM:dd HH:mm:ss"
                    if (DateTime.TryParseExact(value, "yyyy:MM:dd HH:mm:ss",
                        CultureInfo.InvariantCulture, DateTimeStyles.None, out var result))
                        return result;

                    // Try standard parse as fallback
                    if (DateTime.TryParse(value, out result))
                        return result;
                }
            }
            return null;
        }

        private string GenerateUid()
        {
            // Simple UID generation - in production use proper DICOM UID generation
            return $"1.2.826.0.1.3680043.8.498.{DateTime.Now.Ticks}";
        }
    }
}

===== FILE: tests\CamBridge.PipelineTest\Program.cs =====
using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Logging;

namespace CamBridge.PipelineTest
{
    class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("=== CamBridge Pipeline Test v0.5.22 ===");
            Console.WriteLine("© 2025 Claude's Improbably Reliable Software Solutions\n");

            // Test file
            var testFile = "R0010168.JPG";
            
            if (!File.Exists(testFile))
            {
                Console.WriteLine($"ERROR: Test file not found: {testFile}");
                Console.WriteLine($"Current directory: {Directory.GetCurrentDirectory()}");
                Console.WriteLine("\nPlease copy R0010168.JPG to this directory!");
                Console.ReadKey();
                return;
            }

            Console.WriteLine($"✅ Found test file: {testFile}");
            var fileInfo = new FileInfo(testFile);
            Console.WriteLine($"   Size: {fileInfo.Length:N0} bytes");
            Console.WriteLine($"   Modified: {fileInfo.LastWriteTime}");

            // Run direct ExifTool test first
            Console.WriteLine("\n=== Part 1: Direct ExifTool Test ===");
            RunDirectExifToolTest(testFile);

            // Now test our ExifToolReader
            Console.WriteLine("\n=== Part 2: ExifToolReader Integration Test ===");
            await TestExifToolReader(testFile);

            Console.WriteLine("\nPress any key to exit...");
            Console.ReadKey();
        }

        static void RunDirectExifToolTest(string testFile)
        {
            // Find ExifTool
            var exifToolPaths = new[]
            {
                @"..\..\Tools\exiftool.exe",
                @"..\..\..\Tools\exiftool.exe",
                @"Tools\exiftool.exe",
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Tools", "exiftool.exe")
            };

            string? exifToolPath = null;
            foreach (var path in exifToolPaths)
            {
                if (File.Exists(path))
                {
                    exifToolPath = path;
                    break;
                }
            }

            if (exifToolPath == null)
            {
                Console.WriteLine("❌ ExifTool not found for direct test");
                return;
            }

            Console.WriteLine($"✅ Found ExifTool: {exifToolPath}");

            // Look specifically for Barcode field
            Console.WriteLine("\nSearching for Barcode field:");
            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = exifToolPath,
                    Arguments = $"-Barcode -UserComment \"{testFile}\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();

            Console.WriteLine(output);
        }

        static async Task TestExifToolReader(string testFile)
        {
            try
            {
                // Create a simple console logger
                var logger = new ConsoleLogger();

                // Create ExifToolReader with 5 second timeout
                var reader = new ExifToolReader(logger, 5000);
                Console.WriteLine("✅ ExifToolReader created successfully");

                // Extract metadata
                Console.WriteLine("\nExtracting metadata...");
                var metadata = await reader.ExtractMetadataAsync(testFile);

                Console.WriteLine("\n✅ Metadata extracted successfully!");

                // Display results
                Console.WriteLine("\n--- PATIENT INFO ---");
                Console.WriteLine($"ID: {metadata.Patient.Id.Value}");
                Console.WriteLine($"Name: {metadata.Patient.Name}");
                Console.WriteLine($"Birth Date: {metadata.Patient.BirthDate?.ToString("yyyy-MM-dd") ?? "N/A"}");
                Console.WriteLine($"Gender: {metadata.Patient.Gender}");

                Console.WriteLine("\n--- STUDY INFO ---");
                Console.WriteLine($"Study ID: {metadata.Study.StudyId.Value}");
                Console.WriteLine($"Exam ID: {metadata.Study.ExamId}");
                Console.WriteLine($"Description: {metadata.Study.Description}");
                Console.WriteLine($"Modality: {metadata.Study.Modality}");
                Console.WriteLine($"Study Date: {metadata.Study.StudyDate:yyyy-MM-dd HH:mm:ss}");

                Console.WriteLine("\n--- TECHNICAL DATA ---");
                Console.WriteLine($"Manufacturer: {metadata.TechnicalData.Manufacturer}");
                Console.WriteLine($"Model: {metadata.TechnicalData.Model}");
                Console.WriteLine($"Image Size: {metadata.TechnicalData.ImageWidth}x{metadata.TechnicalData.ImageHeight}");

                Console.WriteLine("\n--- RAW DATA ---");
                Console.WriteLine($"Barcode Data: {metadata.BarcodeData ?? "N/A"}");
                Console.WriteLine($"User Comment: {metadata.UserComment ?? "N/A"}");

                Console.WriteLine("\n--- EXIF FIELDS (First 10) ---");
                int count = 0;
                foreach (var kvp in metadata.ExifData)
                {
                    Console.WriteLine($"{kvp.Key}: {kvp.Value}");
                    if (++count >= 10) break;
                }

                // Success!
                Console.WriteLine("\n🎉 SUCCESS! ExifToolReader is working correctly!");
                
                // Check if we found the expected data
                if (metadata.Patient.Id.Value == "EX002" && 
                    metadata.Patient.Name.Contains("Schmidt"))
                {
                    Console.WriteLine("✅ QRBridge data parsed correctly!");
                }
                else
                {
                    Console.WriteLine("⚠️ QRBridge data may not have been parsed correctly");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\n❌ ERROR: {ex.Message}");
                Console.WriteLine($"Stack trace:\n{ex.StackTrace}");
            }
        }
    }

    // Simple console logger for testing
    public class ConsoleLogger : ILogger<ExifToolReader>
    {
        public IDisposable BeginScope<TState>(TState state) => null!;
        public bool IsEnabled(LogLevel logLevel) => true;
        
        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
        {
            var message = formatter(state, exception);
            var prefix = logLevel switch
            {
                LogLevel.Error => "❌ ERROR",
                LogLevel.Warning => "⚠️  WARN",
                LogLevel.Information => "ℹ️  INFO",
                LogLevel.Debug => "🔍 DEBUG",
                _ => "📝 LOG"
            };
            
            Console.WriteLine($"{prefix}: {message}");
            
            if (exception != null)
            {
                Console.WriteLine($"   Exception: {exception.Message}");
            }
        }
    }
}

===== FILE: tests\CamBridge.TestConsole\Program.cs =====
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Entities;
using CamBridge.Core.ValueObjects;
using CamBridge.Core.Interfaces;
using CamBridge.Infrastructure.Services;
using FellowOakDicom;
using FoDicomTag = FellowOakDicom.DicomTag;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Runtime.Versioning;

namespace CamBridge.TestConsole
{
    /// <summary>
    /// Test console application for validating Ricoh G900 II JPEG to DICOM conversion
    /// </summary>
    [SupportedOSPlatform("windows")]
    class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("===========================================");
            Console.WriteLine("CamBridge Core Test - Ricoh G900 II JPEG");
            Console.WriteLine("© 2025 Claude's Improbably Reliable Software Solutions");
            Console.WriteLine("===========================================\n");

            if (args.Length == 0)
            {
                Console.WriteLine("Usage: CamBridge.TestConsole <path-to-ricoh-jpeg>");
                Console.WriteLine("Example: CamBridge.TestConsole C:\\Test\\ricoh_test.jpg");
                return;
            }

            var inputFile = args[0];
            if (!File.Exists(inputFile))
            {
                Console.WriteLine($"ERROR: File not found: {inputFile}");
                return;
            }

            try
            {
                // Setup dependency injection
                var services = new ServiceCollection();
                ConfigureServices(services);

                using var serviceProvider = services.BuildServiceProvider();
                var testRunner = serviceProvider.GetRequiredService<RicohTestRunner>();

                await testRunner.RunTestAsync(inputFile);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\nFATAL ERROR: {ex.Message}");
                Console.WriteLine(ex.StackTrace);
            }

            Console.WriteLine("\nPress any key to exit...");
            Console.ReadKey();
        }

        static void ConfigureServices(IServiceCollection services)
        {
            // Logging
            services.AddLogging(builder =>
            {
                builder.AddConsole();
                builder.SetMinimumLevel(LogLevel.Debug);
            });

            // CamBridge Core Services - ExifTool only!
            services.AddSingleton<ExifToolReader>(sp =>
            {
                var logger = sp.GetRequiredService<ILogger<ExifToolReader>>();
                return new ExifToolReader(logger);
            });

            services.AddSingleton<IDicomTagMapper, DicomTagMapper>();
            services.AddSingleton<IMappingConfiguration, CustomMappingConfiguration>(sp =>
            {
                var config = new CustomMappingConfiguration();
                // Load default mappings
                var loader = new MappingConfigurationLoader(sp.GetRequiredService<ILogger<MappingConfigurationLoader>>());
                var mappingsPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "mappings.json");

                if (File.Exists(mappingsPath))
                {
                    var loadedConfig = loader.LoadFromFileAsync(mappingsPath).Result;
                    foreach (var rule in loadedConfig.GetMappingRules())
                    {
                        config.AddRule(rule);
                    }
                    Console.WriteLine($"Loaded {loadedConfig.GetMappingRules().Count} mapping rules from {mappingsPath}");
                }
                else
                {
                    Console.WriteLine("No mappings.json found, using default configuration");
                    return IMappingConfiguration.GetDefault() as CustomMappingConfiguration ?? new CustomMappingConfiguration();
                }

                return config;
            });

            // DicomConverter with dependencies
            services.AddSingleton<IDicomConverter, DicomConverter>();
            services.AddSingleton<IFileProcessor, FileProcessor>();

            // Settings
            services.Configure<ProcessingOptions>(options =>
            {
                options.CreateBackup = false;
                options.SuccessAction = PostProcessingAction.Leave;
                options.MinimumFileSizeBytes = 1024;
                options.MaximumFileSizeBytes = 100 * 1024 * 1024;
            });

            services.Configure<CamBridgeSettings>(settings =>
            {
                settings.DefaultOutputFolder = Path.Combine(Environment.CurrentDirectory, "output");
                settings.Dicom.ValidateAfterCreation = true;
                settings.Dicom.InstitutionName = "Test Hospital";
            });

            // Test runner
            services.AddTransient<RicohTestRunner>();
        }
    }

    /// <summary>
    /// Main test runner for Ricoh JPEG processing
    /// </summary>
    [SupportedOSPlatform("windows")]
    public class RicohTestRunner
    {
        private readonly ILogger<RicohTestRunner> _logger;
        private readonly ExifToolReader _exifToolReader;  // Direct dependency!
        private readonly IDicomConverter _dicomConverter;
        private readonly IFileProcessor _fileProcessor;

        public RicohTestRunner(
            ILogger<RicohTestRunner> logger,
            ExifToolReader exifToolReader,  // Direct dependency!
            IDicomConverter dicomConverter,
            IFileProcessor fileProcessor)
        {
            _logger = logger;
            _exifToolReader = exifToolReader;
            _dicomConverter = dicomConverter;
            _fileProcessor = fileProcessor;
        }

        public async Task RunTestAsync(string inputFile)
        {
            Console.WriteLine($"\n1. ANALYZING INPUT FILE: {Path.GetFileName(inputFile)}");
            Console.WriteLine($"   File size: {new FileInfo(inputFile).Length:N0} bytes");

            // Step 1: Extract metadata using ExifToolReader
            Console.WriteLine("\n2. EXTRACTING METADATA WITH EXIFTOOL:");
            try
            {
                var metadata = await _exifToolReader.ExtractMetadataAsync(inputFile);

                Console.WriteLine($"   ✓ Successfully extracted metadata");
                Console.WriteLine($"   Patient: {metadata.Patient.Name} (ID: {metadata.Patient.PatientId})");
                Console.WriteLine($"   Study: {metadata.Study.StudyId} - {metadata.Study.StudyDescription}");
                Console.WriteLine($"   Capture Date: {metadata.CaptureDateTime}");
                Console.WriteLine($"   EXIF Tags found: {metadata.ExifData.Count}");

                // Show some key EXIF data
                if (metadata.ExifData.TryGetValue("Barcode", out var barcode))
                {
                    Console.WriteLine($"   Barcode field: {barcode}");
                }
                if (metadata.ExifData.TryGetValue("UserComment", out var userComment))
                {
                    Console.WriteLine($"   UserComment field: {userComment}");
                }

                // Show technical data
                if (metadata.TechnicalData != null)
                {
                    Console.WriteLine($"\n   Technical Data:");
                    Console.WriteLine($"   - Camera: {metadata.TechnicalData.Manufacturer} {metadata.TechnicalData.Model}");
                    Console.WriteLine($"   - Dimensions: {metadata.TechnicalData.ImageWidth}x{metadata.TechnicalData.ImageHeight}");
                    Console.WriteLine($"   - Software: {metadata.TechnicalData.Software}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"   ❌ Failed to extract metadata: {ex.Message}");
                return; // Can't continue without metadata
            }

            // Step 2: Process through full pipeline
            Console.WriteLine("\n3. PROCESSING THROUGH FULL PIPELINE:");
            var outputDir = Path.Combine(Environment.CurrentDirectory, "output");
            Directory.CreateDirectory(outputDir);

            var result = await _fileProcessor.ProcessFileAsync(inputFile);

            if (result.Success && !string.IsNullOrEmpty(result.OutputFile))
            {
                Console.WriteLine($"   ✓ SUCCESS! Output: {result.OutputFile}");
                Console.WriteLine($"   Processing time: {result.ProcessingTime.TotalMilliseconds:F0}ms");

                // Step 3: Analyze generated DICOM
                await AnalyzeDicomFileAsync(result.OutputFile);
            }
            else
            {
                Console.WriteLine($"   ❌ FAILED: {result.ErrorMessage}");

                // Try direct conversion for debugging
                Console.WriteLine("\n4. ATTEMPTING DIRECT CONVERSION (DEBUG MODE):");
                await TestDirectConversionAsync(inputFile);
            }
        }

        private async Task AnalyzeDicomFileAsync(string dicomPath)
        {
            Console.WriteLine("\n4. ANALYZING GENERATED DICOM:");

            try
            {
                var dicomFile = await DicomFile.OpenAsync(dicomPath);
                var dataset = dicomFile.Dataset;

                Console.WriteLine("   Patient Information:");
                Console.WriteLine($"   - Name: {dataset.GetString(FoDicomTag.PatientName)}");
                Console.WriteLine($"   - ID: {dataset.GetString(FoDicomTag.PatientID)}");
                Console.WriteLine($"   - Birth Date: {dataset.GetString(FoDicomTag.PatientBirthDate)}");
                Console.WriteLine($"   - Sex: {dataset.GetString(FoDicomTag.PatientSex)}");

                Console.WriteLine("\n   Study Information:");
                Console.WriteLine($"   - Study ID: {dataset.GetString(FoDicomTag.StudyID)}");
                Console.WriteLine($"   - Study Date: {dataset.GetString(FoDicomTag.StudyDate)}");
                Console.WriteLine($"   - Study Description: {dataset.GetString(FoDicomTag.StudyDescription)}");
                Console.WriteLine($"   - Modality: {dataset.GetString(FoDicomTag.Modality)}");

                Console.WriteLine("\n   Technical Information:");
                Console.WriteLine($"   - Manufacturer: {dataset.GetString(FoDicomTag.Manufacturer)}");
                Console.WriteLine($"   - Model: {dataset.GetString(FoDicomTag.ManufacturerModelName)}");
                Console.WriteLine($"   - Transfer Syntax: {dicomFile.FileMetaInfo.TransferSyntax}");
                Console.WriteLine($"   - SOP Class: {dataset.GetString(FoDicomTag.SOPClassUID)}");

                // Check for pixel data
                if (dataset.Contains(FoDicomTag.PixelData))
                {
                    var pixelData = dataset.GetDicomItem<DicomOtherByteFragment>(FoDicomTag.PixelData);
                    Console.WriteLine($"\n   Pixel Data: ✓ Present ({pixelData.Fragments.Count} fragments)");
                }
                else
                {
                    Console.WriteLine("\n   Pixel Data: ❌ MISSING!");
                }

                // Validate
                var validationResult = await _dicomConverter.ValidateDicomFileAsync(dicomPath);
                Console.WriteLine($"\n   Validation: {(validationResult.IsValid ? "✓ PASSED" : "❌ FAILED")}");

                if (!validationResult.IsValid)
                {
                    foreach (var error in validationResult.Errors)
                    {
                        Console.WriteLine($"   - ERROR: {error}");
                    }
                }

                foreach (var warning in validationResult.Warnings)
                {
                    Console.WriteLine($"   - WARNING: {warning}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"   ❌ Error analyzing DICOM: {ex.Message}");
            }
        }

        private async Task TestDirectConversionAsync(string inputFile)
        {
            try
            {
                // Get metadata from ExifToolReader
                var metadata = await _exifToolReader.ExtractMetadataAsync(inputFile);

                var outputPath = Path.Combine(Environment.CurrentDirectory, "output", "debug_test.dcm");
                var result = await _dicomConverter.ConvertToDicomAsync(inputFile, outputPath, metadata);

                if (result.Success)
                {
                    Console.WriteLine($"   ✓ Direct conversion succeeded: {result.DicomFilePath}");
                    if (!string.IsNullOrEmpty(result.DicomFilePath))
                    {
                        await AnalyzeDicomFileAsync(result.DicomFilePath);
                    }
                }
                else
                {
                    Console.WriteLine($"   ❌ Direct conversion failed: {result.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"   ❌ Exception during direct conversion: {ex.Message}");
            }
        }
    }
}

===== FILE: src\CamBridge.Infrastructure\Services\FileProcessor.cs =====
// src\CamBridge.Infrastructure\Services\FileProcessor.cs
// Version: 0.5.26
// Complete file with fixed GenerateOutputFileName method

using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Entities;
using CamBridge.Core.Interfaces;
using CamBridge.Core.ValueObjects;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Orchestrates the complete JPEG to DICOM conversion process
    /// </summary>
    public class FileProcessor : IFileProcessor
    {
        private readonly ILogger<FileProcessor> _logger;
        private readonly ExifToolReader _exifToolReader; // Direct dependency - no interface!
        private readonly IDicomConverter _dicomConverter;
        private readonly ProcessingOptions _processingOptions;
        private readonly CamBridgeSettings _settings;

        public event EventHandler<FileProcessingEventArgs>? ProcessingStarted;
        public event EventHandler<FileProcessingEventArgs>? ProcessingCompleted;
        public event EventHandler<FileProcessingErrorEventArgs>? ProcessingError;

        public FileProcessor(
            ILogger<FileProcessor> logger,
            ExifToolReader exifToolReader,  // No interface!
            IDicomConverter dicomConverter,
            IOptions<ProcessingOptions> processingOptions,
            IOptions<CamBridgeSettings> settings)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _exifToolReader = exifToolReader ?? throw new ArgumentNullException(nameof(exifToolReader));
            _dicomConverter = dicomConverter ?? throw new ArgumentNullException(nameof(dicomConverter));
            _processingOptions = processingOptions?.Value ?? throw new ArgumentNullException(nameof(processingOptions));
            _settings = settings?.Value ?? throw new ArgumentNullException(nameof(settings));
        }

        /// <inheritdoc />
        public async Task<FileProcessingResult> ProcessFileAsync(string filePath)
        {
            if (string.IsNullOrWhiteSpace(filePath))
                throw new ArgumentException("File path cannot be null or empty", nameof(filePath));

            var stopwatch = Stopwatch.StartNew();

            try
            {
                _logger.LogInformation("Starting processing of {FilePath}", filePath);
                ProcessingStarted?.Invoke(this, new FileProcessingEventArgs(filePath));

                // Validate file
                if (!File.Exists(filePath))
                {
                    throw new FileNotFoundException($"File not found: {filePath}");
                }

                var fileInfo = new FileInfo(filePath);
                ValidateFile(fileInfo);

                // Create backup if configured
                if (_processingOptions.CreateBackup)
                {
                    await CreateBackupAsync(fileInfo);
                }

                // Extract metadata - simplified with new pipeline!
                var metadata = await ExtractMetadataAsync(filePath);

                // Determine output path
                var outputPath = DetermineOutputPath(metadata, filePath);

                // Convert to DICOM
                var conversionResult = await _dicomConverter.ConvertToDicomAsync(
                    filePath,
                    outputPath,
                    metadata);

                if (!conversionResult.Success)
                {
                    throw new InvalidOperationException(
                        $"DICOM conversion failed: {conversionResult.ErrorMessage}");
                }

                // Validate DICOM if configured
                if (_settings.Dicom.ValidateAfterCreation)
                {
                    var validationResult = await _dicomConverter.ValidateDicomFileAsync(outputPath);
                    if (!validationResult.IsValid)
                    {
                        _logger.LogWarning("DICOM validation warnings: {Warnings}",
                            string.Join("; ", validationResult.Warnings));
                    }
                }

                // Handle source file based on success
                await HandleSourceFileAsync(filePath, _processingOptions.SuccessAction);

                stopwatch.Stop();
                var result = FileProcessingResult.CreateSuccess(filePath, outputPath, stopwatch.Elapsed);

                _logger.LogInformation("Successfully processed {FilePath} to {OutputPath} in {ElapsedMs}ms",
                    filePath, outputPath, stopwatch.ElapsedMilliseconds);

                ProcessingCompleted?.Invoke(this, new FileProcessingEventArgs(filePath));
                return result;
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                _logger.LogError(ex, "Error processing file {FilePath}", filePath);

                ProcessingError?.Invoke(this, new FileProcessingErrorEventArgs(filePath, ex));

                // Handle source file based on failure
                try
                {
                    await HandleSourceFileAsync(filePath, _processingOptions.FailureAction);
                }
                catch (Exception moveEx)
                {
                    _logger.LogError(moveEx, "Error handling failed file {FilePath}", filePath);
                }

                return FileProcessingResult.CreateFailure(filePath, ex.Message, stopwatch.Elapsed);
            }
        }

        /// <inheritdoc />
        public bool ShouldProcessFile(string filePath)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
                    return false;

                var fileInfo = new FileInfo(filePath);

                // Check file extension
                var extension = fileInfo.Extension.ToLowerInvariant();
                if (extension != ".jpg" && extension != ".jpeg")
                    return false;

                // Check file size
                if (fileInfo.Length < _processingOptions.MinimumFileSizeBytes ||
                    fileInfo.Length > _processingOptions.MaximumFileSizeBytes)
                {
                    _logger.LogDebug("File {FilePath} size {Size} outside configured range",
                        filePath, fileInfo.Length);
                    return false;
                }

                // Check file age
                if (_processingOptions.MaxFileAge.HasValue)
                {
                    var fileAge = DateTime.UtcNow - fileInfo.CreationTimeUtc;
                    if (fileAge > _processingOptions.MaxFileAge.Value)
                    {
                        _logger.LogDebug("File {FilePath} is too old ({Age} days)",
                            filePath, fileAge.TotalDays);
                        return false;
                    }
                }

                // Check if file is still being written
                if (!IsFileReady(filePath))
                {
                    _logger.LogDebug("File {FilePath} is not ready (still being written)",
                        filePath);
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking if file should be processed: {FilePath}", filePath);
                return false;
            }
        }

        /// <summary>
        /// Simplified metadata extraction using the new ExifToolReader
        /// </summary>
        private async Task<ImageMetadata> ExtractMetadataAsync(string filePath)
        {
            // ExifToolReader does all the heavy lifting now!
            var metadata = await _exifToolReader.ExtractMetadataAsync(filePath);

            _logger.LogInformation("Extracted metadata for {Patient} - {Study}",
                metadata.Patient.Id.Value, metadata.Study.StudyId.Value);

            return metadata;
        }

        private string DetermineOutputPath(ImageMetadata metadata, string sourcePath)
        {
            // Find the matching watch folder configuration
            FolderConfiguration? folderConfig = null;
            foreach (var watchFolder in _settings.WatchFolders)
            {
                if (sourcePath.StartsWith(watchFolder.Path, StringComparison.OrdinalIgnoreCase))
                {
                    folderConfig = watchFolder;
                    break;
                }
            }

            // Determine base output folder
            var baseOutputFolder = folderConfig?.OutputPath ?? _settings.DefaultOutputFolder;

            // Apply output organization
            var organizedPath = ApplyOutputOrganization(baseOutputFolder, metadata);

            // Generate filename
            var fileName = GenerateOutputFileName(metadata);

            return Path.Combine(organizedPath, fileName);
        }

        private string ApplyOutputOrganization(string baseFolder, ImageMetadata metadata)
        {
            var path = baseFolder;

            switch (_processingOptions.OutputOrganization)
            {
                case OutputOrganization.ByPatient:
                    path = Path.Combine(path, SanitizePathComponent(metadata.Patient.Id.Value));
                    break;

                case OutputOrganization.ByDate:
                    path = Path.Combine(path, metadata.Study.StudyDate.ToString("yyyy-MM-dd"));
                    break;

                case OutputOrganization.ByPatientAndDate:
                    path = Path.Combine(path,
                        SanitizePathComponent(metadata.Patient.Id.Value),
                        metadata.Study.StudyDate.ToString("yyyy-MM-dd"));
                    break;
            }

            // Ensure directory exists
            Directory.CreateDirectory(path);
            return path;
        }

        private string GenerateOutputFileName(ImageMetadata metadata)
        {
            var pattern = _processingOptions.OutputFilePattern;

            // Replace tokens - fixed version with proper string assignment
            string fileName = pattern;
            fileName = fileName.Replace("{PatientID}", SanitizeFileName(metadata.Patient.Id.Value));
            fileName = fileName.Replace("{PatientName}", SanitizeFileName(metadata.Patient.Name));
            fileName = fileName.Replace("{StudyDate}", metadata.Study.StudyDate.ToString("yyyyMMdd"));
            fileName = fileName.Replace("{StudyID}", SanitizeFileName(metadata.Study.StudyId.Value));
            fileName = fileName.Replace("{ExamID}", SanitizeFileName(metadata.Study.ExamId ?? ""));
            fileName = fileName.Replace("{InstanceNumber}", metadata.InstanceNumber.ToString("D4"));
            fileName = fileName.Replace("{Timestamp}", DateTime.UtcNow.ToString("yyyyMMddHHmmss"));

            // Ensure .dcm extension
            if (!fileName.EndsWith(".dcm", StringComparison.OrdinalIgnoreCase))
            {
                fileName += ".dcm";
            }

            return fileName;
        }

        private async Task CreateBackupAsync(FileInfo fileInfo)
        {
            var backupPath = Path.Combine(
                _processingOptions.BackupFolder,
                DateTime.UtcNow.ToString("yyyy-MM-dd"),
                fileInfo.Name);

            var backupDir = Path.GetDirectoryName(backupPath)!;
            Directory.CreateDirectory(backupDir);

            await CopyFileAsync(fileInfo.FullName, backupPath);
            _logger.LogDebug("Created backup of {SourceFile} at {BackupPath}",
                fileInfo.FullName, backupPath);
        }

        private async Task HandleSourceFileAsync(string filePath, PostProcessingAction action)
        {
            switch (action)
            {
                case PostProcessingAction.Archive:
                    var archivePath = Path.Combine(
                        _processingOptions.ArchiveFolder,
                        DateTime.UtcNow.ToString("yyyy-MM-dd"),
                        Path.GetFileName(filePath));

                    var archiveDir = Path.GetDirectoryName(archivePath)!;
                    Directory.CreateDirectory(archiveDir);

                    await MoveFileAsync(filePath, archivePath);
                    _logger.LogInformation("Archived {SourceFile} to {ArchivePath}",
                        filePath, archivePath);
                    break;

                case PostProcessingAction.Delete:
                    File.Delete(filePath);
                    _logger.LogInformation("Deleted source file {FilePath}", filePath);
                    break;

                case PostProcessingAction.MoveToError:
                    var errorPath = Path.Combine(
                        _processingOptions.ErrorFolder,
                        DateTime.UtcNow.ToString("yyyy-MM-dd"),
                        Path.GetFileName(filePath));

                    var errorDir = Path.GetDirectoryName(errorPath)!;
                    Directory.CreateDirectory(errorDir);

                    await MoveFileAsync(filePath, errorPath);
                    _logger.LogWarning("Moved failed file {SourceFile} to {ErrorPath}",
                        filePath, errorPath);
                    break;

                case PostProcessingAction.Leave:
                default:
                    // Do nothing
                    break;
            }
        }

        private void ValidateFile(FileInfo fileInfo)
        {
            if (fileInfo.Length < _processingOptions.MinimumFileSizeBytes)
            {
                throw new InvalidOperationException(
                    $"File too small: {fileInfo.Length} bytes (minimum: {_processingOptions.MinimumFileSizeBytes})");
            }

            if (fileInfo.Length > _processingOptions.MaximumFileSizeBytes)
            {
                throw new InvalidOperationException(
                    $"File too large: {fileInfo.Length} bytes (maximum: {_processingOptions.MaximumFileSizeBytes})");
            }
        }

        private bool IsFileReady(string filePath)
        {
            try
            {
                using (var stream = File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.None))
                {
                    return true;
                }
            }
            catch (IOException)
            {
                return false;
            }
        }

        private async Task CopyFileAsync(string source, string destination)
        {
            using var sourceStream = new FileStream(source, FileMode.Open, FileAccess.Read, FileShare.Read);
            using var destStream = new FileStream(destination, FileMode.Create, FileAccess.Write, FileShare.None);
            await sourceStream.CopyToAsync(destStream);
        }

        private async Task MoveFileAsync(string source, string destination)
        {
            // Try direct move first
            try
            {
                File.Move(source, destination, true);
            }
            catch (IOException)
            {
                // Fall back to copy and delete
                await CopyFileAsync(source, destination);
                File.Delete(source);
            }
        }

        private string SanitizeFileName(string fileName)
        {
            var invalid = Path.GetInvalidFileNameChars();
            return string.Join("_", fileName.Split(invalid, StringSplitOptions.RemoveEmptyEntries));
        }

        private string SanitizePathComponent(string pathComponent)
        {
            var invalid = Path.GetInvalidPathChars();
            return string.Join("_", pathComponent.Split(invalid, StringSplitOptions.RemoveEmptyEntries));
        }
    }
}

===== FILE: src\CamBridge.Core\Entities\ImageMetadata.cs =====
using System;
using System.Collections.Generic;

namespace CamBridge.Core.Entities
{
    /// <summary>
    /// Complete metadata extracted from a medical image file
    /// </summary>
    public class ImageMetadata
    {
        public string SourceFilePath { get; }
        public DateTime CaptureDateTime { get; }
        public PatientInfo Patient { get; }
        public StudyInfo Study { get; }
        public ImageTechnicalData TechnicalData { get; }
        public string? UserComment { get; }
        public string? BarcodeData { get; }
        public int InstanceNumber { get; }
        public string InstanceUid { get; }
        public Dictionary<string, string> ExifData { get; }

        public ImageMetadata(
            string sourceFilePath,
            DateTime captureDateTime,
            PatientInfo patient,
            StudyInfo study,
            ImageTechnicalData technicalData,
            string? userComment = null,
            string? barcodeData = null,
            int instanceNumber = 1,
            string? instanceUid = null,
            Dictionary<string, string>? exifData = null)
        {
            SourceFilePath = sourceFilePath ?? throw new ArgumentNullException(nameof(sourceFilePath));
            CaptureDateTime = captureDateTime;
            Patient = patient ?? throw new ArgumentNullException(nameof(patient));
            Study = study ?? throw new ArgumentNullException(nameof(study));
            TechnicalData = technicalData ?? throw new ArgumentNullException(nameof(technicalData));
            UserComment = userComment;
            BarcodeData = barcodeData;
            InstanceNumber = instanceNumber;
            InstanceUid = instanceUid ?? GenerateUid();
            ExifData = exifData ?? new Dictionary<string, string>();
        }

        private static string GenerateUid()
        {
            // Generate a DICOM compliant UID
            var timestamp = DateTime.UtcNow.ToString("yyyyMMddHHmmss");
            var random = new Random().Next(1000, 9999);
            return $"1.2.276.0.7230010.3.1.4.{timestamp}.{random}";
        }
    }
}

