// src/CamBridge.Infrastructure/Services/PipelineManager.cs
// Version: 0.8.0
// Description: Orchestrates multiple processing pipelines with PACS upload support
// Copyright: &#169; 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Manages multiple processing pipelines with independent configurations, queues, watchers, FileProcessors, and PACS upload queues!
    /// ENHANCED: Each pipeline can have its own PACS upload queue for automatic transmission
    /// </summary>
    public class PipelineManager : IDisposable
    {
        private readonly ILogger<PipelineManager> _logger;
        private readonly IServiceProvider _serviceProvider;
        private readonly IOptionsMonitor<CamBridgeSettingsV2> _settingsMonitor;
        private readonly ILoggerFactory _loggerFactory;
        private readonly ConcurrentDictionary<string, PipelineContext> _pipelines = new();
        private readonly SemaphoreSlim _pipelineLock = new(1, 1);
        private readonly CancellationTokenSource _cancellationTokenSource = new();
        private bool _disposed;

        public PipelineManager(
            ILogger<PipelineManager> logger,
            IServiceProvider serviceProvider,
            IOptionsMonitor<CamBridgeSettingsV2> settingsMonitor,
            ILoggerFactory loggerFactory)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
            _settingsMonitor = settingsMonitor ?? throw new ArgumentNullException(nameof(settingsMonitor));
            _loggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));

            // React to settings changes
            _settingsMonitor.OnChange(async settings =>
            {
                _logger.LogInformation("Settings changed, reconfiguring pipelines");
                await ReconfigurePipelinesAsync(settings);
            });
        }

        /// <summary>
        /// Initializes and starts all configured pipelines
        /// </summary>
        public async Task StartAsync(CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Starting Pipeline Manager");

            var settings = _settingsMonitor.CurrentValue;

            // Initialize pipelines from configuration
            foreach (var pipelineConfig in settings.Pipelines.Where(p => p.Enabled))
            {
                try
                {
                    await CreateAndStartPipelineAsync(pipelineConfig, cancellationToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to start pipeline: {PipelineName}", pipelineConfig.Name);
                }
            }

            _logger.LogInformation("Pipeline Manager started with {Count} active pipelines",
                _pipelines.Count(p => p.Value.IsActive));
        }

        /// <summary>
        /// Stops all pipelines gracefully
        /// </summary>
        public async Task StopAsync(CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Stopping Pipeline Manager");

            _cancellationTokenSource.Cancel();

            var stopTasks = _pipelines.Values
                .Where(p => p.IsActive)
                .Select(p => StopPipelineAsync(p, cancellationToken))
                .ToArray();

            await Task.WhenAll(stopTasks);

            _logger.LogInformation("Pipeline Manager stopped");
        }

        /// <summary>
        /// Enables a specific pipeline at runtime
        /// </summary>
        public async Task EnablePipelineAsync(string pipelineId, CancellationToken cancellationToken = default)
        {
            await _pipelineLock.WaitAsync(cancellationToken);
            try
            {
                if (_pipelines.TryGetValue(pipelineId, out var context))
                {
                    if (!context.IsActive)
                    {
                        context.Watcher.EnableRaisingEvents = true;
                        context.IsActive = true;
                        _logger.LogInformation("Pipeline {PipelineName} enabled", context.Configuration.Name);
                    }
                }
                else
                {
                    // Try to find in configuration and create
                    var config = _settingsMonitor.CurrentValue.Pipelines
                        .FirstOrDefault(p => p.Id.ToString() == pipelineId);

                    if (config != null)
                    {
                        config.Enabled = true;
                        await CreateAndStartPipelineAsync(config, cancellationToken);
                    }
                }
            }
            finally
            {
                _pipelineLock.Release();
            }
        }

        /// <summary>
        /// Disables a specific pipeline at runtime
        /// </summary>
        public async Task DisablePipelineAsync(string pipelineId, CancellationToken cancellationToken = default)
        {
            await _pipelineLock.WaitAsync(cancellationToken);
            try
            {
                if (_pipelines.TryGetValue(pipelineId, out var context))
                {
                    await StopPipelineAsync(context, cancellationToken);
                }
            }
            finally
            {
                _pipelineLock.Release();
            }
        }

        /// <summary>
        /// Gets the current status of all pipelines
        /// </summary>
        public List<PipelineStatus> GetPipelineStatuses()
        {
            return _pipelines.Values.Select(p => new PipelineStatus
            {
                Id = p.Configuration.Id,
                Name = p.Configuration.Name,
                IsActive = p.IsActive,
                QueueDepth = p.Queue.QueueLength,
                ProcessedCount = p.ProcessedCount,
                ErrorCount = p.ErrorCount,
                LastProcessed = p.LastProcessed,
                WatchPath = p.Configuration.WatchSettings.Path,
                OutputPath = p.Configuration.WatchSettings.OutputPath ?? "",
                PacsEnabled = p.Configuration.PacsConfiguration?.Enabled ?? false,
                PacsQueueDepth = p.PacsQueue?.QueueLength ?? 0
            }).ToList();
        }

        /// <summary>
        /// Gets detailed information about a specific pipeline
        /// </summary>
        public PipelineStatus? GetPipelineStatus(string pipelineId)
        {
            if (_pipelines.TryGetValue(pipelineId, out var context))
            {
                return new PipelineStatus
                {
                    Id = context.Configuration.Id,
                    Name = context.Configuration.Name,
                    IsActive = context.IsActive,
                    QueueDepth = context.Queue.QueueLength,
                    ProcessedCount = context.ProcessedCount,
                    ErrorCount = context.ErrorCount,
                    LastProcessed = context.LastProcessed,
                    WatchPath = context.Configuration.WatchSettings.Path,
                    OutputPath = context.Configuration.WatchSettings.OutputPath ?? "",
                    PacsEnabled = context.Configuration.PacsConfiguration?.Enabled ?? false,
                    PacsQueueDepth = context.PacsQueue?.QueueLength ?? 0
                };
            }
            return null;
        }

        private async Task CreateAndStartPipelineAsync(PipelineConfiguration config, CancellationToken cancellationToken)
        {
            if (_pipelines.ContainsKey(config.Id.ToString()))
            {
                _logger.LogWarning("Pipeline {PipelineName} ({Id}) already exists", config.Name, config.Id);
                return;
            }

            // Changed to DEBUG level - technical initialization detail
            _logger.LogDebug("Creating pipeline: {PipelineName} ({Id})", config.Name, config.Id);

            try
            {
                // Get services from DI
                var exifReader = _serviceProvider.GetRequiredService<ExifToolReader>();
                var dicomConverter = _serviceProvider.GetRequiredService<DicomConverter>();
                var globalDicomSettings = _settingsMonitor.CurrentValue.GlobalDicomSettings ?? new DicomSettings();

                // CRITICAL: Create pipeline-specific logger with sanitized name
                var sanitizedName = SanitizeForFileName(config.Name);
                var pipelineLogger = _loggerFactory.CreateLogger($"Pipeline.{sanitizedName}");

                // NEW: Create PACS upload queue if enabled
                PacsUploadQueue? pacsQueue = null;
                if (config.PacsConfiguration?.Enabled == true)
                {
                    var dicomStoreService = _serviceProvider.GetRequiredService<DicomStoreService>();
                    var pacsQueueLogger = _loggerFactory.CreateLogger<PacsUploadQueue>();

                    pacsQueue = new PacsUploadQueue(
                        config,
                        dicomStoreService,
                        pacsQueueLogger
                    );

                    _logger.LogInformation("Created PACS upload queue for pipeline {Pipeline} â†’ {Host}:{Port}",
                        config.Name,
                        config.PacsConfiguration.Host,
                        config.PacsConfiguration.Port);
                }

                // Create FileProcessor for THIS pipeline with pipeline-specific logger AND PACS queue
                var fileProcessor = new FileProcessor(
                    pipelineLogger,  // Use pipeline-specific logger!
                    exifReader,
                    dicomConverter,
                    config,
                    globalDicomSettings,
                    tagMapper: null,  // TODO: Wire up when mapping is needed
                    mappingConfiguration: null,  // TODO: Wire up when mapping is needed
                    pacsUploadQueue: pacsQueue  // NEW: Pass PACS queue to FileProcessor
                );

                // Create processing queue for this pipeline
                var processingOptions = Microsoft.Extensions.Options.Options.Create(config.ProcessingOptions);
                var queue = new ProcessingQueue(
                    _loggerFactory.CreateLogger<ProcessingQueue>(),
                    fileProcessor,
                    processingOptions
                );

                // Create file system watcher
                var watcher = CreateFileSystemWatcher(config.WatchSettings);

                // Create pipeline context
                var context = new PipelineContext(
                    config,
                    fileProcessor,
                    queue,
                    watcher,
                    pipelineLogger,  // Store pipeline logger in context
                    pacsQueue  // Store PACS queue in context
                );

                // Wire up file processor events
                fileProcessor.ProcessingCompleted += (sender, args) =>
                {
                    context.ProcessedCount++;
                    context.LastProcessed = DateTime.UtcNow;
                };

                fileProcessor.ProcessingError += (sender, args) =>
                {
                    context.ErrorCount++;
                };

                // Register pipeline
                if (_pipelines.TryAdd(config.Id.ToString(), context))
                {
                    // Wire up watcher events
                    watcher.Created += async (sender, e) =>
                    {
                        if (IsValidImageFile(e.FullPath, config.WatchSettings.FilePattern))
                        {
                            // Changed to DEBUG - file detection is technical detail
                            pipelineLogger.LogDebug("New file detected: {FilePath}", e.FullPath);
                            await queue.EnqueueAsync(e.FullPath, cancellationToken);
                        }
                    };

                    // Start processing queue (fire and forget!)
                    _ = Task.Run(async () =>
                    {
                        pipelineLogger.LogDebug("Starting processing queue for pipeline: {PipelineName}", config.Name);
                        await queue.ProcessQueueAsync(cancellationToken);
                    }, cancellationToken);

                    // Enable watcher
                    watcher.EnableRaisingEvents = true;
                    context.IsActive = true;

                    // Keep as INFO - important business event
                    pipelineLogger.LogInformation("Pipeline {PipelineName} started successfully. Watching: {WatchPath}",
                        config.Name, config.WatchSettings.Path);

                    if (pacsQueue != null)
                    {
                        pipelineLogger.LogInformation("PACS upload enabled for pipeline {PipelineName} â†’ {Host}:{Port}",
                            config.Name,
                            config.PacsConfiguration!.Host,
                            config.PacsConfiguration.Port);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to create pipeline: {PipelineName}", config.Name);
                throw;
            }
        }

        private async Task StopPipelineAsync(PipelineContext context, CancellationToken cancellationToken)
        {
            try
            {
                context.PipelineLogger.LogInformation("Stopping pipeline: {PipelineName}", context.Configuration.Name);

                context.IsActive = false;
                context.Watcher.EnableRaisingEvents = false;

                // Give queue time to finish current work
                await Task.Delay(1000, cancellationToken);

                context.PipelineLogger.LogInformation("Pipeline {PipelineName} stopped", context.Configuration.Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error stopping pipeline: {PipelineName}", context.Configuration.Name);
            }
        }

        private async Task ReconfigurePipelinesAsync(CamBridgeSettingsV2 newSettings)
        {
            await _pipelineLock.WaitAsync();
            try
            {
                // Stop pipelines that are no longer in config
                var configuredIds = newSettings.Pipelines.Select(p => p.Id.ToString()).ToHashSet();
                var toRemove = _pipelines.Keys.Where(id => !configuredIds.Contains(id)).ToList();

                foreach (var id in toRemove)
                {
                    if (_pipelines.TryRemove(id, out var context))
                    {
                        await StopPipelineAsync(context, CancellationToken.None);
                        context.Dispose();
                    }
                }

                // Start or update pipelines from config
                foreach (var pipelineConfig in newSettings.Pipelines)
                {
                    if (pipelineConfig.Enabled)
                    {
                        if (!_pipelines.ContainsKey(pipelineConfig.Id.ToString()))
                        {
                            await CreateAndStartPipelineAsync(pipelineConfig, CancellationToken.None);
                        }
                    }
                    else if (_pipelines.TryGetValue(pipelineConfig.Id.ToString(), out var context))
                    {
                        await StopPipelineAsync(context, CancellationToken.None);
                    }
                }
            }
            finally
            {
                _pipelineLock.Release();
            }
        }

        private FileSystemWatcher CreateFileSystemWatcher(PipelineWatchSettings settings)
        {
            // Ensure watch directory exists
            Directory.CreateDirectory(settings.Path);

            var watcher = new FileSystemWatcher(settings.Path)
            {
                NotifyFilter = NotifyFilters.FileName | NotifyFilters.CreationTime,
                IncludeSubdirectories = settings.IncludeSubdirectories
            };

            // Apply file pattern filter(s)
            // Note: FileSystemWatcher only supports single pattern, so we use *.* and filter in event
            watcher.Filter = "*.*";

            return watcher;
        }

        private bool IsValidImageFile(string filePath, string filePattern)
        {
            var fileName = Path.GetFileName(filePath);

            // Default to JPEG patterns if not specified
            if (string.IsNullOrWhiteSpace(filePattern))
                filePattern = "*.jpg;*.jpeg";

            // Split patterns by semicolon and check each
            var patterns = filePattern.Split(';', StringSplitOptions.RemoveEmptyEntries)
                .Select(p => p.Trim());

            foreach (var pattern in patterns)
            {
                // Convert wildcard pattern to regex
                var regexPattern = "^" + Regex.Escape(pattern)
                    .Replace("\\*", ".*")
                    .Replace("\\?", ".") + "$";

                if (Regex.IsMatch(fileName, regexPattern, RegexOptions.IgnoreCase))
                    return true;
            }

            return false;
        }

        private string SanitizeForFileName(string pipelineName)
        {
            // Same logic as in LogViewerViewModel
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(new[] { ' ', '.', ',', '/', '\\', ':', '-' })
                .Distinct()
                .ToArray();

            var sanitized = string.Join("_", pipelineName.Split(invalid, StringSplitOptions.RemoveEmptyEntries));

            if (sanitized.Length > 100)
            {
                sanitized = sanitized.Substring(0, 97) + "...";
            }

            return sanitized;
        }

        public void Dispose()
        {
            if (_disposed) return;

            try
            {
                _cancellationTokenSource.Cancel();
                StopAsync(CancellationToken.None).GetAwaiter().GetResult();

                foreach (var context in _pipelines.Values)
                {
                    context.Dispose();
                }

                _pipelines.Clear();
                _pipelineLock?.Dispose();
                _cancellationTokenSource?.Dispose();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during PipelineManager disposal");
            }

            _disposed = true;
        }

        /// <summary>
        /// Internal class to hold pipeline runtime context
        /// </summary>
        private class PipelineContext : IDisposable
        {
            public PipelineConfiguration Configuration { get; }
            public FileProcessor FileProcessor { get; }
            public ProcessingQueue Queue { get; }
            public FileSystemWatcher Watcher { get; }
            public ILogger PipelineLogger { get; }
            public PacsUploadQueue? PacsQueue { get; }
            public bool IsActive { get; set; }
            public DateTime LastProcessed { get; set; }
            public int ProcessedCount { get; set; }
            public int ErrorCount { get; set; }

            public PipelineContext(
                PipelineConfiguration configuration,
                FileProcessor fileProcessor,
                ProcessingQueue queue,
                FileSystemWatcher watcher,
                ILogger pipelineLogger,
                PacsUploadQueue? pacsQueue = null)
            {
                Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
                FileProcessor = fileProcessor ?? throw new ArgumentNullException(nameof(fileProcessor));
                Queue = queue ?? throw new ArgumentNullException(nameof(queue));
                Watcher = watcher ?? throw new ArgumentNullException(nameof(watcher));
                PipelineLogger = pipelineLogger ?? throw new ArgumentNullException(nameof(pipelineLogger));
                PacsQueue = pacsQueue;
                LastProcessed = DateTime.MinValue;
            }

            public void Dispose()
            {
                Watcher?.Dispose();
            }
        }
    }

    /// <summary>
    /// Pipeline status information for API responses
    /// </summary>
    public class PipelineStatus
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public bool IsActive { get; set; }
        public int QueueDepth { get; set; }
        public int ProcessedCount { get; set; }
        public int ErrorCount { get; set; }
        public DateTime LastProcessed { get; set; }
        public string WatchPath { get; set; } = string.Empty;
        public string OutputPath { get; set; } = string.Empty;
        public bool PacsEnabled { get; set; }
        public int PacsQueueDepth { get; set; }
    }
}
// src/CamBridge.Infrastructure/Services/FileProcessor.cs
// Version: 0.8.6
// Description: Pipeline-aware file processor with LogContext integration
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.Entities;
using CamBridge.Core.Interfaces;
using CamBridge.Core.ValueObjects;
using CamBridge.Core.Logging;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Orchestrates the complete JPEG to DICOM conversion process for a specific pipeline
    /// ENHANCED: Now uses LogContext for structured hierarchical logging
    /// </summary>
    public class FileProcessor
    {
        private readonly ILogger _logger;
        private readonly ExifToolReader _exifToolReader;
        private readonly DicomConverter _dicomConverter;
        private readonly PipelineConfiguration _pipelineConfig;
        private readonly DicomSettings _dicomSettings;
        private readonly IDicomTagMapper? _tagMapper;
        private readonly IMappingConfiguration? _mappingConfiguration;
        private readonly PacsUploadQueue? _pacsUploadQueue;
        private readonly LogVerbosity _logVerbosity;

        public event EventHandler<FileProcessingEventArgs>? ProcessingStarted;
        public event EventHandler<FileProcessingEventArgs>? ProcessingCompleted;
        public event EventHandler<FileProcessingErrorEventArgs>? ProcessingError;

        /// <summary>
        /// Creates a FileProcessor for a specific pipeline with optional PACS upload support
        /// </summary>
        public FileProcessor(
            ILogger logger,
            ExifToolReader exifToolReader,
            DicomConverter dicomConverter,
            PipelineConfiguration pipelineConfig,
            DicomSettings globalDicomSettings,
            IDicomTagMapper? tagMapper = null,
            IMappingConfiguration? mappingConfiguration = null,
            PacsUploadQueue? pacsUploadQueue = null,
            LogVerbosity logVerbosity = LogVerbosity.Detailed)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _exifToolReader = exifToolReader ?? throw new ArgumentNullException(nameof(exifToolReader));
            _dicomConverter = dicomConverter ?? throw new ArgumentNullException(nameof(dicomConverter));
            _pipelineConfig = pipelineConfig ?? throw new ArgumentNullException(nameof(pipelineConfig));
            _dicomSettings = ApplyDicomOverrides(globalDicomSettings, pipelineConfig.DicomOverrides);
            _tagMapper = tagMapper;
            _mappingConfiguration = mappingConfiguration;
            _pacsUploadQueue = pacsUploadQueue;
            _logVerbosity = logVerbosity;

            _logger.LogDebug("Created FileProcessor for pipeline: {PipelineName} (\"{PipelineId}\")",
                pipelineConfig.Name, pipelineConfig.Id);

            if (_pacsUploadQueue != null)
            {
                _logger.LogInformation("PACS upload queue attached to pipeline: {PipelineName}",
                    pipelineConfig.Name);
            }
        }

        /// <summary>
        /// Processes a single JPEG file through the pipeline using LogContext
        /// </summary>
        public async Task<FileProcessingResult> ProcessFileAsync(string filePath)
        {
            // Generate correlation ID and create LogContext
            var correlationId = GenerateCorrelationId(filePath);
            var logContext = _logger.CreateContext(correlationId, _pipelineConfig.Name, _logVerbosity);

            var result = new FileProcessingResult
            {
                SourceFile = filePath,
                StartTime = DateTime.UtcNow,
                PipelineId = _pipelineConfig.Id,
                CorrelationId = correlationId
            };

            try
            {
                using (logContext.BeginStage(ProcessingStage.FileDetected, $"Processing file: {Path.GetFileName(filePath)}"))
                {
                    ProcessingStarted?.Invoke(this, new FileProcessingEventArgs
                    {
                        FilePath = filePath,
                        CorrelationId = correlationId,
                        PipelineName = _pipelineConfig.Name,
                        Stage = ProcessingStage.FileDetected
                    });

                    // Validate input file
                    ValidateInputFile(filePath);
                }

                // Extract EXIF data with timing
                ImageMetadata? metadata;
                using (logContext.BeginStage(ProcessingStage.ExifExtraction, "Extracting EXIF metadata"))
                {
                    metadata = await _exifToolReader.ExtractMetadataAsync(filePath);

                    if (metadata == null)
                    {
                        logContext.LogWarning("Failed to extract metadata, creating default DICOM with minimal tags");
                        metadata = CreateDefaultMetadata(filePath);
                    }
                    else if (metadata.Patient != null)
                    {
                        logContext.LogInformation($"Patient: {metadata.Patient.PatientName}");
                    }
                }

                // Apply tag mapping if configured
                if (_tagMapper != null && _mappingConfiguration != null)
                {
                    using (logContext.BeginStage(ProcessingStage.TagMapping, "Applying tag mapping rules"))
                    {
                        var mappingRules = _mappingConfiguration.GetMappingRules();
                        if (mappingRules.Any())
                        {
                            logContext.LogDebug($"Applying {mappingRules.Count()} mapping rules");
                        }
                    }
                }

                // Determine output path based on pipeline configuration
                var outputPath = DetermineOutputPath(metadata, filePath);

                // Ensure output directory exists
                var outputDir = Path.GetDirectoryName(outputPath);
                if (!string.IsNullOrEmpty(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }

                // Convert to DICOM with timing
                ConversionResult conversionResult;
                using (logContext.BeginStage(ProcessingStage.DicomConversion, $"Converting to DICOM: {Path.GetFileName(outputPath)}"))
                {
                    // Create converter with mapper if available
                    var converterWithMapping = new DicomConverter(
                        _logger as ILogger<DicomConverter> ?? Microsoft.Extensions.Logging.Abstractions.NullLogger<DicomConverter>.Instance,
                        _tagMapper,
                        _mappingConfiguration);

                    conversionResult = await converterWithMapping.ConvertToDicomAsync(
                        filePath,
                        outputPath,
                        metadata);
                }

                result.Success = conversionResult.Success;
                result.OutputFile = outputPath;
                result.DicomFile = outputPath;
                result.EndTime = DateTime.UtcNow;
                result.ProcessingTimeMs = (long)(result.EndTime - result.StartTime).TotalMilliseconds;

                if (result.Success)
                {
                    // Queue for PACS upload if enabled
                    if (_pacsUploadQueue != null && _pipelineConfig.PacsConfiguration?.Enabled == true)
                    {
                        using (logContext.BeginStage(ProcessingStage.PacsUpload, $"Queueing for PACS upload to {_pipelineConfig.PacsConfiguration.Host}:{_pipelineConfig.PacsConfiguration.Port}"))
                        {
                            try
                            {
                                await _pacsUploadQueue.EnqueueAsync(conversionResult.DicomFilePath!, correlationId);
                            }
                            catch (Exception ex)
                            {
                                logContext.LogError(ex, "Failed to queue DICOM for PACS upload");
                                // Don't fail the overall processing if PACS queue fails
                            }
                        }
                    }

                    // Handle post-processing
                    using (logContext.BeginStage(ProcessingStage.PostProcessing, "Performing post-processing"))
                    {
                        await HandlePostProcessingAsync(filePath, outputPath, result.Success, logContext);
                    }

                    // Final success log
                    using (logContext.BeginStage(ProcessingStage.Complete, $"Successfully processed {Path.GetFileName(filePath)}"))
                    {
                        // Performance warning for slow processing
                        if (result.ProcessingTimeMs > 5000)
                        {
                            logContext.LogWarning($"Slow processing detected: {result.ProcessingTimeMs}ms");
                        }

                        ProcessingCompleted?.Invoke(this, new FileProcessingEventArgs
                        {
                            FilePath = filePath,
                            OutputPath = outputPath,
                            CorrelationId = correlationId,
                            PipelineName = _pipelineConfig.Name,
                            Stage = ProcessingStage.Complete
                        });
                    }
                }
                else
                {
                    throw new InvalidOperationException(
                        $"DICOM conversion failed: {conversionResult.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.ErrorMessage = ex.Message;
                result.EndTime = DateTime.UtcNow;
                result.ProcessingTimeMs = (long)(result.EndTime - result.StartTime).TotalMilliseconds;

                using (logContext.BeginStage(ProcessingStage.Error, $"Processing failed: {ex.Message}"))
                {
                    logContext.LogError(ex, $"Failed to process {Path.GetFileName(filePath)}");

                    // Critical error detection
                    if (ex is UnauthorizedAccessException && filePath.StartsWith(_pipelineConfig.WatchSettings.Path))
                    {
                        _logger.LogCritical(ex, "[{CorrelationId}] [Error] Cannot access watch folder {Path} - pipeline will fail! [{Pipeline}]",
                            correlationId, _pipelineConfig.WatchSettings.Path, _pipelineConfig.Name);
                    }

                    // Handle failure post-processing
                    await HandlePostProcessingAsync(filePath, null, false, logContext);

                    ProcessingError?.Invoke(this, new FileProcessingErrorEventArgs
                    {
                        FilePath = filePath,
                        Error = ex,
                        CorrelationId = correlationId,
                        PipelineName = _pipelineConfig.Name,
                        Stage = ProcessingStage.Error
                    });
                }
            }

            return result;
        }

        /// <summary>
        /// Handles post-processing with LogContext
        /// </summary>
        private async Task HandlePostProcessingAsync(string sourceFilePath, string? dicomFilePath, bool success, LogContext logContext)
        {
            var action = success
                ? _pipelineConfig.ProcessingOptions.SuccessAction
                : _pipelineConfig.ProcessingOptions.FailureAction;

            try
            {
                logContext.LogDebug($"Performing {action} on source file");

                switch (action)
                {
                    case PostProcessingAction.Delete:
                        // Delete only the source file
                        if (File.Exists(sourceFilePath))
                        {
                            File.Delete(sourceFilePath);
                            logContext.LogDebug("Deleted source file");
                        }
                        break;

                    case PostProcessingAction.Archive:
                        var jpegArchiveFolder = _pipelineConfig.ProcessingOptions.BackupFolder
                            ?? Path.Combine(_pipelineConfig.ProcessingOptions.ArchiveFolder, "ProcessedJPEGs");

                        var archivePath = Path.Combine(
                            jpegArchiveFolder,
                            Path.GetFileName(sourceFilePath));

                        Directory.CreateDirectory(Path.GetDirectoryName(archivePath)!);

                        if (File.Exists(sourceFilePath))
                        {
                            File.Move(sourceFilePath, archivePath, true);
                            logContext.LogDebug($"Archived source JPEG to {Path.GetFullPath(archivePath)}");
                        }

                        // DICOM file stays in output folder
                        if (success && !string.IsNullOrEmpty(dicomFilePath))
                        {
                            logContext.LogInformation($"DICOM file created at: {Path.GetFullPath(dicomFilePath)}");
                        }
                        break;

                    case PostProcessingAction.MoveToError:
                        // Move source file to error folder (typically for failures)
                        if (!success)
                        {
                            await MoveToErrorFolderAsync(sourceFilePath, "Processing failed", logContext);

                            // If DICOM was partially created, clean it up
                            if (!string.IsNullOrEmpty(dicomFilePath) && File.Exists(dicomFilePath))
                            {
                                try
                                {
                                    File.Delete(dicomFilePath);
                                    logContext.LogDebug("Cleaned up partial DICOM file");
                                }
                                catch (Exception ex)
                                {
                                    logContext.LogWarning($"Failed to clean up partial DICOM: {ex.Message}");
                                }
                            }
                        }
                        break;

                    default:
                        // Leave files as-is
                        logContext.LogDebug("No post-processing action");
                        break;
                }
            }
            catch (Exception ex)
            {
                logContext.LogWarning($"Failed to perform {action}: {ex.Message}");
                // Don't fail the overall processing for post-processing errors
            }
        }

        private async Task MoveToErrorFolderAsync(string filePath, string errorMessage, LogContext logContext)
        {
            try
            {
                var errorFolder = _pipelineConfig.ProcessingOptions.ErrorFolder;
                Directory.CreateDirectory(errorFolder);

                var errorFileName = $"{Path.GetFileNameWithoutExtension(filePath)}" +
                                   $"_{DateTime.Now:yyyyMMdd_HHmmss}" +
                                   $"{Path.GetExtension(filePath)}";

                var errorPath = Path.Combine(errorFolder, errorFileName);

                // Write error info file
                var errorInfoPath = Path.ChangeExtension(errorPath, ".error.txt");
                await File.WriteAllTextAsync(errorInfoPath,
                    $"Error Time: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\n" +
                    $"Pipeline: {_pipelineConfig.Name}\n" +
                    $"Source File: {filePath}\n" +
                    $"Correlation ID: {logContext.CorrelationId}\n" +
                    $"Error: {errorMessage}");

                // Move the file
                if (File.Exists(filePath))
                {
                    File.Move(filePath, errorPath, true);
                    logContext.LogDebug("Moved failed file to error folder");
                }
            }
            catch (Exception ex)
            {
                logContext.LogError(ex, "Failed to move file to error folder");
            }
        }

        // Rest of the methods remain the same...

        /// <summary>
        /// Determines if a file should be processed based on pipeline configuration
        /// </summary>
        public bool ShouldProcessFile(string filePath)
        {
            try
            {
                var fileInfo = new FileInfo(filePath);
                var extension = fileInfo.Extension.ToLowerInvariant();

                // Check file extension
                var filePattern = _pipelineConfig.WatchSettings.FilePattern;
                var patterns = string.IsNullOrEmpty(filePattern)
                    ? new[] { "*.jpg", "*.jpeg" }
                    : filePattern.Split(';', StringSplitOptions.RemoveEmptyEntries);

                var isValidExtension = patterns.Any(pattern =>
                {
                    var patternExt = Path.GetExtension(pattern).ToLowerInvariant();
                    return patternExt == extension || patternExt == ".*";
                });

                if (!isValidExtension)
                {
                    return false;
                }

                // Check file age
                if (_pipelineConfig.ProcessingOptions.MaxFileAge.HasValue)
                {
                    var age = DateTime.UtcNow - fileInfo.CreationTimeUtc;
                    if (age > _pipelineConfig.ProcessingOptions.MaxFileAge.Value)
                    {
                        _logger.LogDebug("File {FileName} is too old ({Age} days)",
                            fileInfo.Name, age.TotalDays);
                        return false;
                    }
                }

                // Check file size
                if (_pipelineConfig.ProcessingOptions.MinimumFileSizeBytes.HasValue &&
                    fileInfo.Length < _pipelineConfig.ProcessingOptions.MinimumFileSizeBytes.Value)
                {
                    _logger.LogDebug("File {FileName} is too small ({Size} bytes)",
                        fileInfo.Name, fileInfo.Length);
                    return false;
                }

                if (_pipelineConfig.ProcessingOptions.MaximumFileSizeBytes.HasValue &&
                    fileInfo.Length > _pipelineConfig.ProcessingOptions.MaximumFileSizeBytes.Value)
                {
                    _logger.LogDebug("File {FileName} is too large ({Size} bytes)",
                        fileInfo.Name, fileInfo.Length);
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error checking file {FilePath}", filePath);
                return false;
            }
        }

        private string GenerateCorrelationId(string filePath)
        {
            // Format: F{HHmmssff}-{FilePrefix8}
            // Example: F10234512-IMG_1234
            var timestamp = DateTime.Now.ToString("HHmmssff");
            var fileNameWithoutExt = Path.GetFileNameWithoutExtension(filePath);
            var filePrefix = fileNameWithoutExt.Length > 8
                ? fileNameWithoutExt.Substring(0, 8)
                : fileNameWithoutExt;

            return $"F{timestamp}-{filePrefix}";
        }

        private void ValidateInputFile(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException($"Source file not found: {filePath}");
            }

            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            if (extension != ".jpg" && extension != ".jpeg")
            {
                throw new InvalidOperationException($"Invalid file type: {extension}. Expected JPEG file.");
            }
        }

        private string DetermineOutputPath(ImageMetadata metadata, string sourceFile)
        {
            // FIXED: Use ArchiveFolder as DICOM output if no OutputPath configured
            var baseOutputPath = _pipelineConfig.WatchSettings.OutputPath;

            if (string.IsNullOrEmpty(baseOutputPath))
            {
                // Fallback to ArchiveFolder if no OutputPath (current config behavior)
                baseOutputPath = _pipelineConfig.ProcessingOptions.ArchiveFolder;
                _logger.LogWarning("No OutputPath in WatchSettings, using ArchiveFolder as output: {Path}",
                    Path.GetFullPath(baseOutputPath));
            }

            // ALWAYS make path absolute!
            if (!Path.IsPathRooted(baseOutputPath))
            {
                // If relative path, make it relative to service executable location
                var serviceDir = AppDomain.CurrentDomain.BaseDirectory;
                baseOutputPath = Path.Combine(serviceDir, baseOutputPath);
                _logger.LogWarning("OutputPath was relative, converted to absolute: {Path}",
                    Path.GetFullPath(baseOutputPath));
            }

            _logger.LogDebug("Base output path for pipeline {Pipeline}: {Path}",
                _pipelineConfig.Name, Path.GetFullPath(baseOutputPath));

            var organization = _pipelineConfig.ProcessingOptions.OutputOrganization;
            var fileName = Path.GetFileNameWithoutExtension(sourceFile);

            // Build organized path based on configuration
            var outputDir = baseOutputPath;

            switch (organization)
            {
                case OutputOrganization.ByPatient:
                    if (!string.IsNullOrEmpty(metadata.Patient?.PatientName))
                    {
                        var safeName = SanitizeForPath(metadata.Patient.PatientName);
                        outputDir = Path.Combine(baseOutputPath, safeName);
                        _logger.LogDebug("Output organized by patient: {PatientName} -> {SafeName}",
                            metadata.Patient.PatientName, safeName);
                    }
                    else
                    {
                        outputDir = Path.Combine(baseOutputPath, "Unknown Patient");
                        _logger.LogWarning("No patient name found, using 'Unknown Patient' folder");
                    }
                    break;

                case OutputOrganization.ByDate:
                    // ALWAYS use current date for organization
                    var dateFolder = DateTime.Now.ToString("yyyy-MM-dd");
                    outputDir = Path.Combine(baseOutputPath, dateFolder);
                    _logger.LogDebug("Output organized by date: {Date}", dateFolder);
                    break;

                case OutputOrganization.ByPatientAndDate:
                    if (!string.IsNullOrEmpty(metadata.Patient?.PatientName))
                    {
                        var safeName = SanitizeForPath(metadata.Patient.PatientName);
                        // ALWAYS use current date for organization
                        var dateFolder2 = DateTime.Now.ToString("yyyy-MM-dd");
                        outputDir = Path.Combine(baseOutputPath, safeName, dateFolder2);
                        _logger.LogDebug("Output organized by patient/date: {PatientName}/{Date}",
                            safeName, dateFolder2);
                    }
                    else
                    {
                        var dateFolder3 = DateTime.Now.ToString("yyyy-MM-dd");
                        outputDir = Path.Combine(baseOutputPath, "Unknown Patient", dateFolder3);
                        _logger.LogWarning("No patient name found, using 'Unknown Patient/{Date}' folder", dateFolder3);
                    }
                    break;

                case OutputOrganization.None:
                default:
                    // Use base output path as-is
                    break;
            }

            // Add DICOM extension
            var dicomPath = Path.Combine(outputDir, $"{fileName}.dcm");

            // CRITICAL: ALWAYS return ABSOLUTE path!
            var absolutePath = Path.GetFullPath(dicomPath);
            _logger.LogInformation("Determined DICOM output path: {FullPath}", absolutePath);
            return absolutePath;
        }

        private string SanitizeForPath(string input)
        {
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(Path.GetInvalidPathChars())
                .Distinct()
                .ToArray();

            return string.Join("_", input.Split(invalid, StringSplitOptions.RemoveEmptyEntries));
        }

        private DicomSettings ApplyDicomOverrides(DicomSettings global, DicomOverrides? overrides)
        {
            if (overrides == null)
                return global;

            // Create a copy of global settings with overrides applied
            var settings = new DicomSettings
            {
                InstitutionName = overrides.InstitutionName ?? global.InstitutionName,
                InstitutionDepartment = overrides.InstitutionDepartment ?? global.InstitutionDepartment,
                StationName = global.StationName,
                SourceApplicationEntityTitle = global.SourceApplicationEntityTitle,
                ImplementationVersionName = global.ImplementationVersionName,
                ImplementationClassUid = global.ImplementationClassUid,
                Modality = global.Modality,
                ValidateAfterCreation = global.ValidateAfterCreation
            };

            _logger.LogDebug("Applied DICOM overrides for pipeline: {PipelineName}", _pipelineConfig.Name);
            return settings;
        }

        /// <summary>
        /// Creates minimal default metadata when extraction fails
        /// </summary>
        private ImageMetadata CreateDefaultMetadata(string sourceFile)
        {
            var fileName = Path.GetFileNameWithoutExtension(sourceFile);
            var now = DateTime.Now;

            _logger.LogWarning("Creating default metadata for {FileName} with date {Date}",
                fileName, now.ToString("yyyy-MM-dd"));

            // Create default patient info with constructor
            var patientId = new PatientId($"DEFAULT_{now:yyyyMMddHHmmss}");
            var patient = new PatientInfo(
                id: patientId,
                name: "Unknown Patient",
                birthDate: null,
                gender: Gender.Other
            );

            // Create default study info with constructor
            var studyId = new StudyId(Guid.NewGuid().ToString().Substring(0, 16)); // Max 16 chars
            var study = new StudyInfo(
                studyId: studyId,
                examId: null,
                description: "CamBridge JPEG to DICOM Conversion",
                modality: "XC",  // Photographic Image
                studyDate: now,
                accessionNumber: $"ACC{now:yyyyMMddHHmmss}",
                referringPhysician: null,
                comment: null
            );

            // Create technical data (minimal)
            var technicalData = new ImageTechnicalData
            {
                Manufacturer = "Unknown",
                Model = "Unknown"
            };

            // Create EXIF data dictionary
            var exifData = new Dictionary<string, string>
            {
                ["FileName"] = fileName,
                ["FileDate"] = now.ToString("yyyy-MM-dd HH:mm:ss"),
                ["Source"] = "CamBridge Default"
            };

            // Create metadata with full constructor
            var metadata = new ImageMetadata(
                sourceFilePath: sourceFile,
                captureDateTime: now,
                patient: patient,
                study: study,
                technicalData: technicalData,
                userComment: null,
                barcodeData: null,
                instanceNumber: 1,
                instanceUid: null,
                exifData: exifData
            );

            return metadata;
        }
    }

    /// <summary>
    /// Event arguments for file processing events with correlation support
    /// </summary>
    public class FileProcessingEventArgs : EventArgs
    {
        public string FilePath { get; set; } = string.Empty;
        public string? OutputPath { get; set; }
        public string CorrelationId { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public ProcessingStage Stage { get; set; } = ProcessingStage.FileDetected;
    }

    /// <summary>
    /// Event arguments for file processing errors with correlation support
    /// </summary>
    public class FileProcessingErrorEventArgs : EventArgs
    {
        public string FilePath { get; set; } = string.Empty;
        public Exception Error { get; set; } = null!;
        public string CorrelationId { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public ProcessingStage Stage { get; set; } = ProcessingStage.Error;
    }

    /// <summary>
    /// Result of file processing operation with correlation tracking
    /// </summary>
    public class FileProcessingResult
    {
        public string SourceFile { get; set; } = string.Empty;
        public string? OutputFile { get; set; }
        public string? DicomFile { get; set; }
        public bool Success { get; set; }
        public string? ErrorMessage { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public long ProcessingTimeMs { get; set; }
        public Guid PipelineId { get; set; }
        public string CorrelationId { get; set; } = string.Empty;
    }
}
// src/CamBridge.Core/Logging/LogContext.cs
// Version: 0.9.0
// Description: Context for hierarchical logging with correlation IDs and timing
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace CamBridge.Core.Logging
{
    /// <summary>
    /// Provides context for hierarchical logging with correlation IDs
    /// </summary>
    public class LogContext
    {
        private readonly ILogger _logger;
        private readonly Stack<StageContext> _stageStack = new();

        public string CorrelationId { get; }
        public string PipelineName { get; }
        public ProcessingStage CurrentStage { get; private set; }
        public DateTime StartTime { get; }
        public LogVerbosity Verbosity { get; }

        public LogContext(
            ILogger logger,
            string correlationId,
            string pipelineName,
            LogVerbosity verbosity = LogVerbosity.Detailed)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            CorrelationId = correlationId ?? throw new ArgumentNullException(nameof(correlationId));
            PipelineName = pipelineName ?? throw new ArgumentNullException(nameof(pipelineName));
            Verbosity = verbosity;
            StartTime = DateTime.UtcNow;
            CurrentStage = ProcessingStage.FileDetected;
        }

        /// <summary>
        /// Begins a new processing stage and returns a disposable that logs completion
        /// </summary>
        public IDisposable BeginStage(ProcessingStage stage, string? message = null)
        {
            CurrentStage = stage;
            var stageContext = new StageContext(this, stage, message);
            _stageStack.Push(stageContext);
            return stageContext;
        }

        /// <summary>
        /// Check if should log at this verbosity level
        /// </summary>
        public bool ShouldLog(LogVerbosity requiredLevel)
        {
            return Verbosity >= requiredLevel;
        }

        /// <summary>
        /// Log with correlation context
        /// </summary>
        public void Log(LogLevel level, string message, params object[] args)
        {
            var formattedArgs = new List<object> { CorrelationId, CurrentStage, message, PipelineName };
            if (args != null && args.Length > 0)
            {
                formattedArgs.AddRange(args);
            }

            _logger.Log(level, "[{CorrelationId}] [{Stage}] " + message + " [{Pipeline}]", formattedArgs.ToArray());
        }

        /// <summary>
        /// Log information with correlation context
        /// </summary>
        public void LogInformation(string message, params object[] args)
        {
            if (ShouldLog(LogVerbosity.Minimal))
            {
                Log(LogLevel.Information, message, args);
            }
        }

        /// <summary>
        /// Log debug with correlation context
        /// </summary>
        public void LogDebug(string message, params object[] args)
        {
            if (ShouldLog(LogVerbosity.Debug))
            {
                Log(LogLevel.Debug, message, args);
            }
        }

        /// <summary>
        /// Log warning with correlation context
        /// </summary>
        public void LogWarning(string message, params object[] args)
        {
            if (ShouldLog(LogVerbosity.Normal))
            {
                Log(LogLevel.Warning, message, args);
            }
        }

        /// <summary>
        /// Log error with correlation context
        /// </summary>
        public void LogError(Exception ex, string message, params object[] args)
        {
            // Always log errors
            var formattedArgs = new List<object> { CorrelationId, CurrentStage, message, PipelineName };
            if (args != null && args.Length > 0)
            {
                formattedArgs.AddRange(args);
            }

            _logger.LogError(ex, "[{CorrelationId}] [{Stage}] " + message + " [{Pipeline}]", formattedArgs.ToArray());
        }

        /// <summary>
        /// Context for a processing stage with timing
        /// </summary>
        private class StageContext : IDisposable
        {
            private readonly LogContext _logContext;
            private readonly ProcessingStage _stage;
            private readonly Stopwatch _stopwatch;
            private readonly string? _message;

            public StageContext(LogContext logContext, ProcessingStage stage, string? message)
            {
                _logContext = logContext;
                _stage = stage;
                _message = message;
                _stopwatch = Stopwatch.StartNew();

                // Log stage start if detailed logging
                if (_logContext.ShouldLog(LogVerbosity.Detailed))
                {
                    _logContext.LogInformation(_message ?? $"{stage} started");
                }
            }

            public void Dispose()
            {
                _stopwatch.Stop();

                // Log stage completion with timing
                if (_logContext.ShouldLog(LogVerbosity.Normal))
                {
                    var completionMessage = _message != null
                        ? $"{_message} completed"
                        : $"{_stage} completed";

                    _logContext.LogInformation($"{completionMessage} [{{Duration}}ms]", _stopwatch.ElapsedMilliseconds);
                }

                // Pop from stack
                if (_logContext._stageStack.Count > 0)
                {
                    _logContext._stageStack.Pop();
                }
            }
        }
    }

    /// <summary>
    /// Processing stages for hierarchical logging
    /// </summary>
    public enum ProcessingStage
    {
        FtpReceived,      // File received from FTP Server
        FileDetected,     // File detected in watch folder
        ExifExtraction,   // Extracting metadata from JPEG
        TagMapping,       // Applying mapping rules
        DicomConversion,  // Creating DICOM file
        PostProcessing,   // Archive/Delete operations
        PacsUpload,       // Uploading to PACS
        Complete,         // Processing complete
        Error             // Error occurred
    }

    /// <summary>
    /// Log verbosity levels
    /// </summary>
    public enum LogVerbosity
    {
        Minimal,   // Start/End only (~150 KB/day)
        Normal,    // + Compact info (~750 KB/day)
        Detailed,  // + All stages (~1.75 MB/day) DEFAULT!
        Debug      // + Raw data (~3.5 MB/day)
    }

    /// <summary>
    /// Extension methods for clean logging
    /// </summary>
    public static class LogContextExtensions
    {
        /// <summary>
        /// Create a log context from a logger
        /// </summary>
        public static LogContext CreateContext(
            this ILogger logger,
            string correlationId,
            string pipelineName,
            LogVerbosity verbosity = LogVerbosity.Detailed)
        {
            return new LogContext(logger, correlationId, pipelineName, verbosity);
        }

        /// <summary>
        /// Log a processing stage with timing
        /// </summary>
        public static IDisposable LogStage(
            this LogContext context,
            ProcessingStage stage,
            string? message = null)
        {
            return context.BeginStage(stage, message);
        }
    }
}
// src/CamBridge.Core/Enums/LogVerbosity.cs
// Version: 0.8.6
// Created: Session 96 - Making Logs Great Again!
// Purpose: Define global log verbosity levels for the service

namespace CamBridge.Core.Enums
{
    /// <summary>
    /// Defines the verbosity levels for service logging.
    /// Controls how much detail is written to log files.
    /// </summary>
    public enum LogVerbosity
    {
        /// <summary>
        /// Minimal logging - Only start/end events (~150 KB/day)
        /// Logs: File detected, processing complete/failed
        /// </summary>
        Minimal = 0,

        /// <summary>
        /// Normal logging - Key events and compact info (~750 KB/day)
        /// Logs: Minimal + EXIF data summary, mapping rules applied
        /// </summary>
        Normal = 1,

        /// <summary>
        /// Detailed logging - All stages with timing (~1.75 MB/day)
        /// Logs: Normal + all processing stages, timing information
        /// DEFAULT setting for troubleshooting
        /// </summary>
        Detailed = 2,

        /// <summary>
        /// Debug logging - Everything including raw data (~3.5 MB/day)
        /// Logs: Detailed + raw EXIF JSON, DICOM tags, full error stacks
        /// Use only for deep debugging
        /// </summary>
        Debug = 3
    }
}
// src\CamBridge.Core\CamBridgeSettingsV2.cs
// Version: 0.9.0
// Description: Version 2 settings with pipeline architecture and hierarchical logging support
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;
using CamBridge.Core.Logging;

namespace CamBridge.Core
{
    /// <summary>
    /// Version 2 configuration with pipeline-based architecture
    /// CLEAN: No more legacy workarounds!
    /// </summary>
    public class CamBridgeSettingsV2
    {
        /// <summary>
        /// Settings version for future compatibility
        /// </summary>
        public string Version { get; set; } = "2.0";

        /// <summary>
        /// List of configured pipelines
        /// </summary>
        public List<PipelineConfiguration> Pipelines { get; set; } = new();

        /// <summary>
        /// Reusable mapping sets
        /// </summary>
        public List<MappingSet> MappingSets { get; set; } = new();

        /// <summary>
        /// Global DICOM settings (can be overridden per pipeline)
        /// </summary>
        public DicomSettings GlobalDicomSettings { get; set; } = new();

        /// <summary>
        /// Global defaults for new pipelines
        /// </summary>
        public ProcessingOptions DefaultProcessingOptions { get; set; } = new();

        /// <summary>
        /// Logging configuration (remains global)
        /// </summary>
        public LoggingSettings Logging { get; set; } = new();

        /// <summary>
        /// Service configuration (remains global)
        /// </summary>
        public ServiceSettings Service { get; set; } = new();

        /// <summary>
        /// Notification settings (remains global)
        /// </summary>
        public NotificationSettings Notifications { get; set; } = new();

        /// <summary>
        /// ExifTool executable path (global setting)
        /// </summary>
        public string ExifToolPath { get; set; } = "Tools\\exiftool.exe";

        /// <summary>
        /// Validate the configuration
        /// </summary>
        [JsonIgnore]
        public bool IsValid
        {
            get
            {
                // At least one pipeline must be configured
                if (Pipelines.Count == 0)
                    return false;

                // All enabled pipelines must be valid
                if (Pipelines.Any(p => p.Enabled && !p.IsValid))
                    return false;

                // All pipelines must have valid mapping sets
                var mappingSetIds = MappingSets.Select(m => m.Id).ToHashSet();
                if (Pipelines.Any(p => p.MappingSetId.HasValue && !mappingSetIds.Contains(p.MappingSetId.Value)))
                    return false;

                return true;
            }
        }
    }

    /// <summary>
    /// DICOM-specific settings
    /// </summary>
    public class DicomSettings
    {
        /// <summary>
        /// Implementation Class UID for this application
        /// </summary>
        public string ImplementationClassUid { get; set; } = "1.2.276.0.7230010.3.0.3.6.4";

        /// <summary>
        /// Implementation Version Name
        /// </summary>
        public string ImplementationVersionName { get; set; } = "CAMBRIDGE_001";

        /// <summary>
        /// Source Application Entity Title
        /// </summary>
        public string SourceApplicationEntityTitle { get; set; } = "CAMBRIDGE";

        /// <summary>
        /// Institution Name
        /// </summary>
        public string? InstitutionName { get; set; }

        /// <summary>
        /// Institution Department
        /// </summary>
        public string? InstitutionDepartment { get; set; }

        /// <summary>
        /// Station Name
        /// </summary>
        public string? StationName { get; set; }

        /// <summary>
        /// Modality for created images
        /// </summary>
        public string Modality { get; set; } = "OT"; // Other

        /// <summary>
        /// Validate DICOM files after creation
        /// </summary>
        public bool ValidateAfterCreation { get; set; } = true;
    }

    /// <summary>
    /// Logging configuration
    /// </summary>
    public class LoggingSettings
    {
        /// <summary>
        /// Minimum log level (Trace, Debug, Information, Warning, Error, Critical)
        /// </summary>
        public string LogLevel { get; set; } = "Information";

        /// <summary>
        /// Log folder path
        /// </summary>
        public string LogFolder { get; set; } = @"C:\CamBridge\Logs";

        /// <summary>
        /// Enable file logging
        /// </summary>
        public bool EnableFileLogging { get; set; } = true;

        /// <summary>
        /// Enable Windows Event Log
        /// </summary>
        public bool EnableEventLog { get; set; } = true;

        /// <summary>
        /// Maximum log file size in MB
        /// </summary>
        public int MaxLogFileSizeMB { get; set; } = 10;

        /// <summary>
        /// Maximum number of log files to retain
        /// </summary>
        public int MaxLogFiles { get; set; } = 10;
    }

    /// <summary>
    /// Windows Service specific settings with enhanced logging control
    /// </summary>
    public class ServiceSettings
    {
        /// <summary>
        /// Service name (for sc.exe)
        /// </summary>
        public string ServiceName { get; set; } = "CamBridgeService";

        /// <summary>
        /// Service display name
        /// </summary>
        public string DisplayName { get; set; } = "CamBridge JPEG to DICOM Converter";

        /// <summary>
        /// Service description
        /// </summary>
        public string Description { get; set; } = "Monitors folders for JPEG files from Ricoh cameras and converts them to DICOM format";

        /// <summary>
        /// Startup delay in seconds
        /// </summary>
        public int StartupDelaySeconds { get; set; } = 5;

        /// <summary>
        /// File processing delay in milliseconds
        /// </summary>
        public int FileProcessingDelayMs { get; set; } = 500;

        /// <summary>
        /// API port for web interface
        /// </summary>
        public int ApiPort { get; set; } = 5111;

        /// <summary>
        /// Global log verbosity level for all pipelines
        /// Controls how much detail is logged during processing
        /// </summary>
        public LogVerbosity LogVerbosity { get; set; } = LogVerbosity.Detailed;
    }

    /// <summary>
    /// Configuration for the notification system
    /// Part of SystemSettings - Compatible with legacy NotificationService
    /// </summary>
    public class NotificationSettings
    {
        /// <summary>
        /// Enable or disable the notification system
        /// </summary>
        public bool Enabled { get; set; } = true;

        // === LEGACY PROPERTIES FOR COMPATIBILITY ===

        /// <summary>
        /// Enable Windows Event Log notifications
        /// </summary>
        public bool EnableEventLog { get; set; } = true;

        /// <summary>
        /// Enable email notifications
        /// </summary>
        public bool EnableEmail { get; set; } = false;

        /// <summary>
        /// Minimum log level for email notifications (0=Trace, 1=Debug, 2=Info, 3=Warning, 4=Error, 5=Critical)
        /// </summary>
        public int MinimumEmailLevel { get; set; } = 4; // Error level

        /// <summary>
        /// Dead letter queue threshold for notifications
        /// </summary>
        public int DeadLetterThreshold { get; set; } = 100;

        /// <summary>
        /// Send daily summary emails
        /// </summary>
        public bool SendDailySummary { get; set; } = true;

        /// <summary>
        /// Hour to send daily summary (0-23)
        /// </summary>
        public int DailySummaryHour { get; set; } = 8;

        // === NEW STRUCTURED PROPERTIES ===

        /// <summary>
        /// Email notification settings
        /// </summary>
        public EmailSettings Email { get; set; } = new();

        /// <summary>
        /// Windows Event Log settings
        /// </summary>
        public EventLogSettings EventLog { get; set; } = new();

        /// <summary>
        /// Webhook notification settings
        /// </summary>
        public WebhookSettings Webhook { get; set; } = new();

        /// <summary>
        /// Notification rules and filters
        /// </summary>
        public NotificationRules Rules { get; set; } = new();
    }

    public class EmailSettings
    {
        public bool Enabled { get; set; } = false;

        // Legacy properties for compatibility
        public string SmtpHost { get; set; } = string.Empty;
        public string From { get; set; } = string.Empty;
        public string To { get; set; } = string.Empty;

        // New structured properties
        public string SmtpServer { get; set; } = string.Empty;
        public int SmtpPort { get; set; } = 587;
        public bool UseSsl { get; set; } = true;
        public string Username { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty; // Should be encrypted in production
        public string FromAddress { get; set; } = string.Empty;
        public string FromDisplayName { get; set; } = "CamBridge Service";
        public List<string> ToAddresses { get; set; } = new();
        public List<string> CcAddresses { get; set; } = new();
        public string SubjectPrefix { get; set; } = "[CamBridge]";
        public int TimeoutSeconds { get; set; } = 30;

        /// <summary>
        /// Legacy compatibility - returns first address from ToAddresses
        /// </summary>
        public string GetPrimaryToAddress() => ToAddresses?.FirstOrDefault() ?? To;

        /// <summary>
        /// Legacy compatibility - sets both To and ToAddresses
        /// </summary>
        public void SetToAddress(string address)
        {
            To = address;
            if (!string.IsNullOrEmpty(address) && !ToAddresses.Contains(address))
            {
                ToAddresses.Add(address);
            }
        }
    }

    public class EventLogSettings
    {
        public bool Enabled { get; set; } = true;
        public string LogName { get; set; } = "Application";
        public string SourceName { get; set; } = "CamBridge";
        public bool CreateSourceIfMissing { get; set; } = true;
    }

    public class WebhookSettings
    {
        public bool Enabled { get; set; } = false;
        public string Url { get; set; } = string.Empty;
        public string Method { get; set; } = "POST";
        public Dictionary<string, string> Headers { get; set; } = new();
        public string ContentType { get; set; } = "application/json";
        public int TimeoutSeconds { get; set; } = 30;
        public int RetryCount { get; set; } = 3;
        public int RetryDelaySeconds { get; set; } = 5;
    }

    public class NotificationRules
    {
        /// <summary>
        /// Minimum time between notifications of the same type (anti-spam)
        /// </summary>
        public int MinimumIntervalMinutes { get; set; } = 5;

        /// <summary>
        /// Events that trigger notifications
        /// </summary>
        public NotificationTriggers Triggers { get; set; } = new();

        /// <summary>
        /// Daily summary settings
        /// </summary>
        public DailySummarySettings DailySummary { get; set; } = new();

        /// <summary>
        /// Batch notification settings
        /// </summary>
        public BatchNotificationSettings Batching { get; set; } = new();
    }

    public class NotificationTriggers
    {
        public bool OnServiceStart { get; set; } = true;
        public bool OnServiceStop { get; set; } = true;
        public bool OnError { get; set; } = true;
        public bool OnWarning { get; set; } = false;
        public bool OnSuccess { get; set; } = false;
        public bool OnPipelineComplete { get; set; } = true;
        public bool OnFolderWatchError { get; set; } = true;
        public bool OnConfigurationChange { get; set; } = true;
        public bool OnHealthCheckFailure { get; set; } = true;

        /// <summary>
        /// Error count threshold before notification
        /// </summary>
        public int ErrorThreshold { get; set; } = 5;

        /// <summary>
        /// Time window for error threshold (minutes)
        /// </summary>
        public int ErrorThresholdWindowMinutes { get; set; } = 60;
    }

    public class DailySummarySettings
    {
        public bool Enabled { get; set; } = true;
        public TimeSpan SendTime { get; set; } = new TimeSpan(8, 0, 0); // 8:00 AM
        public bool IncludeStatistics { get; set; } = true;
        public bool IncludeErrors { get; set; } = true;
        public bool IncludeWarnings { get; set; } = false;
        public bool OnlyIfActivity { get; set; } = true;
    }

    public class BatchNotificationSettings
    {
        public bool Enabled { get; set; } = false;
        public int BatchSize { get; set; } = 10;
        public int BatchWindowMinutes { get; set; } = 15;
        public bool GroupBySeverity { get; set; } = true;
    }

    public enum NotificationSeverity
    {
        Information,
        Success,
        Warning,
        Error,
        Critical
    }

    public enum NotificationLevel
    {
        None = 0,
        Critical = 1,
        Error = 2,
        Warning = 3,
        Information = 4,
        Debug = 5,
        All = 6
    }

    public static class NotificationLevelExtensions
    {
        public static int ToInt(this NotificationLevel level)
        {
            return (int)level;
        }

        public static NotificationLevel ToNotificationLevel(this int value)
        {
            if (Enum.IsDefined(typeof(NotificationLevel), value))
                return (NotificationLevel)value;
            return NotificationLevel.Error; // Default
        }
    }

    public enum NotificationEventType
    {
        ServiceStarted,
        ServiceStopped,
        ServiceError,
        ProcessingStarted,
        ProcessingCompleted,
        ProcessingFailed,
        ConfigurationChanged,
        HealthCheckPassed,
        HealthCheckFailed,
        FolderWatchStarted,
        FolderWatchStopped,
        FolderWatchError,
        DailySummary,
        Custom
    }
}
// src\CamBridge.Core\PipelineConfiguration.cs
// Version: 0.8.0
// Description: Pipeline configuration model with PACS support
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;

namespace CamBridge.Core
{
    /// <summary>
    /// Represents a complete processing pipeline from input to output
    /// </summary>
    public class PipelineConfiguration : INotifyPropertyChanged
    {
        private Guid _id = Guid.NewGuid();
        private string _name = "New Pipeline";
        private string? _description;
        private bool _enabled = true;
        private PipelineWatchSettings _watchSettings = new();
        private ProcessingOptions _processingOptions = new();
        private DicomOverrides? _dicomOverrides;
        private Guid? _mappingSetId;
        private PacsConfiguration? _pacsConfiguration;

        /// <summary>
        /// Unique identifier for this pipeline
        /// </summary>
        public Guid Id
        {
            get => _id;
            set { _id = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Display name for this pipeline
        /// </summary>
        public string Name
        {
            get => _name;
            set { _name = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Optional description
        /// </summary>
        public string? Description
        {
            get => _description;
            set { _description = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Whether this pipeline is active
        /// </summary>
        public bool Enabled
        {
            get => _enabled;
            set { _enabled = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Watch folder configuration for this pipeline
        /// </summary>
        public PipelineWatchSettings WatchSettings
        {
            get => _watchSettings;
            set { _watchSettings = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Processing options specific to this pipeline
        /// </summary>
        public ProcessingOptions ProcessingOptions
        {
            get => _processingOptions;
            set { _processingOptions = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// DICOM overrides for this pipeline (optional)
        /// </summary>
        public DicomOverrides? DicomOverrides
        {
            get => _dicomOverrides;
            set { _dicomOverrides = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// ID of the mapping set to use
        /// </summary>
        public Guid? MappingSetId
        {
            get => _mappingSetId;
            set { _mappingSetId = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// PACS upload configuration for this pipeline (optional)
        /// </summary>
        public PacsConfiguration? PacsConfiguration
        {
            get => _pacsConfiguration;
            set { _pacsConfiguration = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Pipeline-specific metadata
        /// </summary>
        public Dictionary<string, string> Metadata { get; set; } = new();

        /// <summary>
        /// Creation timestamp
        /// </summary>
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Last modification timestamp
        /// </summary>
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Calculated property for UI display
        /// </summary>
        [JsonIgnore]
        public string ProcessedToday => "0 files"; // TODO: Implement actual counting

        [JsonIgnore]
        public bool IsValid => WatchSettings?.IsValid ?? false;

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Watch folder settings for a pipeline
    /// </summary>
    public class PipelineWatchSettings : INotifyPropertyChanged
    {
        private string _path = string.Empty;
        private string _filePattern = "*.jpg;*.jpeg";
        private bool _includeSubdirectories = false;
        private string? _outputPath;
        private int _minimumFileAgeSeconds = 2;

        /// <summary>
        /// Folder path to watch
        /// </summary>
        public string Path
        {
            get => _path;
            set { _path = value; OnPropertyChanged(); OnPropertyChanged(nameof(IsValid)); }
        }

        /// <summary>
        /// File pattern to match (e.g., "*.jpg;*.jpeg")
        /// </summary>
        public string FilePattern
        {
            get => _filePattern;
            set { _filePattern = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Include subdirectories in watch
        /// </summary>
        public bool IncludeSubdirectories
        {
            get => _includeSubdirectories;
            set { _includeSubdirectories = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Custom output path (overrides processing options)
        /// </summary>
        public string? OutputPath
        {
            get => _outputPath;
            set { _outputPath = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Minimum file age before processing (to ensure write completion)
        /// </summary>
        public int MinimumFileAgeSeconds
        {
            get => _minimumFileAgeSeconds;
            set { _minimumFileAgeSeconds = value; OnPropertyChanged(); }
        }

        [JsonIgnore]
        public bool IsValid => !string.IsNullOrWhiteSpace(Path) &&
                              System.IO.Directory.Exists(Path);

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// DICOM settings that can be overridden per pipeline
    /// </summary>
    public class DicomOverrides : INotifyPropertyChanged
    {
        private string? _institutionName;
        private string? _institutionDepartment;
        private string? _stationName;

        /// <summary>
        /// Override institution name for this pipeline
        /// </summary>
        public string? InstitutionName
        {
            get => _institutionName;
            set { _institutionName = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Override institution department for this pipeline
        /// </summary>
        public string? InstitutionDepartment
        {
            get => _institutionDepartment;
            set { _institutionDepartment = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Override station name for this pipeline
        /// </summary>
        public string? StationName
        {
            get => _stationName;
            set { _stationName = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Additional DICOM tags to set/override
        /// </summary>
        public Dictionary<string, string> AdditionalTags { get; set; } = new();

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Represents a reusable mapping configuration set
    /// </summary>
    public class MappingSet : INotifyPropertyChanged
    {
        private Guid _id = Guid.NewGuid();
        private string _name = "New Mapping Set";
        private string? _description;
        private bool _isSystemDefault = false;

        /// <summary>
        /// Unique identifier
        /// </summary>
        public Guid Id
        {
            get => _id;
            set { _id = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Display name
        /// </summary>
        public string Name
        {
            get => _name;
            set { _name = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Optional description
        /// </summary>
        public string? Description
        {
            get => _description;
            set { _description = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// The actual mapping rules
        /// </summary>
        public List<MappingRule> Rules { get; set; } = new();

        /// <summary>
        /// Whether this is a system default (read-only)
        /// </summary>
        public bool IsSystemDefault
        {
            get => _isSystemDefault;
            set { _isSystemDefault = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Creation timestamp
        /// </summary>
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Last modification timestamp
        /// </summary>
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Tags for categorization
        /// </summary>
        public List<string> Tags { get; set; } = new();

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// PACS (Picture Archiving and Communication System) configuration for automatic upload
    /// </summary>
    public class PacsConfiguration : INotifyPropertyChanged
    {
        private bool _enabled = false;
        private string _host = string.Empty;
        private int _port = 104;
        private string _calledAeTitle = string.Empty;
        private string _callingAeTitle = "CAMBRIDGE";
        private int _timeoutSeconds = 30;
        private int _maxConcurrentUploads = 1;
        private bool _retryOnFailure = true;
        private int _maxRetryAttempts = 3;
        private int _retryDelaySeconds = 5;

        /// <summary>
        /// Enable automatic PACS upload after DICOM creation
        /// </summary>
        public bool Enabled
        {
            get => _enabled;
            set { _enabled = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// PACS server hostname or IP address
        /// </summary>
        public string Host
        {
            get => _host;
            set { _host = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// PACS server port (default: 104)
        /// </summary>
        public int Port
        {
            get => _port;
            set { _port = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Called AE Title (PACS server's AE Title)
        /// </summary>
        public string CalledAeTitle
        {
            get => _calledAeTitle;
            set { _calledAeTitle = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Calling AE Title (our AE Title)
        /// </summary>
        public string CallingAeTitle
        {
            get => _callingAeTitle;
            set { _callingAeTitle = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Connection timeout in seconds
        /// </summary>
        public int TimeoutSeconds
        {
            get => _timeoutSeconds;
            set { _timeoutSeconds = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum concurrent uploads per pipeline
        /// </summary>
        public int MaxConcurrentUploads
        {
            get => _maxConcurrentUploads;
            set { _maxConcurrentUploads = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Enable retry on upload failure
        /// </summary>
        public bool RetryOnFailure
        {
            get => _retryOnFailure;
            set { _retryOnFailure = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum retry attempts
        /// </summary>
        public int MaxRetryAttempts
        {
            get => _maxRetryAttempts;
            set { _maxRetryAttempts = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Delay between retry attempts in seconds
        /// </summary>
        public int RetryDelaySeconds
        {
            get => _retryDelaySeconds;
            set { _retryDelaySeconds = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Validate configuration
        /// </summary>
        public bool IsValid() =>
            !string.IsNullOrWhiteSpace(Host) &&
            Port > 0 &&
            Port < 65536 &&
            !string.IsNullOrWhiteSpace(CalledAeTitle) &&
            !string.IsNullOrWhiteSpace(CallingAeTitle) &&
            CalledAeTitle.Length <= 16 &&
            CallingAeTitle.Length <= 16;

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
// src/CamBridge.Infrastructure/ServiceCollectionExtensions.cs
// Version: 0.8.0
// Description: DI container configuration with DicomStoreService
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure
{
    /// <summary>
    /// Extension methods for service registration
    /// PIPELINE UPDATE: FileProcessor no longer registered as singleton!
    /// </summary>
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Adds infrastructure services to the DI container
        /// </summary>
        public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
        {
            // Add configuration
            services.Configure<CamBridgeSettingsV2>(configuration.GetSection("CamBridge"));
            services.Configure<ProcessingOptions>(configuration.GetSection("CamBridge:DefaultProcessingOptions"));

            // Add notification settings (global)
            services.Configure<NotificationSettings>(configuration.GetSection("CamBridge:Notifications"));

            // Register shared services (used by all pipelines)
            // FIX: ExifToolReader needs the path from configuration!
            services.AddSingleton<ExifToolReader>(sp =>
            {
                var settings = sp.GetRequiredService<IOptionsMonitor<CamBridgeSettingsV2>>().CurrentValue;
                return new ExifToolReader(
                    sp.GetRequiredService<ILogger<ExifToolReader>>(),
                    settings.ExifToolPath ?? "Tools\\exiftool.exe"
                );
            });

            services.AddSingleton<DicomConverter>();

            // Register DICOM Store Service for PACS upload
            services.AddSingleton<DicomStoreService>();

            // FileProcessor is NO LONGER registered here!
            // It's created per-pipeline in PipelineManager!
            // services.AddSingleton<FileProcessor>(); // REMOVED!

            // Register pipeline manager
            services.AddSingleton<PipelineManager>();

            // Register notification service (v0.7.18: Direct class, no interface!)
            services.AddSingleton<NotificationService>();

            // Register remaining interfaces (only 2 left!)
            services.AddSingleton<IMappingConfiguration, MappingConfigurationLoader>();
            services.AddSingleton<IDicomTagMapper, DicomTagMapper>();

            return services;
        }
    }
}
