// src\CamBridge.Config\ViewModels\LogViewerViewModel.cs
// Version: 0.8.11
// Description: Enhanced log viewer with FIXED TreeView parser
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.Services;
using CamBridge.Core;
using CamBridge.Core.Enums;
using CamBridge.Core.Infrastructure;
using CamBridge.Core.Logging;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;


namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Tracks file position for incremental reading
    /// </summary>
    public class FilePositionInfo
    {
        public long Position { get; set; }
        public DateTime LastRead { get; set; }
    }

    /// <summary>
    /// Represents a selectable pipeline in the multi-select dropdown
    /// </summary>
    public class PipelineSelection : ViewModelBase
    {
        private bool _isSelected;

        public string Name { get; set; } = string.Empty;
        public string SanitizedName { get; set; } = string.Empty;

        public bool IsSelected
        {
            get => _isSelected;
            set => SetProperty(ref _isSelected, value);
        }
    }

    /// <summary>
    /// Enhanced ViewModel for the log viewer with correlation ID support
    /// </summary>
    public partial class LogViewerViewModel : ViewModelBase
    {
        private readonly ILogger<LogViewerViewModel> _logger;
        private readonly IConfigurationService _configurationService;
        private readonly Dictionary<string, string> _pipelineNameMapping;
        private readonly Timer _refreshTimer;
        private readonly Dictionary<string, long> _filePositions;
        private CancellationTokenSource? _watcherCancellation;
        private FileSystemWatcher? _logWatcher;

        // Constants
        private const int MaxDisplayedEntries = 10000;
        private const int TailLineCount = 1000;
        private const int RefreshIntervalMs = 1000;

        public LogViewerViewModel(
            ILogger<LogViewerViewModel> logger,
            IConfigurationService configurationService)
        {
            _logger = logger;
            _configurationService = configurationService;
            _pipelineNameMapping = new Dictionary<string, string>();
            _filePositions = new Dictionary<string, long>();

            // Initialize collections
            LogEntries = new ObservableCollection<LogEntry>();
            FilteredCombinedEntries = new ObservableCollection<LogEntry>();
            CombinedLogEntries = new ObservableCollection<LogEntry>();
            CorrelationGroups = new ObservableCollection<CorrelationGroup>();
            AvailablePipelines = new ObservableCollection<string>();
            PipelineSelections = new ObservableCollection<PipelineSelection>();

            // Initialize commands
            RefreshCommand = new AsyncRelayCommand(RefreshLogsAsync);
            ClearLogCommand = new RelayCommand(ClearLogs);
            ExportLogCommand = new AsyncRelayCommand(ExportLogsAsync);
            ToggleTreeViewCommand = new RelayCommand(() => IsTreeViewEnabled = !IsTreeViewEnabled);
            ExpandAllCommand = new RelayCommand(ExpandAll);
            CollapseAllCommand = new RelayCommand(CollapseAll);
            CopySelectedCommand = new RelayCommand(CopySelected);
            OpenLogFolderCommand = new RelayCommand(OpenLogFolder);
            ClearFiltersCommand = new RelayCommand(ClearFilters);
            CopyLineCommand = new RelayCommand<object>(CopyLine);
            CopyGroupCommand = new RelayCommand<object>(CopyGroup);
            ExpandGroupCommand = new RelayCommand<object>(ExpandGroup);

            // Initialize timer for auto-refresh
            _refreshTimer = new Timer(OnRefreshTimer, null, Timeout.Infinite, Timeout.Infinite);

            // Set default filter values
            ShowDebug = false;  // Debug meist zu viel
            ShowInformation = true;
            ShowWarning = true;
            ShowError = true;
            ShowCritical = true;
            IsAutoScrollEnabled = false; // Default OFF to prevent flicker
            IsTreeViewEnabled = true; // Default to tree view for correlation
        }

        #region Properties

        [ObservableProperty]
        private ObservableCollection<LogEntry> logEntries;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(DisplayedLineCount))]
        private ObservableCollection<LogEntry> filteredCombinedEntries;

        [ObservableProperty]
        private ObservableCollection<LogEntry> combinedLogEntries;

        [ObservableProperty]
        private ObservableCollection<CorrelationGroup> correlationGroups;

        [ObservableProperty]
        private ObservableCollection<string> availablePipelines;

        [ObservableProperty]
        private ObservableCollection<PipelineSelection> pipelineSelections;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string? searchText;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string filter1 = string.Empty;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string filter2 = string.Empty;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string filter3 = string.Empty;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showDebug;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showInformation;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showWarning;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showError;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showCritical;

        [ObservableProperty]
        private bool isAutoScrollEnabled;

        [ObservableProperty]
        private bool isTreeViewEnabled;

        [ObservableProperty]
        private bool isLoading;

        [ObservableProperty]
        private string currentLogFile = "No log file loaded";

        [ObservableProperty]
        private string currentLogFiles = "No files selected";

        [ObservableProperty]
        private int totalLineCount;

        [ObservableProperty]
        private DateTime lastUpdateTime = DateTime.Now;

        public int DisplayedLineCount =>
            IsTreeViewEnabled
                ? CorrelationGroups?.Sum(g => g.TotalEntries) ?? 0
                : FilteredCombinedEntries?.Count ?? 0;

        public int SelectedPipelineCount => PipelineSelections?.Count(p => p.IsSelected) ?? 0;

        public int SelectedLevelCount
        {
            get
            {
                var count = 0;
                if (ShowDebug) count++;
                if (ShowInformation) count++;
                if (ShowWarning) count++;
                if (ShowError) count++;
                if (ShowCritical) count++;
                return count;
            }
        }

        #endregion

        #region Commands

        public IAsyncRelayCommand RefreshCommand { get; }
        public IRelayCommand ClearLogCommand { get; }
        public IAsyncRelayCommand ExportLogCommand { get; }
        public IRelayCommand ToggleTreeViewCommand { get; }
        public IRelayCommand ExpandAllCommand { get; }
        public IRelayCommand CollapseAllCommand { get; }
        public IRelayCommand CopySelectedCommand { get; }
        public IRelayCommand OpenLogFolderCommand { get; }
        public IRelayCommand ClearFiltersCommand { get; }
        public ICommand CopyLineCommand { get; }
        public ICommand CopyGroupCommand { get; }
        public ICommand ExpandGroupCommand { get; }

        #endregion

        #region Public Methods

        public async Task InitializeAsync()
        {
            try
            {
                _logger.LogInformation("Initializing Enhanced LogViewerViewModel");

                // Load available pipelines
                await LoadAvailablePipelinesAsync();

                // Update count display
                OnPropertyChanged(nameof(SelectedPipelineCount));
                OnPropertyChanged(nameof(SelectedLevelCount));

                // Log initial filter state
                _logger.LogInformation("Initial filter state: Debug={Debug}, Info={Info}, Warn={Warn}, Error={Error}, Critical={Critical}",
                    ShowDebug, ShowInformation, ShowWarning, ShowError, ShowCritical);

                // Log selected pipelines
                var selected = PipelineSelections.Where(p => p.IsSelected).Select(p => p.Name).ToList();
                _logger.LogInformation("Selected pipelines: {Pipelines}", string.Join(", ", selected));

                // Load initial logs
                await RefreshLogsAsync();

                // Start auto-refresh if enabled
                if (IsAutoScrollEnabled)
                {
                    _refreshTimer.Change(RefreshIntervalMs, RefreshIntervalMs);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to initialize LogViewerViewModel");
            }
        }

        public void Cleanup()
        {
            try
            {
                _refreshTimer?.Change(Timeout.Infinite, Timeout.Infinite);
                _refreshTimer?.Dispose();
                _watcherCancellation?.Cancel();
                _watcherCancellation?.Dispose();
                _logWatcher?.Dispose();

                // Unsubscribe from selection changes
                foreach (var selection in PipelineSelections)
                {
                    selection.PropertyChanged -= OnPipelineSelectionChanged;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during cleanup");
            }
        }

        #endregion

        #region Copy Command Implementations

        private void CopyLine(object? parameter)
        {
            if (parameter is LogEntry entry)
            {
                var text = $"[{entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff}] [{entry.CorrelationId}] [{entry.Stage}] {entry.Message}";
                Clipboard.SetText(text);
            }
        }

        private void CopyGroup(object? parameter)
        {
            if (parameter is CorrelationGroup group)
            {
                var sb = new StringBuilder();
                sb.AppendLine($"=== {group.CorrelationId} - {group.Pipeline} [{group.DurationText}] ===");

                // Get all entries sorted
                var allEntries = new List<LogEntry>();
                foreach (var stage in group.Stages)
                {
                    allEntries.AddRange(stage.Entries);
                }
                allEntries.AddRange(group.UngroupedEntries);

                foreach (var entry in allEntries.OrderBy(e => e.Timestamp))
                {
                    sb.AppendLine($"{entry.Timestamp:HH:mm:ss.fff} {entry.Stage}: {entry.Message}");
                }

                Clipboard.SetText(sb.ToString());
            }
        }

        private void ExpandGroup(object? parameter)
        {
            if (parameter is CorrelationGroup group)
            {
                group.IsExpanded = true;
                // In compact view we don't have nested stages anymore
            }
        }

        #endregion

        private void ApplyFilters()
        {
            // WICHTIG: Muss auf dem UI Thread laufen!
            if (!Application.Current.Dispatcher.CheckAccess())
            {
                Application.Current.Dispatcher.Invoke(() => ApplyFilters());
                return;
            }

            _logger.LogDebug("ApplyFilters: Starting with {Count} combined entries", CombinedLogEntries.Count);

            var filtered = CombinedLogEntries.AsEnumerable();

            // Apply level filters
            var anyLevelSelected = ShowDebug || ShowInformation || ShowWarning || ShowError || ShowCritical;

            if (anyLevelSelected)
            {
                filtered = filtered.Where(e =>
                    (ShowDebug && e.Level == LogLevel.Debug) ||
                    (ShowInformation && e.Level == LogLevel.Information) ||
                    (ShowWarning && e.Level == LogLevel.Warning) ||
                    (ShowError && e.Level == LogLevel.Error) ||
                    (ShowCritical && e.Level == LogLevel.Critical));
            }

            // Apply search filter (legacy single search)
            if (!string.IsNullOrWhiteSpace(SearchText))
            {
                var searchLower = SearchText.ToLowerInvariant();
                filtered = filtered.Where(e =>
                    e.Message.ToLowerInvariant().Contains(searchLower) ||
                    e.LevelText.ToLowerInvariant().Contains(searchLower) ||
                    e.Source.ToLowerInvariant().Contains(searchLower) ||
                    (e.CorrelationId?.ToLowerInvariant().Contains(searchLower) ?? false) ||
                    (e.Stage?.ToString().ToLowerInvariant().Contains(searchLower) ?? false));
            }

            // Update filtered collection
            var filteredList = filtered.ToList();

            // NEW: Apply Triple Text Filter if tree view is enabled
            if (IsTreeViewEnabled && (!string.IsNullOrWhiteSpace(Filter1) || !string.IsNullOrWhiteSpace(Filter2) || !string.IsNullOrWhiteSpace(Filter3)))
            {
                filteredList = ApplyTripleTextFilter(filteredList);
            }

            _logger.LogDebug("After filtering: {Count} entries remain", filteredList.Count);

            FilteredCombinedEntries.Clear();
            foreach (var entry in filteredList)
            {
                FilteredCombinedEntries.Add(entry);
            }

            // Update correlation groups if tree view is enabled
            if (IsTreeViewEnabled)
            {
                UpdateCorrelationGroups(filteredList);
            }
        }

        private List<LogEntry> ApplyTripleTextFilter(List<LogEntry> entries)
        {
            // For tree-aware filtering, we need to check groups
            var groups = entries
                .Where(e => !string.IsNullOrEmpty(e.CorrelationId))
                .GroupBy(e => e.CorrelationId!)
                .ToList();

            var matchingEntries = new List<LogEntry>();

            foreach (var group in groups)
            {
                // Check if ANY entry in the group matches ALL active filters
                bool groupMatches = group.Any(entry =>
                {
                    var fullText = $"{entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.CorrelationId} {entry.Stage} {entry.Message} {entry.Pipeline}";

                    return MatchesWildcard(fullText, Filter1) &&
                           MatchesWildcard(fullText, Filter2) &&
                           MatchesWildcard(fullText, Filter3);
                });

                if (groupMatches)
                {
                    // Include ALL entries from matching groups (tree-aware!)
                    matchingEntries.AddRange(group);
                }
            }

            // Also check uncorrelated entries individually
            var uncorrelated = entries.Where(e => string.IsNullOrEmpty(e.CorrelationId)).ToList();
            foreach (var entry in uncorrelated)
            {
                var fullText = $"{entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.Message} {entry.Pipeline}";

                if (MatchesWildcard(fullText, Filter1) &&
                    MatchesWildcard(fullText, Filter2) &&
                    MatchesWildcard(fullText, Filter3))
                {
                    matchingEntries.Add(entry);
                }
            }

            return matchingEntries;
        }

        private bool MatchesWildcard(string text, string pattern)
        {
            if (string.IsNullOrWhiteSpace(pattern)) return true;

            // Convert wildcard pattern to regex
            var regexPattern = "^" + Regex.Escape(pattern)
                .Replace("\\*", ".*")    // * = any number of chars
                .Replace("\\?", ".")     // ? = exactly one char
                + "$";

            return Regex.IsMatch(text, regexPattern, RegexOptions.IgnoreCase);
        }

        private void ClearFilters()
        {
            SearchText = string.Empty;
            Filter1 = string.Empty;
            Filter2 = string.Empty;
            Filter3 = string.Empty;
        }

        private void UpdateCorrelationGroups(List<LogEntry> entries)
        {
            // DEBUG OUTPUT
            Console.WriteLine($"[DEBUG] UpdateCorrelationGroups called with {entries.Count} entries");

            CorrelationGroups.Clear();

            // Group by correlation ID
            var groups = entries
                .Where(e => !string.IsNullOrEmpty(e.CorrelationId))
                .GroupBy(e => e.CorrelationId!)
                .OrderByDescending(g => g.Max(e => e.Timestamp));

            Console.WriteLine($"[DEBUG] Found {groups.Count()} correlation groups");

            foreach (var group in groups)
            {
                Console.WriteLine($"[DEBUG] Processing group {group.Key} with {group.Count()} entries");

                var correlationGroup = new CorrelationGroup
                {
                    CorrelationId = group.Key,
                    StartTime = group.Min(e => e.Timestamp),
                    EndTime = group.Max(e => e.Timestamp),
                    Pipeline = group.FirstOrDefault(e => !string.IsNullOrEmpty(e.Pipeline))?.Pipeline ?? "Unknown",
                    IsExpanded = true // Default expanded!
                };

                // Build stage hierarchy
                var stages = new Dictionary<ProcessingStage, StageGroup>();

                foreach (var entry in group.OrderBy(e => e.Timestamp))
                {
                    if (entry.Stage.HasValue)
                    {
                        if (!stages.ContainsKey(entry.Stage.Value))
                        {
                            stages[entry.Stage.Value] = new StageGroup
                            {
                                Stage = entry.Stage.Value,
                                StartTime = entry.Timestamp,
                                IsExpanded = true // Default expanded!
                            };
                        }

                        stages[entry.Stage.Value].Entries.Add(entry);
                        stages[entry.Stage.Value].EndTime = entry.Timestamp;
                    }
                    else
                    {
                        // Add entries without stage directly to correlation group
                        correlationGroup.UngroupedEntries.Add(entry);
                    }
                }

                // Add stages to correlation group
                foreach (var stage in stages.Values.OrderBy(s => s.StartTime))
                {
                    correlationGroup.Stages.Add(stage);
                }

                // Determine overall status
                if (stages.ContainsKey(ProcessingStage.Error))
                {
                    correlationGroup.Status = ProcessingStatus.Failed;
                }
                else if (stages.ContainsKey(ProcessingStage.Complete))
                {
                    correlationGroup.Status = ProcessingStatus.Completed;
                }
                else
                {
                    correlationGroup.Status = ProcessingStatus.InProgress;
                }

                CorrelationGroups.Add(correlationGroup);
            }

            // Add entries without correlation ID
            var uncorrelatedEntries = entries.Where(e => string.IsNullOrEmpty(e.CorrelationId)).ToList();
            Console.WriteLine($"[DEBUG] Found {uncorrelatedEntries.Count} uncorrelated entries");

            if (uncorrelatedEntries.Any())
            {
                var uncorrelatedGroup = new CorrelationGroup
                {
                    CorrelationId = "Uncorrelated",
                    StartTime = uncorrelatedEntries.Min(e => e.Timestamp),
                    EndTime = uncorrelatedEntries.Max(e => e.Timestamp),
                    Pipeline = "Various",
                    IsExpanded = true, // Default expanded!
                    Status = ProcessingStatus.Unknown
                };

                foreach (var entry in uncorrelatedEntries.OrderBy(e => e.Timestamp))
                {
                    uncorrelatedGroup.UngroupedEntries.Add(entry);
                }

                CorrelationGroups.Add(uncorrelatedGroup);
            }

            Console.WriteLine($"[DEBUG] Total CorrelationGroups: {CorrelationGroups.Count}");
        }

        private void ExpandAll()
        {
            foreach (var group in CorrelationGroups)
            {
                group.IsExpanded = true;
                foreach (var stage in group.Stages)
                {
                    stage.IsExpanded = true;
                }
            }
        }

        private void CollapseAll()
        {
            foreach (var group in CorrelationGroups)
            {
                group.IsExpanded = false;
                foreach (var stage in group.Stages)
                {
                    stage.IsExpanded = false;
                }
            }
        }

        private void CopySelected()
        {
            // Copy all visible log entries to clipboard
            var sb = new StringBuilder();

            if (IsTreeViewEnabled)
            {
                // Copy tree structure
                foreach (var group in CorrelationGroups)
                {
                    sb.AppendLine($"=== {group.CorrelationId} - {group.Pipeline} [{group.DurationText}] ===");

                    foreach (var stage in group.Stages)
                    {
                        sb.AppendLine($"  {stage.Stage} [{stage.DurationText}]");
                        foreach (var entry in stage.Entries)
                        {
                            sb.AppendLine($"    {entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                        }
                    }

                    if (group.UngroupedEntries.Any())
                    {
                        sb.AppendLine("  [Ungrouped]");
                        foreach (var entry in group.UngroupedEntries)
                        {
                            sb.AppendLine($"    {entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                        }
                    }

                    sb.AppendLine();
                }
            }
            else
            {
                // Copy flat list
                foreach (var entry in FilteredCombinedEntries)
                {
                    sb.AppendLine($"{entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} [{entry.CorrelationId}] [{entry.Stage}] {entry.Message}");
                }
            }

            if (sb.Length > 0)
            {
                Clipboard.SetText(sb.ToString());
                _logger.LogInformation("Copied {Count} entries to clipboard",
                    IsTreeViewEnabled ? CorrelationGroups.Sum(g => g.TotalEntries) : FilteredCombinedEntries.Count);
            }
        }

        private void OpenLogFolder()
        {
            try
            {
                var logPath = ConfigurationPaths.GetLogsDirectory();
                if (Directory.Exists(logPath))
                {
                    Process.Start(new ProcessStartInfo
                    {
                        FileName = logPath,
                        UseShellExecute = true,
                        Verb = "open"
                    });
                    _logger.LogInformation("Opened log folder: {Path}", logPath);
                }
                else
                {
                    _logger.LogWarning("Log folder does not exist: {Path}", logPath);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to open log folder");
            }
        }
        private async Task LoadAvailablePipelinesAsync()
        {
            try
            {
                AvailablePipelines.Clear();
                PipelineSelections.Clear();
                _pipelineNameMapping.Clear();

                // Always add Service (Global) log
                AvailablePipelines.Add("Service (Global)");
                PipelineSelections.Add(new PipelineSelection
                {
                    Name = "Service (Global)",
                    SanitizedName = "service",
                    IsSelected = true // Default selected
                });

                // Get configured pipelines
                var settings = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();
                if (settings?.Pipelines != null)
                {
                    var isFirstPipeline = true;
                    foreach (var pipeline in settings.Pipelines)
                    {
                        var displayName = $"{pipeline.Name}";
                        var sanitizedName = SanitizeForFileName(pipeline.Name);

                        AvailablePipelines.Add(displayName);
                        _pipelineNameMapping[displayName] = sanitizedName;

                        PipelineSelections.Add(new PipelineSelection
                        {
                            Name = displayName,
                            SanitizedName = sanitizedName,
                            IsSelected = isFirstPipeline // Select first pipeline by default
                        });

                        isFirstPipeline = false;
                    }
                }

                // Also check for existing log files that might not be in config
                var logPath = ConfigurationPaths.GetLogsDirectory();
                if (Directory.Exists(logPath))
                {
                    var pipelineLogFiles = Directory.GetFiles(logPath, "pipeline_*.log")
                        .Select(Path.GetFileNameWithoutExtension)
                        .Where(f => f != null && f.StartsWith("pipeline_"))
                        .Select(f => f!.Substring("pipeline_".Length))
                        .Distinct();

                    foreach (var logName in pipelineLogFiles)
                    {
                        if (!_pipelineNameMapping.Values.Contains(logName))
                        {
                            var displayName = $"{logName} (Archived)";
                            AvailablePipelines.Add(displayName);
                            _pipelineNameMapping[displayName] = logName;

                            PipelineSelections.Add(new PipelineSelection
                            {
                                Name = displayName,
                                SanitizedName = logName,
                                IsSelected = false
                            });
                        }
                    }
                }

                // Listen for selection changes
                foreach (var selection in PipelineSelections)
                {
                    selection.PropertyChanged += OnPipelineSelectionChanged;
                }

                // Update initial count
                OnPropertyChanged(nameof(SelectedPipelineCount));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to load available pipelines");
            }
        }

        private async Task RefreshLogsAsync()
        {
            try
            {
                IsLoading = true;

                // Get selected pipelines
                var selectedPipelines = PipelineSelections.Where(p => p.IsSelected).ToList();
                if (!selectedPipelines.Any())
                {
                    CombinedLogEntries.Clear();
                    CorrelationGroups.Clear();
                    CurrentLogFiles = "No pipelines selected";
                    return;
                }

                // Update current files display
                if (selectedPipelines.Count == 0)
                {
                    CurrentLogFiles = "No pipelines selected";
                }
                else if (selectedPipelines.Count == 1)
                {
                    CurrentLogFiles = selectedPipelines[0].Name;
                }
                else
                {
                    CurrentLogFiles = $"{selectedPipelines.Count} pipelines selected";
                }

                // Collect all log entries from selected pipelines
                var allEntries = new List<LogEntry>();

                foreach (var pipeline in selectedPipelines)
                {
                    var logFileName = GetLogFileName(pipeline.Name);
                    var logPath = Path.Combine(ConfigurationPaths.GetLogsDirectory(), logFileName);

                    if (File.Exists(logPath))
                    {
                        // Read entries from this pipeline
                        var entries = await ReadLogFileAsync(logPath, pipeline.Name);
                        allEntries.AddRange(entries);
                    }
                }

                // Sort all entries by timestamp (millisecond precision)
                var sortedEntries = allEntries
                    .OrderBy(e => e.Timestamp)
                    .TakeLast(MaxDisplayedEntries)
                    .ToList();

                // Update collection efficiently (minimize UI updates)
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    // For auto-scroll, append only new entries to prevent flicker
                    if (IsAutoScrollEnabled && CombinedLogEntries.Count > 0)
                    {
                        // Find the last timestamp we have
                        var lastTimestamp = CombinedLogEntries.Last().Timestamp;

                        // Add only newer entries
                        var newEntries = sortedEntries
                            .Where(e => e.Timestamp > lastTimestamp)
                            .ToList();

                        foreach (var entry in newEntries)
                        {
                            CombinedLogEntries.Add(entry);

                            // Maintain max entries
                            if (CombinedLogEntries.Count > MaxDisplayedEntries)
                                CombinedLogEntries.RemoveAt(0);
                        }
                    }
                    else
                    {
                        // Full refresh when not auto-scrolling
                        CombinedLogEntries.Clear();
                        foreach (var entry in sortedEntries)
                        {
                            CombinedLogEntries.Add(entry);
                        }
                    }
                });

                TotalLineCount = CombinedLogEntries.Count;
                LastUpdateTime = DateTime.Now;
                ApplyFilters();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to refresh logs");
            }
            finally
            {
                IsLoading = false;
            }
        }

        private async Task<List<LogEntry>> ReadLogFileAsync(string logPath, string sourcePipeline)
        {
            var entries = new List<LogEntry>();

            try
            {
                _logger.LogInformation("Reading log file: {Path} for pipeline: {Pipeline}", logPath, sourcePipeline);

                using (var fs = new FileStream(logPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var reader = new StreamReader(fs, Encoding.UTF8))
                {
                    string? line;
                    int lineCount = 0;
                    int parsedCount = 0;

                    while ((line = await reader.ReadLineAsync()) != null)
                    {
                        lineCount++;
                        var entry = ParseLogLine(line);
                        if (entry != null)
                        {
                            entry.Source = sourcePipeline; // Tag with source
                            entries.Add(entry);
                            parsedCount++;
                        }
                    }

                    _logger.LogInformation("Read {Lines} lines, parsed {Parsed} entries from {File}",
                        lineCount, parsedCount, Path.GetFileName(logPath));
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to read log file: {LogPath}", logPath);
            }

            return entries;
        }

        private LogEntry? ParseLogLine(string line)
        {
            if (string.IsNullOrWhiteSpace(line))
                return null;

            try
            {
                // DEBUG output for first few lines
                if (TotalLineCount < 10)
                {
                    Console.WriteLine($"[DEBUG] Parsing line: {line}");
                }

                // ROBUST PARSER - Try multiple patterns in order of specificity

                // Pattern 1: Full format with stage in quotes
                // [HH:mm:ss LEVEL] [CorrelationId] ["Stage"] Message [Pipeline]
                var fullFormatQuoted = Regex.Match(line,
                    @"^\[(\d{2}:\d{2}:\d{2})\s+(\w+)\]\s+\[([^\]]+)\]\s+\[""([^""]+)""\]\s+(.+)$");

                if (fullFormatQuoted.Success)
                {
                    return ParseFullFormat(line, fullFormatQuoted, true);
                }

                // Pattern 2: Full format with stage without quotes
                // [HH:mm:ss LEVEL] [CorrelationId] [Stage] Message [Pipeline]
                var fullFormatUnquoted = Regex.Match(line,
                    @"^\[(\d{2}:\d{2}:\d{2})\s+(\w+)\]\s+\[([^\]]+)\]\s+\[([^\]]+)\]\s+(.+)$");

                if (fullFormatUnquoted.Success)
                {
                    return ParseFullFormat(line, fullFormatUnquoted, false);
                }

                // Pattern 3: Format with correlation ID but no stage
                // [HH:mm:ss LEVEL] [CorrelationId] Message
                var noStageFormat = Regex.Match(line,
                    @"^\[(\d{2}:\d{2}:\d{2})\s+(\w+)\]\s+\[([^\]]+)\]\s+(.+)$");

                if (noStageFormat.Success)
                {
                    var timeStr = noStageFormat.Groups[1].Value;
                    var levelStr = noStageFormat.Groups[2].Value;
                    var correlationId = noStageFormat.Groups[3].Value;
                    var message = noStageFormat.Groups[4].Value;

                    // Parse timestamp
                    var timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss", CultureInfo.InvariantCulture);
                    timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

                    // Extract pipeline if present at end
                    string? pipeline = null;
                    var pipelineMatch = Regex.Match(message, @"\s*\[([^\]]+)\]\s*$");
                    if (pipelineMatch.Success)
                    {
                        pipeline = pipelineMatch.Groups[1].Value;
                        message = message.Substring(0, message.Length - pipelineMatch.Value.Length).Trim();
                    }

                    // Try to infer stage from message patterns
                    ProcessingStage? stage = InferStageFromMessage(message);

                    return new LogEntry
                    {
                        Timestamp = timestamp,
                        Level = ParseLogLevel(levelStr),
                        Message = message,
                        RawLine = line,
                        CorrelationId = correlationId,
                        Stage = stage,
                        Pipeline = pipeline
                    };
                }

                // Pattern 4: Simple format without correlation ID
                // [HH:mm:ss LEVEL] Message
                var simpleFormat = Regex.Match(line,
                    @"^\[(\d{2}:\d{2}:\d{2})\s+(\w+)\]\s+(.+)$");

                if (simpleFormat.Success)
                {
                    var timeStr = simpleFormat.Groups[1].Value;
                    var levelStr = simpleFormat.Groups[2].Value;
                    var message = simpleFormat.Groups[3].Value;

                    var timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss", CultureInfo.InvariantCulture);
                    timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

                    return new LogEntry
                    {
                        Timestamp = timestamp,
                        Level = ParseLogLevel(levelStr),
                        Message = message,
                        RawLine = line
                    };
                }

                // Fallback: return as-is
                return new LogEntry
                {
                    Timestamp = DateTime.Now,
                    Level = LogLevel.Information,
                    Message = line,
                    RawLine = line
                };
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to parse log line: {Line}", line);
                return new LogEntry
                {
                    Timestamp = DateTime.Now,
                    Level = LogLevel.Information,
                    Message = line,
                    RawLine = line
                };
            }
        }

        private LogEntry ParseFullFormat(string line, Match match, bool stageIsQuoted)
        {
            var timeStr = match.Groups[1].Value;
            var levelStr = match.Groups[2].Value;
            var correlationId = match.Groups[3].Value;
            var stageStr = match.Groups[4].Value;
            var messageAndMore = match.Groups[5].Value;

            // Parse timestamp
            var timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss", CultureInfo.InvariantCulture);
            timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

            // Parse log level
            var level = ParseLogLevel(levelStr);

            // Parse stage - be more flexible
            ProcessingStage? stage = ParseStage(stageStr);

            // Extract message and pipeline
            var message = messageAndMore;
            string? pipeline = null;

            // Check for pipeline at end: [Radiology]
            var pipelineMatch = Regex.Match(messageAndMore, @"^(.+?)\s*\[([^\]]+)\]\s*$");
            if (pipelineMatch.Success)
            {
                message = pipelineMatch.Groups[1].Value.Trim();
                pipeline = pipelineMatch.Groups[2].Value;
            }

            // Extract duration if present
            int? durationMs = null;
            var durationMatch = Regex.Match(message, @"\[(\d+)ms\]");
            if (durationMatch.Success)
            {
                durationMs = int.Parse(durationMatch.Groups[1].Value);
                message = message.Replace(durationMatch.Value, "").Trim();
            }

            return new LogEntry
            {
                Timestamp = timestamp,
                Level = level,
                Message = message,
                RawLine = line,
                CorrelationId = correlationId,
                Stage = stage,
                Pipeline = pipeline,
                DurationMs = durationMs
            };
        }

        private ProcessingStage? ParseStage(string stageStr)
        {
            if (string.IsNullOrWhiteSpace(stageStr))
                return null;

            // Try exact match first
            if (Enum.TryParse<ProcessingStage>(stageStr, true, out var stage))
                return stage;

            // Try some common mappings
            var stageLower = stageStr.ToLowerInvariant();

            if (stageLower.Contains("startup"))
                return ProcessingStage.ServiceStartup;
            if (stageLower.Contains("shutdown"))
                return ProcessingStage.ServiceShutdown;
            if (stageLower.Contains("initialization") || stageLower.Contains("init"))
                return ProcessingStage.PipelineInitialization;
            if (stageLower.Contains("detected"))
                return ProcessingStage.FileDetected;
            if (stageLower.Contains("exif"))
                return ProcessingStage.ExifExtraction;
            if (stageLower.Contains("mapping"))
                return ProcessingStage.TagMapping;
            if (stageLower.Contains("dicom"))
                return ProcessingStage.DicomConversion;
            if (stageLower.Contains("pacs"))
                return ProcessingStage.PacsUpload;
            if (stageLower.Contains("complete"))
                return ProcessingStage.Complete;
            if (stageLower.Contains("error") || stageLower.Contains("failed"))
                return ProcessingStage.Error;

            return null;
        }

        private ProcessingStage? InferStageFromMessage(string message)
        {
            var messageLower = message.ToLowerInvariant();

            if (messageLower.Contains("starting") && messageLower.Contains("pipeline"))
                return ProcessingStage.PipelineInitialization;
            if (messageLower.Contains("processing file") || messageLower.Contains("file detected"))
                return ProcessingStage.FileDetected;
            if (messageLower.Contains("exif") || messageLower.Contains("metadata"))
                return ProcessingStage.ExifExtraction;
            if (messageLower.Contains("mapping") || messageLower.Contains("tag"))
                return ProcessingStage.TagMapping;
            if (messageLower.Contains("dicom") || messageLower.Contains("conversion"))
                return ProcessingStage.DicomConversion;
            if (messageLower.Contains("pacs") || messageLower.Contains("upload"))
                return ProcessingStage.PacsUpload;
            if (messageLower.Contains("success") || messageLower.Contains("complete"))
                return ProcessingStage.Complete;
            if (messageLower.Contains("error") || messageLower.Contains("failed"))
                return ProcessingStage.Error;

            return null;
        }

        private LogLevel DetermineLogLevel(ProcessingStage? stage, string message)
        {
            // Check stage first
            if (stage == ProcessingStage.Error)
                return LogLevel.Error;

            // Check message content
            var messageLower = message.ToLowerInvariant();
            if (messageLower.Contains("error") || messageLower.Contains("failed"))
                return LogLevel.Error;

            if (messageLower.Contains("warning") || messageLower.Contains("warn") || messageLower.Contains("slow"))
                return LogLevel.Warning;

            if (messageLower.Contains("debug"))
                return LogLevel.Debug;

            // Default to Information
            return LogLevel.Information;
        }

        private LogLevel ParseLogLevel(string levelStr)
        {
            return levelStr.ToUpperInvariant() switch
            {
                "DBG" or "DEB" or "DEBUG" => LogLevel.Debug,
                "INF" or "INFO" or "INFORMATION" => LogLevel.Information,
                "WRN" or "WARN" or "WARNING" => LogLevel.Warning,
                "ERR" or "ERROR" => LogLevel.Error,
                "CRT" or "CRIT" or "CRITICAL" or "FTL" or "FATAL" => LogLevel.Critical,
                _ => LogLevel.Information  // Default to Information instead of failing
            };
        }

        private void ClearLogs()
        {
            LogEntries.Clear();
            CombinedLogEntries.Clear();
            FilteredCombinedEntries.Clear();
            CorrelationGroups.Clear();
            TotalLineCount = 0;
            _filePositions.Clear();
        }

        private async Task ExportLogsAsync()
        {
            try
            {
                // Create export dialog
                var dialog = new Microsoft.Win32.SaveFileDialog
                {
                    Filter = "Log files (*.log)|*.log|Text files (*.txt)|*.txt|All files (*.*)|*.*",
                    DefaultExt = ".log",
                    FileName = $"CamBridge_Export_{DateTime.Now:yyyyMMdd_HHmmss}.log"
                };

                if (dialog.ShowDialog() == true)
                {
                    var sb = new StringBuilder();

                    if (IsTreeViewEnabled)
                    {
                        // Export tree structure
                        foreach (var group in CorrelationGroups)
                        {
                            sb.AppendLine($"=== Correlation: {group.CorrelationId} ===");
                            sb.AppendLine($"Pipeline: {group.Pipeline}");
                            sb.AppendLine($"Duration: {group.DurationText}");
                            sb.AppendLine($"Status: {group.Status}");
                            sb.AppendLine();

                            foreach (var stage in group.Stages)
                            {
                                sb.AppendLine($"  Stage: {stage.Stage} [{stage.DurationText}]");
                                foreach (var entry in stage.Entries)
                                {
                                    sb.AppendLine($"    {entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                                }
                                sb.AppendLine();
                            }

                            if (group.UngroupedEntries.Any())
                            {
                                sb.AppendLine("  [Ungrouped Entries]");
                                foreach (var entry in group.UngroupedEntries)
                                {
                                    sb.AppendLine($"    {entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                                }
                                sb.AppendLine();
                            }

                            sb.AppendLine(new string('=', 50));
                            sb.AppendLine();
                        }
                    }
                    else
                    {
                        // Export flat list
                        var lines = FilteredCombinedEntries.Select(e => e.RawLine ??
                            $"{e.Timestamp:yyyy-MM-dd HH:mm:ss.fff} {e.LevelText} [{e.CorrelationId}] [{e.Stage}] {e.Message}");
                        foreach (var line in lines)
                        {
                            sb.AppendLine(line);
                        }
                    }

                    await File.WriteAllTextAsync(dialog.FileName, sb.ToString(), Encoding.UTF8);

                    _logger.LogInformation("Exported {Count} log entries to {FileName}",
                        IsTreeViewEnabled ? CorrelationGroups.Sum(g => g.TotalEntries) : FilteredCombinedEntries.Count,
                        dialog.FileName);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to export logs");
            }
        }

        private string GetLogFileName(string pipelineSelection)
        {
            var today = DateTime.Now.ToString("yyyyMMdd");

            if (pipelineSelection == "Service (Global)")
            {
                return $"service_{today}.log";
            }

            if (pipelineSelection == "All Pipelines (Legacy)")
            {
                return $"pipelines_{today}.log";
            }

            // Get sanitized name from mapping
            if (_pipelineNameMapping.TryGetValue(pipelineSelection, out var sanitizedName))
            {
                return $"pipeline_{sanitizedName}_{today}.log";
            }

            // Fallback - sanitize the selection directly
            var safeName = SanitizeForFileName(pipelineSelection.Replace(" (Archived)", ""));
            return $"pipeline_{safeName}_{today}.log";
        }

        private string SanitizeForFileName(string pipelineName)
        {
            // Replace invalid filename characters and common separators
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(new[] { ' ', '.', ',', '/', '\\', ':', '-' })
                .Distinct()
                .ToArray();

            var sanitized = string.Join("_", pipelineName.Split(invalid, StringSplitOptions.RemoveEmptyEntries));

            // Limit length
            if (sanitized.Length > 100)
            {
                sanitized = sanitized.Substring(0, 97) + "...";
            }

            return sanitized;
        }

        private void OnRefreshTimer(object? state)
        {
            if (IsAutoScrollEnabled && !IsLoading)
            {
                _ = RefreshLogsAsync();
            }
        }

        private void OnPipelineSelectionChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(PipelineSelection.IsSelected))
            {
                // Update count
                OnPropertyChanged(nameof(SelectedPipelineCount));

                // Update current files display - show selection count when closed
                var selectedNames = PipelineSelections.Where(p => p.IsSelected).Select(p => p.Name).ToList();
                if (selectedNames.Count == 0)
                {
                    CurrentLogFiles = "No pipelines selected";
                }
                else if (selectedNames.Count == 1)
                {
                    CurrentLogFiles = selectedNames[0];
                }
                else
                {
                    CurrentLogFiles = $"{selectedNames.Count} pipelines selected";
                }

                // Refresh logs with new selection
                _ = RefreshLogsAsync();
            }
        }

        partial void OnSearchTextChanged(string? value)
        {
            // Debounce search to avoid too many updates
            ApplyFilters();
        }

        partial void OnShowDebugChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowInformationChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowWarningChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowErrorChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowCriticalChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnIsTreeViewEnabledChanged(bool value)
        {
            ApplyFilters();
        }

        partial void OnFilter1Changed(string value)
        {
            ApplyFilters();
        }

        partial void OnFilter2Changed(string value)
        {
            ApplyFilters();
        }

        partial void OnFilter3Changed(string value)
        {
            ApplyFilters();
        }
    }

    /// <summary>
    /// Enhanced log entry with correlation support
    /// </summary>
    public class LogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogLevel Level { get; set; }
        public string Message { get; set; } = string.Empty;
        public string? RawLine { get; set; }
        public string Source { get; set; } = string.Empty; // Which log file this came from

        // Enhanced properties for correlation
        public string? CorrelationId { get; set; }
        public ProcessingStage? Stage { get; set; }
        public string? Pipeline { get; set; }
        public int? DurationMs { get; set; }

        // UI Helper Properties
        public string LevelText => Level switch
        {
            LogLevel.Debug => "DBG",
            LogLevel.Information => "INF",
            LogLevel.Warning => "WRN",
            LogLevel.Error => "ERR",
            LogLevel.Critical => "CRT",
            _ => "???"
        };

        public string LevelColor => Level switch
        {
            LogLevel.Debug => "#808080",      // Gray
            LogLevel.Information => "#0078D4", // Blue
            LogLevel.Warning => "#FFA500",     // Orange
            LogLevel.Error => "#FF0000",       // Red
            LogLevel.Critical => "#8B0000",    // Dark Red
            _ => "#000000"
        };

        // FIXED emoji icons for UTF-8!
        public string StageIcon => Stage switch
        {
            ProcessingStage.ServiceStartup => "ðŸš€",
            ProcessingStage.ConfigurationLoading => "âš™ï¸",
            ProcessingStage.PipelineInitialization => "ðŸ”§",
            ProcessingStage.ServiceShutdown => "ðŸ›‘",
            ProcessingStage.FileDetected => "ðŸ“„",
            ProcessingStage.ExifExtraction => "ðŸ“·",
            ProcessingStage.TagMapping => "ðŸ”„",
            ProcessingStage.DicomConversion => "ðŸ¥",
            ProcessingStage.PostProcessing => "ðŸ“‹",
            ProcessingStage.PacsUpload => "â˜ï¸",
            ProcessingStage.Complete => "âœ…",
            ProcessingStage.Error => "âŒ",
            ProcessingStage.PipelineShutdown => "ðŸ”´",
            ProcessingStage.PipelineRecovery => "ðŸ”§",
            ProcessingStage.WatcherError => "ðŸ‘ï¸",
            ProcessingStage.HealthCheck => "ðŸ’š",
            _ => "ðŸ“Œ"
        };

        public string FormattedDuration => DurationMs.HasValue ? $"{DurationMs}ms" : "";
    }

    /// <summary>
    /// Represents a group of log entries with the same correlation ID
    /// </summary>
    public class CorrelationGroup : ObservableObject
    {
        private bool _isExpanded;

        public string CorrelationId { get; set; } = string.Empty;
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public string Pipeline { get; set; } = string.Empty;
        public ProcessingStatus Status { get; set; }
        public ObservableCollection<StageGroup> Stages { get; } = new();
        public ObservableCollection<LogEntry> UngroupedEntries { get; } = new();

        public bool IsExpanded
        {
            get => _isExpanded;
            set => SetProperty(ref _isExpanded, value);
        }

        public TimeSpan Duration => EndTime - StartTime;
        public string DurationText => $"{Duration.TotalMilliseconds:0}ms";
        public int TotalEntries => Stages.Sum(s => s.Entries.Count) + UngroupedEntries.Count;

        // FIXED emoji icons!
        public string StatusIcon => Status switch
        {
            ProcessingStatus.Completed => "âœ…",
            ProcessingStatus.Failed => "âŒ",
            ProcessingStatus.InProgress => "â³",
            _ => "â“"
        };

        public string StatusColor => Status switch
        {
            ProcessingStatus.Completed => "#4CAF50",
            ProcessingStatus.Failed => "#F44336",
            ProcessingStatus.InProgress => "#FFA500",
            _ => "#808080"
        };
    }

    /// <summary>
    /// Represents a group of log entries for a specific processing stage
    /// </summary>
    public class StageGroup : ObservableObject
    {
        private bool _isExpanded;

        public ProcessingStage Stage { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public ObservableCollection<LogEntry> Entries { get; } = new();

        public bool IsExpanded
        {
            get => _isExpanded;
            set => SetProperty(ref _isExpanded, value);
        }

        public TimeSpan Duration => EndTime - StartTime;
        public string DurationText => $"{Duration.TotalMilliseconds:0}ms";

        public string StageIcon => Entries.FirstOrDefault()?.StageIcon ?? "ðŸ“Œ";
    }

    /// <summary>
    /// Processing status for correlation groups
    /// </summary>
    public enum ProcessingStatus
    {
        Unknown,
        InProgress,
        Completed,
        Failed
    }
}

// src/CamBridge.Config/Converters/ValueConverters.cs
// Version: 0.8.5
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Media;
using CamBridge.Config.ViewModels;
using CamBridge.Core;

namespace CamBridge.Config.Converters
{
    /// <summary>
    /// Converts IsExpanded boolean to expand/collapse icon
    /// </summary>
    public class ExpandIconConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isExpanded)
            {
                return isExpanded ? "â–¼" : "â–¶";
            }
            return "â–¶";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts integer to Visibility based on comparison with parameter
    /// NEW in v0.7.28 for LogViewerPage
    /// </summary>
    public class IntToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            int intValue = 0;
            int compareValue = 0;

            // Convert value
            if (value != null)
            {
                try
                {
                    intValue = System.Convert.ToInt32(value);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Convert parameter
            if (parameter != null)
            {
                try
                {
                    compareValue = System.Convert.ToInt32(parameter);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Show when value equals compareValue
            return intValue == compareValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean values to Visibility
    /// </summary>
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = value is bool b && b;
            bool invert = parameter as string == "Inverse";

            if (invert)
                return boolValue ? Visibility.Collapsed : Visibility.Visible;
            else
                return boolValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Inverts boolean to visibility conversion
    /// </summary>
    public class InverseBooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = value is bool b && b;
            return boolValue ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts numeric values greater than zero to true
    /// </summary>
    public class GreaterThanZeroConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null) return false;

            try
            {
                double numValue = System.Convert.ToDouble(value);
                return numValue > 0;
            }
            catch
            {
                return false;
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts null values to Visibility
    /// </summary>
    public class NullToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool isNull = value == null;
            bool invert = parameter as string == "Inverse";

            if (invert)
                return isNull ? Visibility.Visible : Visibility.Collapsed;
            else
                return isNull ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts zero values to Visibility
    /// </summary>
    public class ZeroToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool isZero = false;

            if (value != null)
            {
                try
                {
                    double numValue = System.Convert.ToDouble(value);
                    isZero = Math.Abs(numValue) < 0.0001; // Floating point comparison
                }
                catch
                {
                    // If conversion fails, treat as non-zero
                }
            }

            bool invert = parameter as string == "Inverse";

            if (invert)
                return isZero ? Visibility.Collapsed : Visibility.Visible;
            else
                return isZero ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts error count to color brush
    /// </summary>
    public class ErrorCountToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            int errorCount = 0;

            if (value != null)
            {
                try
                {
                    errorCount = System.Convert.ToInt32(value);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Return red color if errors exist, otherwise default
            if (errorCount > 0)
            {
                return new SolidColorBrush(Color.FromRgb(255, 107, 107)); // Light red
            }

            return DependencyProperty.UnsetValue; // Use default style
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean values to inverse boolean
    /// </summary>
    public class InverseBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return !(value is bool b && b);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return !(value is bool b && b);
        }
    }

    /// <summary>
    /// Converts empty string to visibility
    /// </summary>
    public class EmptyStringToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            string? str = value as string;
            bool isEmpty = string.IsNullOrWhiteSpace(str);
            bool invert = parameter as string == "Inverse";

            if (invert)
                return isEmpty ? Visibility.Visible : Visibility.Collapsed;
            else
                return isEmpty ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts service status to color
    /// UPDATED in v0.8.5 for proper status colors (Session 95)
    /// FIXED: Added "online" and "offline" mappings
    /// </summary>
    public class ServiceStatusToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            string status = value as string ?? "";

            return status.ToLower() switch
            {
                "running" => new SolidColorBrush(Color.FromRgb(76, 175, 80)),      // Green #4CAF50
                "online" => new SolidColorBrush(Color.FromRgb(76, 175, 80)),       // Green #4CAF50 (same as running)
                "stopped" => new SolidColorBrush(Color.FromRgb(255, 193, 7)),      // Yellow #FFC107 (was Red)
                "offline" => new SolidColorBrush(Color.FromRgb(255, 193, 7)),      // Yellow #FFC107 (same as stopped)
                "paused" => new SolidColorBrush(Color.FromRgb(255, 152, 0)),       // Orange #FF9800
                "startpending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)), // Orange #FF9800
                "stoppending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)),  // Orange #FF9800
                "continuepending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)), // Orange
                "pausepending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)),    // Orange
                "error" => new SolidColorBrush(Color.FromRgb(244, 67, 54)),        // Red #F44336
                "notinstalled" => new SolidColorBrush(Color.FromRgb(244, 67, 54)), // Red #F44336
                _ => new SolidColorBrush(Color.FromRgb(158, 158, 158))             // Gray #9E9E9E
            };
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts seconds to milliseconds
    /// </summary>
    public class SecondsToMillisecondsConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double seconds)
                return seconds * 1000;
            if (value is int intSeconds)
                return intSeconds * 1000;
            return 0;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double milliseconds)
                return milliseconds / 1000;
            if (value is int intMilliseconds)
                return intMilliseconds / 1000;
            return 0;
        }
    }

    /// <summary>
    /// Converts enum value to boolean based on parameter
    /// </summary>
    public class EnumToBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null || parameter == null)
                return false;

            string enumValue = value.ToString();
            string targetValue = parameter.ToString();

            return enumValue.Equals(targetValue, StringComparison.InvariantCultureIgnoreCase);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isChecked && isChecked)
            {
                if (parameter != null && targetType.IsEnum)
                {
                    return Enum.Parse(targetType, parameter.ToString());
                }
            }

            return Binding.DoNothing;
        }
    }

    /// <summary>
    /// Converter for file selection dialogs
    /// </summary>
    public class FileSelectConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // Simply pass through the value
            return value;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // Simply pass through the value
            return value;
        }
    }

    /// <summary>
    /// Multi-value boolean OR converter
    /// </summary>
    public class MultiBooleanOrConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length == 0)
                return false;

            foreach (var value in values)
            {
                if (value is bool b && b)
                    return true;
            }

            return false;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts enum types to collection for ComboBox binding
    /// </summary>
    public class EnumToCollectionConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return Enum.GetValues(parameter as Type ?? value?.GetType() ?? typeof(object));
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts file size to human-readable format
    /// </summary>
    public class FileSizeConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null) return "0 B";

            long bytes = System.Convert.ToInt64(value);
            string[] sizes = { "B", "KB", "MB", "GB", "TB" };
            int order = 0;
            double size = bytes;

            while (size >= 1024 && order < sizes.Length - 1)
            {
                order++;
                size /= 1024;
            }

            return $"{size:0.##} {sizes[order]}";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts TimeSpan to readable string
    /// </summary>
    public class TimeSpanToStringConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is TimeSpan timeSpan)
            {
                if (timeSpan.TotalDays >= 1)
                    return $"{(int)timeSpan.TotalDays}d {timeSpan.Hours}h {timeSpan.Minutes}m";
                else if (timeSpan.TotalHours >= 1)
                    return $"{(int)timeSpan.TotalHours}h {timeSpan.Minutes}m";
                else
                    return $"{timeSpan.Minutes}m {timeSpan.Seconds}s";
            }
            return "0s";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Multi-value boolean AND converter
    /// </summary>
    public class MultiBooleanAndConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length == 0)
                return false;

            foreach (var value in values)
            {
                if (!(value is bool b) || !b)
                    return false;
            }

            return true;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Null and boolean AND converter
    /// </summary>
    public class NullBooleanAndConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length < 2)
                return false;

            // First value should not be null, second should be true
            return values[0] != null && values[1] is bool b && b;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean to color (Green for true, Red for false)
    /// NEW in v0.7.21 for Dashboard minimal
    /// </summary>
    public class BoolToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isTrue)
            {
                return new SolidColorBrush(isTrue ? Colors.Green : Colors.Red);
            }
            return new SolidColorBrush(Colors.Gray);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts Transform enum to a visual symbol for display
    /// NEW in v0.7.25 for Mapping Editor Redesign
    /// </summary>
    public class TransformToSymbolConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is ValueTransform transform)
            {
                return transform switch
                {
                    ValueTransform.None => "â†’",
                    ValueTransform.DateToDicom => "ðŸ“…â†’",
                    ValueTransform.TimeToDicom => "â°â†’",
                    ValueTransform.DateTimeToDicom => "ðŸ“…â°â†’",
                    ValueTransform.MapGender => "â™‚â™€â†’",
                    ValueTransform.RemovePrefix => "âœ‚â†’",
                    ValueTransform.ExtractDate => "ðŸ“…â†",
                    ValueTransform.ExtractTime => "â°â†",
                    ValueTransform.ToUpperCase => "Aâ†’",
                    ValueTransform.ToLowerCase => "aâ†’",
                    ValueTransform.Trim => "âŽµâ†’",
                    _ => "â†’"
                };
            }
            return "â†’";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts Transform enum to a descriptive text
    /// NEW in v0.7.25 for Mapping Editor Redesign
    /// </summary>
    public class TransformToDescriptionConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is ValueTransform transform)
            {
                return transform switch
                {
                    ValueTransform.None => "Direct mapping",
                    ValueTransform.DateToDicom => "Convert date to DICOM format (YYYYMMDD)",
                    ValueTransform.TimeToDicom => "Convert time to DICOM format (HHMMSS)",
                    ValueTransform.DateTimeToDicom => "Convert datetime to DICOM format",
                    ValueTransform.MapGender => "Map gender values (M/F/O)",
                    ValueTransform.RemovePrefix => "Remove prefix from value",
                    ValueTransform.ExtractDate => "Extract date from datetime",
                    ValueTransform.ExtractTime => "Extract time from datetime",
                    ValueTransform.ToUpperCase => "Convert to uppercase",
                    ValueTransform.ToLowerCase => "Convert to lowercase",
                    ValueTransform.Trim => "Remove leading/trailing spaces",
                    _ => "Unknown transformation"
                };
            }
            return "No transformation";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Combines stage entries and ungrouped entries into a flat list for compact tree view
    /// </summary>
    public class CombineStagesConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values.Length != 2) return null;

            var stages = values[0] as ObservableCollection<StageGroup>;
            var ungrouped = values[1] as ObservableCollection<LogEntry>;

            var combined = new List<LogEntry>();

            // Add all entries from stages (flattened)
            if (stages != null)
            {
                foreach (var stage in stages.OrderBy(s => s.StartTime))
                {
                    combined.AddRange(stage.Entries);
                }
            }

            // Add ungrouped entries
            if (ungrouped != null)
            {
                combined.AddRange(ungrouped);
            }

            // Sort by timestamp
            return combined.OrderBy(e => e.Timestamp).ToList();
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts color string to SolidColorBrush with opacity
    /// </summary>
    public class ColorToBrushConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is string colorString)
            {
                try
                {
                    var color = (Color)ColorConverter.ConvertFromString(colorString);
                    // Add slight transparency for background
                    color.A = 30; // Very light background
                    return new SolidColorBrush(color);
                }
                catch
                {
                    return Brushes.Transparent;
                }
            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}

// src/CamBridge.Infrastructure/Services/DicomConverter.cs
// Version: 0.8.11
// Description: DICOM conversion service with enhanced error handling and user-friendly messages
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Entities;
using CamBridge.Core.Interfaces;
using FellowOakDicom;
using FellowOakDicom.Imaging;
using FellowOakDicom.IO.Buffer;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Service responsible for converting JPEG images to DICOM format
    /// </summary>
    public class DicomConverter
    {
        private readonly ILogger<DicomConverter> _logger;
        private readonly IDicomTagMapper? _tagMapper;
        private readonly IMappingConfiguration? _mappingConfiguration;
        private readonly DicomSettings _dicomSettings;

        /// <summary>
        /// Creates a DicomConverter with optional tag mapping support
        /// </summary>
        public DicomConverter(
            ILogger<DicomConverter> logger,
            IDicomTagMapper? tagMapper = null,
            IMappingConfiguration? mappingConfiguration = null)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _tagMapper = tagMapper;
            _mappingConfiguration = mappingConfiguration;

            // Default DICOM settings if not injected
            _dicomSettings = new DicomSettings
            {
                InstitutionName = "CamBridge Medical Imaging",
                InstitutionDepartment = "Radiology",
                StationName = "CAMBRIDGE01",
                SourceApplicationEntityTitle = "CAMBRIDGE",
                ImplementationVersionName = "CAMBRIDGE_0.8.11",
                ImplementationClassUid = "1.2.276.0.7230010.3.0.3.8.11",
                Modality = "XC",
                ValidateAfterCreation = true
            };
        }

        /// <summary>
        /// Creates a DicomConverter with specific DICOM settings
        /// </summary>
        public DicomConverter(
            ILogger<DicomConverter> logger,
            DicomSettings dicomSettings,
            IDicomTagMapper? tagMapper = null,
            IMappingConfiguration? mappingConfiguration = null)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _dicomSettings = dicomSettings ?? throw new ArgumentNullException(nameof(dicomSettings));
            _tagMapper = tagMapper;
            _mappingConfiguration = mappingConfiguration;
        }

        /// <summary>
        /// Converts a JPEG file to DICOM format
        /// </summary>
        public async Task<ConversionResult> ConvertToDicomAsync(
            string sourceJpegPath,
            string outputDicomPath,
            ImageMetadata metadata,
            string? correlationId = null)
        {
            if (string.IsNullOrWhiteSpace(sourceJpegPath))
                throw new ArgumentException("Source JPEG path cannot be empty", nameof(sourceJpegPath));

            if (string.IsNullOrWhiteSpace(outputDicomPath))
                throw new ArgumentException("Output DICOM path cannot be empty", nameof(outputDicomPath));

            if (metadata == null)
                throw new ArgumentNullException(nameof(metadata));

            _logger.LogInformation("[{CorrelationId}] [DicomConversion] Starting JPEG to DICOM conversion: {Source} -> {Target}",
                correlationId ?? "NO-ID", Path.GetFileName(sourceJpegPath), Path.GetFileName(outputDicomPath));

            var stopwatch = Stopwatch.StartNew();

            try
            {
                // Validate source file exists
                if (!File.Exists(sourceJpegPath))
                {
                    throw new FileNotFoundException($"Source JPEG file not found: {sourceJpegPath}");
                }

                // Ensure output directory exists
                var outputDir = Path.GetDirectoryName(outputDicomPath);
                if (!string.IsNullOrEmpty(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }

                // Create DICOM dataset with JPEG transfer syntax
                var dicomFile = new DicomFile();
                var dataset = new DicomDataset(DicomTransferSyntax.JPEGProcess1);

                // Add required DICOM tags
                AddRequiredDicomTags(dataset, metadata);

                // Apply custom mappings if available
                if (_tagMapper != null && _mappingConfiguration != null)
                {
                    try
                    {
                        _logger.LogDebug("[{CorrelationId}] [DicomConversion] Applying custom tag mappings",
                            correlationId ?? "NO-ID");

                        // Convert metadata to dictionary for mapping
                        var sourceData = CreateSourceDataDictionary(metadata);
                        var mappingRules = _mappingConfiguration.GetMappingRules();

                        // FIXED: Pass correlationId to mapper!
                        if (_tagMapper is DicomTagMapper mapper)
                        {
                            // Use the overloaded method with correlationId
                            mapper.MapToDataset(dataset, sourceData, mappingRules, correlationId);
                        }
                        else
                        {
                            // Fallback to interface method without correlationId
                            _tagMapper.MapToDataset(dataset, sourceData, mappingRules);
                        }

                        _logger.LogDebug("[{CorrelationId}] [DicomConversion] Applied {Count} mapping rules",
                            correlationId ?? "NO-ID", mappingRules.Count());
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, "[{CorrelationId}] [DicomConversion] Failed to apply custom mappings, continuing with default tags",
                            correlationId ?? "NO-ID");
                        // Continue with default tags only
                    }
                }

                // Load JPEG and add as pixel data
                await AddJpegAsPixelDataAsync(dataset, sourceJpegPath);

                // Set file meta info
                dicomFile.FileMetaInfo.TransferSyntax = DicomTransferSyntax.JPEGProcess1;
                dicomFile.FileMetaInfo.MediaStorageSOPClassUID = DicomUID.SecondaryCaptureImageStorage;
                dicomFile.FileMetaInfo.MediaStorageSOPInstanceUID = dataset.GetSingleValue<DicomUID>(DicomTag.SOPInstanceUID);
                dicomFile.FileMetaInfo.ImplementationClassUID = DicomUID.Parse(_dicomSettings.ImplementationClassUid);
                dicomFile.FileMetaInfo.ImplementationVersionName = _dicomSettings.ImplementationVersionName;

                // Add dataset to file
                dicomFile.Dataset.AddOrUpdate(dataset);

                // Validate if configured
                if (_dicomSettings.ValidateAfterCreation)
                {
                    var validationResult = ValidateDicomFile(dicomFile);
                    if (!validationResult.IsValid)
                    {
                        _logger.LogWarning("[{CorrelationId}] [DicomConversion] DICOM validation warnings: {Warnings}",
                            correlationId ?? "NO-ID", string.Join(", ", validationResult.Warnings));
                    }
                }

                // Save DICOM file
                await dicomFile.SaveAsync(outputDicomPath);

                stopwatch.Stop();

                var fileInfo = new FileInfo(outputDicomPath);
                _logger.LogInformation("[{CorrelationId}] [DicomConversion] DICOM conversion successful in {ElapsedMs}ms, output size: {FileSize} bytes",
                    correlationId ?? "NO-ID", stopwatch.ElapsedMilliseconds, fileInfo.Length);

                return new ConversionResult
                {
                    Success = true,
                    DicomFilePath = outputDicomPath,
                    FileSizeBytes = fileInfo.Length,
                    ProcessingTime = stopwatch.Elapsed
                };
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                _logger.LogError(ex, "[{CorrelationId}] [DicomConversion] DICOM conversion failed after {ElapsedMs}ms",
                    correlationId ?? "NO-ID", stopwatch.ElapsedMilliseconds);

                return new ConversionResult
                {
                    Success = false,
                    ErrorMessage = ex.Message,
                    ProcessingTime = stopwatch.Elapsed
                };
            }
        }

        /// <summary>
        /// Adds required DICOM tags to the dataset
        /// </summary>
        private void AddRequiredDicomTags(DicomDataset dataset, ImageMetadata metadata)
        {
            // Patient Module
            if (metadata.Patient != null)
            {
                dataset.Add(DicomTag.PatientName, metadata.Patient.PatientName);
                dataset.Add(DicomTag.PatientID, metadata.Patient.PatientId.ToString());

                if (metadata.Patient.BirthDate.HasValue)
                {
                    dataset.Add(DicomTag.PatientBirthDate, metadata.Patient.BirthDate.Value);
                }

                dataset.Add(DicomTag.PatientSex, metadata.Patient.Gender.ToString().Substring(0, 1).ToUpperInvariant());
            }

            // Study Module
            if (metadata.Study != null)
            {
                dataset.Add(DicomTag.StudyInstanceUID, DicomUID.Generate());
                dataset.Add(DicomTag.StudyID, metadata.Study.StudyId.ToString());
                dataset.Add(DicomTag.StudyDate, metadata.Study.StudyDate);
                dataset.Add(DicomTag.StudyTime, metadata.Study.StudyDate);
                dataset.Add(DicomTag.StudyDescription, metadata.Study.Description ?? string.Empty);
                dataset.Add(DicomTag.AccessionNumber, metadata.Study.AccessionNumber ?? string.Empty);
                dataset.Add(DicomTag.ReferringPhysicianName, metadata.Study.ReferringPhysician ?? string.Empty);
            }

            // Series Module
            dataset.Add(DicomTag.SeriesInstanceUID, DicomUID.Generate());
            dataset.Add(DicomTag.SeriesNumber, "1");
            dataset.Add(DicomTag.Modality, _dicomSettings.Modality);
            dataset.Add(DicomTag.SeriesDescription, "CamBridge JPEG to DICOM Conversion");

            // General Image Module
            dataset.Add(DicomTag.InstanceNumber, metadata.InstanceNumber.ToString());
            dataset.Add(DicomTag.ContentDate, metadata.CaptureDateTime);
            dataset.Add(DicomTag.ContentTime, metadata.CaptureDateTime);
            dataset.Add(DicomTag.AcquisitionDateTime, metadata.CaptureDateTime);

            // SOP Common Module
            dataset.Add(DicomTag.SOPClassUID, DicomUID.SecondaryCaptureImageStorage);
            dataset.Add(DicomTag.SOPInstanceUID, string.IsNullOrEmpty(metadata.InstanceUid) ? DicomUID.Generate() : DicomUID.Parse(metadata.InstanceUid));

            // Equipment Module
            dataset.Add(DicomTag.Manufacturer, metadata.TechnicalData?.Manufacturer ?? "Unknown");
            dataset.Add(DicomTag.ManufacturerModelName, metadata.TechnicalData?.Model ?? "Unknown");
            dataset.Add(DicomTag.StationName, _dicomSettings.StationName);
            dataset.Add(DicomTag.InstitutionName, _dicomSettings.InstitutionName);
            dataset.Add(DicomTag.InstitutionalDepartmentName, _dicomSettings.InstitutionDepartment);

            // SC Equipment Module
            dataset.Add(DicomTag.ConversionType, "WSD"); // Workstation
            dataset.Add(DicomTag.SecondaryCaptureDeviceManufacturer, "Claude's Improbably Reliable Software Solutions");
            dataset.Add(DicomTag.SecondaryCaptureDeviceManufacturerModelName, "CamBridge");
            dataset.Add(DicomTag.SecondaryCaptureDeviceSoftwareVersions, _dicomSettings.ImplementationVersionName);

            // Image Pixel Module
            dataset.Add(DicomTag.SamplesPerPixel, (ushort)3);
            dataset.Add(DicomTag.PhotometricInterpretation, PhotometricInterpretation.Rgb.Value);
            dataset.Add(DicomTag.PlanarConfiguration, (ushort)0);

            // FIXED: Add barcode data as private tag with proper VR
            if (!string.IsNullOrEmpty(metadata.BarcodeData))
            {
                // Add Private Creator first (group 0x0009, element 0x0010)
                dataset.Add(new DicomTag(0x0009, 0x0010), "CAMBRIDGE");

                // Add the private tag with data - fo-dicom will determine VR
                dataset.Add(new DicomTag(0x0009, 0x1001), metadata.BarcodeData);

                _logger.LogDebug("[DicomConversion] Added private tag for barcode data: {BarcodeData}", metadata.BarcodeData);
            }
        }

        /// <summary>
        /// Creates a dictionary from metadata for tag mapping
        /// </summary>
        private Dictionary<string, string> CreateSourceDataDictionary(ImageMetadata metadata)
        {
            var data = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            // Patient data
            if (metadata.Patient != null)
            {
                data["PatientName"] = metadata.Patient.PatientName;
                data["PatientID"] = metadata.Patient.PatientId.ToString();
                data["PatientBirthDate"] = metadata.Patient.BirthDate?.ToString("yyyyMMdd") ?? "";
                data["PatientSex"] = metadata.Patient.Gender.ToString().Substring(0, 1).ToUpperInvariant();
            }

            // Study data
            if (metadata.Study != null)
            {
                data["StudyID"] = metadata.Study.StudyId.ToString();
                data["StudyDescription"] = metadata.Study.Description ?? "";
                data["StudyDate"] = metadata.Study.StudyDate.ToString("yyyyMMdd");
                data["StudyTime"] = metadata.Study.StudyDate.ToString("HHmmss");
                data["AccessionNumber"] = metadata.Study.AccessionNumber ?? "";
                data["ReferringPhysicianName"] = metadata.Study.ReferringPhysician ?? "";
                data["ExamId"] = metadata.Study.ExamId ?? "";
            }

            // Technical data
            if (metadata.TechnicalData != null)
            {
                data["Manufacturer"] = metadata.TechnicalData.Manufacturer ?? "";
                data["ManufacturerModelName"] = metadata.TechnicalData.Model ?? "";
                data["ImageWidth"] = metadata.TechnicalData.ImageWidth.ToString();
                data["ImageHeight"] = metadata.TechnicalData.ImageHeight.ToString();
            }

            // General data
            data["CaptureDateTime"] = metadata.CaptureDateTime.ToString("yyyyMMddHHmmss");
            data["CaptureDate"] = metadata.CaptureDateTime.ToString("yyyyMMdd");
            data["CaptureTime"] = metadata.CaptureDateTime.ToString("HHmmss");
            data["InstanceNumber"] = metadata.InstanceNumber.ToString();
            data["SourceFilePath"] = metadata.SourceFilePath;
            data["BarcodeData"] = metadata.BarcodeData ?? "";
            data["UserComment"] = metadata.UserComment ?? "";

            // Add all EXIF data
            foreach (var kvp in metadata.ExifData)
            {
                // Avoid overwriting existing keys
                if (!data.ContainsKey(kvp.Key))
                {
                    data[kvp.Key] = kvp.Value;
                }
            }

            return data;
        }

        /// <summary>
        /// Adds JPEG image as pixel data to DICOM dataset
        /// </summary>
        private async Task AddJpegAsPixelDataAsync(DicomDataset dataset, string jpegPath)
        {
            // Read JPEG file
            var jpegBytes = await File.ReadAllBytesAsync(jpegPath);

            // Get image dimensions from JPEG
            // For JPEG, we can read the dimensions from the JPEG header
            // This is a simplified approach - in production you might use a library
            var (width, height) = GetJpegDimensions(jpegBytes);

            // Add image dimensions
            dataset.Add(DicomTag.Rows, (ushort)height);
            dataset.Add(DicomTag.Columns, (ushort)width);
            dataset.Add(DicomTag.BitsAllocated, (ushort)8);
            dataset.Add(DicomTag.BitsStored, (ushort)8);
            dataset.Add(DicomTag.HighBit, (ushort)7);
            dataset.Add(DicomTag.PixelRepresentation, (ushort)0);

            // Create pixel data element with JPEG data
            var pixelData = new DicomOtherByteFragment(DicomTag.PixelData);

            // Add offset table (required for encapsulated data)
            pixelData.Fragments.Add(new MemoryByteBuffer(new byte[0]));

            // Add JPEG data as fragment
            pixelData.Fragments.Add(new MemoryByteBuffer(jpegBytes));

            dataset.AddOrUpdate(pixelData);
        }

        /// <summary>
        /// Gets JPEG dimensions by reading the JPEG header
        /// </summary>
        private (int width, int height) GetJpegDimensions(byte[] jpegData)
        {
            // Default dimensions if we can't read them
            int width = 0;
            int height = 0;

            // JPEG starts with FFD8
            if (jpegData.Length < 2 || jpegData[0] != 0xFF || jpegData[1] != 0xD8)
                return (width, height);

            int offset = 2;
            while (offset < jpegData.Length - 9)
            {
                if (jpegData[offset] != 0xFF)
                {
                    offset++;
                    continue;
                }

                byte marker = jpegData[offset + 1];

                // Skip any padding FF bytes
                if (marker == 0xFF)
                {
                    offset++;
                    continue;
                }

                offset += 2;

                // Check for SOF markers (C0-CF, except C4, C8, CC)
                if ((marker >= 0xC0 && marker <= 0xCF) &&
                    marker != 0xC4 && marker != 0xC8 && marker != 0xCC)
                {
                    // Skip length (2 bytes) and precision (1 byte)
                    offset += 3;

                    // Read dimensions
                    height = (jpegData[offset] << 8) | jpegData[offset + 1];
                    width = (jpegData[offset + 2] << 8) | jpegData[offset + 3];
                    break;
                }
                else
                {
                    // Read the length and skip this segment
                    int segmentLength = (jpegData[offset] << 8) | jpegData[offset + 1];
                    offset += segmentLength;
                }
            }

            // Fallback to reasonable defaults if parsing fails
            if (width == 0 || height == 0)
            {
                _logger.LogWarning("Failed to read JPEG dimensions, using defaults");
                width = 1024;
                height = 768;
            }

            return (width, height);
        }

        /// <summary>
        /// Validates DICOM file for common issues
        /// </summary>
        private ValidationResult ValidateDicomFile(DicomFile dicomFile)
        {
            var result = new ValidationResult { IsValid = true };
            var warnings = new List<string>();

            // Check required patient tags
            if (!dicomFile.Dataset.Contains(DicomTag.PatientName))
                warnings.Add("Missing PatientName");

            if (!dicomFile.Dataset.Contains(DicomTag.PatientID))
                warnings.Add("Missing PatientID");

            // Check required study tags
            if (!dicomFile.Dataset.Contains(DicomTag.StudyInstanceUID))
                warnings.Add("Missing StudyInstanceUID");

            // Check image data
            if (!dicomFile.Dataset.Contains(DicomTag.PixelData))
            {
                warnings.Add("Missing PixelData");
                result.IsValid = false;
            }

            // Check transfer syntax
            if (dicomFile.FileMetaInfo.TransferSyntax != DicomTransferSyntax.JPEGProcess1)
            {
                warnings.Add($"Unexpected transfer syntax: {dicomFile.FileMetaInfo.TransferSyntax}");
            }

            result.Warnings = warnings;
            return result;
        }
    }

    /// <summary>
    /// Result of DICOM conversion operation
    /// </summary>
    public class ConversionResult
    {
        public bool Success { get; set; }
        public string? DicomFilePath { get; set; }
        public string? ErrorMessage { get; set; }
        public long FileSizeBytes { get; set; }
        public TimeSpan ProcessingTime { get; set; }
    }

    /// <summary>
    /// Result of DICOM validation
    /// </summary>
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Warnings { get; set; } = new List<string>();
    }
}

