# CamBridge Sources - INFRASTRUCTURE
# Generated: 2025-07-01 14:22:49
# Version: 0.7.11
# Purpose: Complete source code for project knowledge
# Token-efficient access to all implementations


================================================================================
FILE: src\CamBridge.Infrastructure\GlobalUsings.cs
================================================================================

global using System;
global using System.Collections.Generic;
global using System.IO;
global using System.Linq;
global using System.Text;
global using System.Threading.Tasks;
global using Microsoft.Extensions.Logging;


================================================================================
FILE: src\CamBridge.Infrastructure\ServiceCollectionExtensions.cs
================================================================================

// src/CamBridge.Infrastructure/ServiceCollectionExtensions.cs
// Version: 0.8.8
// Description: DI container configuration with FIXED duplicate registration
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure
{
    /// <summary>
    /// Extension methods for service registration
    /// PIPELINE UPDATE: FileProcessor no longer registered as singleton!
    /// </summary>
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Adds infrastructure services to the DI container
        /// </summary>
        public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
        {
            // FIXED: REMOVED duplicate Configure<CamBridgeSettingsV2>!
            // This is already done in Program.cs with validation logic
            // services.Configure<CamBridgeSettingsV2>(configuration.GetSection("CamBridge"));

            // Add other configuration sections (these are fine)
            services.Configure<ProcessingOptions>(configuration.GetSection("CamBridge:DefaultProcessingOptions"));

            // Add notification settings (global)
            services.Configure<NotificationSettings>(configuration.GetSection("CamBridge:Notifications"));

            // Register shared services (used by all pipelines)
            // FIX: ExifToolReader needs the path from configuration!
            services.AddSingleton<ExifToolReader>(sp =>
            {
                var settings = sp.GetRequiredService<IOptionsMonitor<CamBridgeSettingsV2>>().CurrentValue;
                return new ExifToolReader(
                    sp.GetRequiredService<ILogger<ExifToolReader>>(),
                    settings.ExifToolPath ?? "Tools\\exiftool.exe",
                    null  // No correlation ID for global instance
                );
            });

            services.AddSingleton<DicomConverter>();

            // Register DICOM Store Service for PACS upload
            services.AddSingleton<DicomStoreService>();

            // FileProcessor is NO LONGER registered here!
            // It's created per-pipeline in PipelineManager!
            // services.AddSingleton<FileProcessor>(); // REMOVED!

            // Register pipeline manager
            services.AddSingleton<PipelineManager>();

            // Register notification service (v0.7.18: Direct class, no interface!)
            services.AddSingleton<NotificationService>();

            // FIXED: Register MappingConfigurationLoader as both interface AND concrete type
            services.AddSingleton<MappingConfigurationLoader>();
            services.AddSingleton<IMappingConfiguration>(sp => sp.GetRequiredService<MappingConfigurationLoader>());

            // Register remaining interfaces (only 2 left!)
            services.AddSingleton<IDicomTagMapper, DicomTagMapper>();

            return services;
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: src\CamBridge.Infrastructure\obj\Release\net8.0\CamBridge.Infrastructure.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("CamBridge.Infrastructure.Tests")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.10+ee5ebf36a408cf8cb648db40b0c428beb752eef8")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Infrastructure")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Infrastructure\obj\x64\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: src\CamBridge.Infrastructure\obj\x64\Release\net8.0\CamBridge.Infrastructure.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("CamBridge.Infrastructure.Tests")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.10+ee5ebf36a408cf8cb648db40b0c428beb752eef8")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Infrastructure")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Infrastructure\Services\DicomConverter.cs
================================================================================

// src/CamBridge.Infrastructure/Services/DicomConverter.cs
// Version: 0.7.31
// Description: DICOM converter with FIXED property names and JPEG encapsulation
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Runtime.Versioning;
using System.Threading.Tasks;
using CamBridge.Core.Entities;
using CamBridge.Core.Interfaces;
using FellowOakDicom;
using FellowOakDicom.Imaging;
using FellowOakDicom.IO.Buffer;
using Microsoft.Extensions.Logging;
using DicomTag = FellowOakDicom.DicomTag;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// DICOM converter using fo-dicom library
    /// Converts JPEG images to DICOM format while preserving JPEG compression
    /// v0.7.31: FIXED property names and JPEG encapsulation
    /// </summary>
    [SupportedOSPlatform("windows")]
    public class DicomConverter
    {
        private readonly ILogger<DicomConverter> _logger;
        private readonly IDicomTagMapper? _tagMapper;
        private readonly IMappingConfiguration? _mappingConfiguration;

        private const string PHOTOGRAPHIC_SOP_CLASS_UID = "1.2.840.10008.5.1.4.1.1.77.1.4";
        private const string JPEG_BASELINE_TRANSFER_SYNTAX_UID = "1.2.840.10008.1.2.4.50";

        // Implementation Class UID prefix for CamBridge
        private const string IMPLEMENTATION_CLASS_UID = "1.2.276.0.7230010.3.0.3.6.4";
        private const string IMPLEMENTATION_VERSION_NAME = "CAMBRIDGE_001";

        // Constructor for backward compatibility
        public DicomConverter(ILogger<DicomConverter> logger)
            : this(logger, null, null)
        {
        }

        // New constructor with dependency injection
        public DicomConverter(
            ILogger<DicomConverter> logger,
            IDicomTagMapper? tagMapper,
            IMappingConfiguration? mappingConfiguration)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _tagMapper = tagMapper;
            _mappingConfiguration = mappingConfiguration;
        }

        /// <summary>
        /// Converts a JPEG file to DICOM using the provided metadata
        /// </summary>
        public async Task<ConversionResult> ConvertToDicomAsync(
            string sourceJpegPath,
            string destinationDicomPath,
            ImageMetadata metadata)
        {
            try
            {
                _logger.LogInformation("Converting JPEG to DICOM: {Source} â†’ {Destination}",
                    sourceJpegPath, destinationDicomPath);

                // Validate inputs
                if (!File.Exists(sourceJpegPath))
                {
                    return ConversionResult.CreateFailure($"Source file not found: {sourceJpegPath}");
                }

                // Load JPEG data
                var jpegData = await File.ReadAllBytesAsync(sourceJpegPath);

                // Create DICOM dataset with JPEG transfer syntax for proper encapsulation
                var dataset = CreateDicomDataset(metadata, jpegData);

                // Map custom tags if mapper is available
                if (_tagMapper != null && _mappingConfiguration != null)
                {
                    var mappingRules = _mappingConfiguration.GetMappingRules();

                    if (mappingRules.Any())
                    {
                        _tagMapper.MapToDataset(dataset, metadata.ExifData, mappingRules);
                    }
                }

                // Create DICOM file with correct structure
                var dicomFile = new DicomFile(dataset);

                // CRITICAL FIX: Set Transfer Syntax on FileMetaInfo!
                dicomFile.FileMetaInfo.TransferSyntax = DicomTransferSyntax.JPEGProcess1;

                // Also ensure File Meta Information has required tags
                dicomFile.FileMetaInfo.MediaStorageSOPClassUID = dataset.GetSingleValue<DicomUID>(DicomTag.SOPClassUID);
                dicomFile.FileMetaInfo.MediaStorageSOPInstanceUID = dataset.GetSingleValue<DicomUID>(DicomTag.SOPInstanceUID);
                dicomFile.FileMetaInfo.ImplementationClassUID = DicomUID.Parse(IMPLEMENTATION_CLASS_UID);
                dicomFile.FileMetaInfo.ImplementationVersionName = IMPLEMENTATION_VERSION_NAME;

                // Ensure output directory exists
                var outputDir = Path.GetDirectoryName(destinationDicomPath);
                if (!string.IsNullOrEmpty(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }

                // Save DICOM file - fo-dicom should handle undefined length automatically
                // when dataset has JPEG transfer syntax
                await dicomFile.SaveAsync(destinationDicomPath);

                var fileInfo = new FileInfo(destinationDicomPath);
                var sopInstanceUid = dataset.GetSingleValue<string>(DicomTag.SOPInstanceUID);

                _logger.LogInformation("Successfully created DICOM file: {Path} ({Size} bytes, Transfer Syntax: {TransferSyntax})",
                    destinationDicomPath, fileInfo.Length, dicomFile.FileMetaInfo.TransferSyntax.UID.UID);

                return ConversionResult.CreateSuccess(destinationDicomPath, sopInstanceUid, fileInfo.Length);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to convert JPEG to DICOM");
                return ConversionResult.CreateFailure($"Conversion failed: {ex.Message}");
            }
        }

        /// <summary>
        /// Validates if the generated DICOM file is compliant
        /// </summary>
        public async Task<ValidationResult> ValidateDicomFileAsync(string dicomFilePath)
        {
            try
            {
                if (!File.Exists(dicomFilePath))
                {
                    return ValidationResult.Invalid($"DICOM file not found: {dicomFilePath}");
                }

                // Load DICOM file for validation
                var dicomFile = await DicomFile.OpenAsync(dicomFilePath);
                var dataset = dicomFile.Dataset;

                var errors = new List<string>();
                var warnings = new List<string>();

                // Validate required tags
                ValidateRequiredTags(dataset, errors);

                // Validate image module
                ValidateImageModule(dataset, warnings);

                // Validate patient module
                ValidatePatientModule(dataset, warnings);

                // Validate study module
                ValidateStudyModule(dataset, warnings);

                // Check for critical errors
                if (errors.Any())
                {
                    return ValidationResult.Invalid(string.Join("; ", errors));
                }

                // Return valid with warnings if any
                if (warnings.Any())
                {
                    return ValidationResult.ValidWithWarnings(string.Join("; ", warnings));
                }

                return ValidationResult.Valid();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to validate DICOM file: {Path}", dicomFilePath);
                return ValidationResult.Invalid($"Validation error: {ex.Message}");
            }
        }

        private DicomDataset CreateDicomDataset(ImageMetadata metadata, byte[] jpegData)
        {
            // CRITICAL FIX: Create dataset WITH transfer syntax for proper JPEG encapsulation!
            // This ensures fo-dicom uses undefined length for pixel data as required by DICOM standard
            var dataset = new DicomDataset(DicomTransferSyntax.JPEGProcess1);

            // Generate UIDs
            var studyInstanceUid = GenerateUid();
            var seriesInstanceUid = GenerateUid();
            var sopInstanceUid = GenerateUid();

            // SOP Common Module
            dataset.Add(DicomTag.SOPClassUID, PHOTOGRAPHIC_SOP_CLASS_UID);
            dataset.Add(DicomTag.SOPInstanceUID, sopInstanceUid);

            // Study Module - FIXED property names
            dataset.Add(DicomTag.StudyInstanceUID, studyInstanceUid);
            dataset.Add(DicomTag.StudyDate, metadata.Study.StudyDate.ToString("yyyyMMdd"));
            dataset.Add(DicomTag.StudyTime, metadata.Study.StudyDate.ToString("HHmmss.fff"));
            dataset.Add(DicomTag.StudyID, metadata.Study.StudyId.Value ?? "");
            dataset.Add(DicomTag.AccessionNumber, metadata.Study.AccessionNumber ?? "");
            dataset.Add(DicomTag.StudyDescription, metadata.Study.Description ?? "");

            // Series Module
            dataset.Add(DicomTag.SeriesInstanceUID, seriesInstanceUid);
            dataset.Add(DicomTag.SeriesNumber, "1"); // IS expects string!
            dataset.Add(DicomTag.Modality, metadata.Study.Modality ?? "OT"); // Other

            // Patient Module - FIXED property names
            dataset.Add(DicomTag.PatientName, metadata.Patient.Name ?? "");
            dataset.Add(DicomTag.PatientID, metadata.Patient.Id.Value ?? "");
            dataset.Add(DicomTag.PatientBirthDate, metadata.Patient.BirthDate?.ToString("yyyyMMdd") ?? "");
            dataset.Add(DicomTag.PatientSex, MapGenderToString(metadata.Patient.Gender) ?? "");

            // General Image Module
            dataset.Add(DicomTag.InstanceNumber, "1"); // IS expects string!
            dataset.Add(DicomTag.PatientOrientation, "");

            // Image Pixel Module - FIXED: No SamplesPerPixel property
            dataset.Add(DicomTag.SamplesPerPixel, (ushort)3); // Assume RGB JPEG
            dataset.Add(DicomTag.PhotometricInterpretation, "YBR_FULL_422"); // JPEG requires YBR!
            dataset.Add(DicomTag.Rows, (ushort)(metadata.TechnicalData.ImageHeight ?? 0));
            dataset.Add(DicomTag.Columns, (ushort)(metadata.TechnicalData.ImageWidth ?? 0));
            dataset.Add(DicomTag.BitsAllocated, (ushort)8);
            dataset.Add(DicomTag.BitsStored, (ushort)8);
            dataset.Add(DicomTag.HighBit, (ushort)7);
            dataset.Add(DicomTag.PixelRepresentation, (ushort)0);
            dataset.Add(DicomTag.PlanarConfiguration, (ushort)0);

            // Add JPEG data as encapsulated pixel data
            var pixelData = DicomPixelData.Create(dataset, true);
            var buffer = new MemoryByteBuffer(jpegData);
            pixelData.AddFrame(buffer);

            // General Equipment Module - FIXED property names
            dataset.Add(DicomTag.Manufacturer, metadata.TechnicalData.Manufacturer ?? "Unknown");
            dataset.Add(DicomTag.ManufacturerModelName, metadata.TechnicalData.Model ?? "Unknown");
            dataset.Add(DicomTag.SoftwareVersions, metadata.TechnicalData.Software ?? "CamBridge");

            // Add character set for proper encoding (UTF-8)
            dataset.Add(DicomTag.SpecificCharacterSet, "ISO_IR 192");

            return dataset;
        }

        /// <summary>
        /// Generates a DICOM compliant UID with only numeric characters
        /// </summary>
        private string GenerateUid()
        {
            // Use shorter components to ensure we stay under 64 characters
            // Only numeric characters allowed in DICOM UIDs!
            var shortTicks = (DateTime.UtcNow.Ticks % 10000000000).ToString();
            var processId = (Environment.ProcessId % 10000).ToString();
            var random = new Random().Next(1000, 9999);

            var uid = $"{IMPLEMENTATION_CLASS_UID}.{shortTicks}.{processId}.{random}";

            // Ensure UID doesn't exceed 64 characters
            if (uid.Length > 64)
            {
                _logger.LogWarning("Generated UID too long ({Length} chars), truncating: {UID}",
                    uid.Length, uid);
                uid = uid.Substring(0, 64);
            }

            return uid;
        }

        private void ValidateRequiredTags(DicomDataset dataset, List<string> errors)
        {
            // Check for essential tags
            if (!dataset.Contains(DicomTag.SOPClassUID))
                errors.Add("Missing SOP Class UID");

            if (!dataset.Contains(DicomTag.SOPInstanceUID))
                errors.Add("Missing SOP Instance UID");

            if (!dataset.Contains(DicomTag.StudyInstanceUID))
                errors.Add("Missing Study Instance UID");

            if (!dataset.Contains(DicomTag.SeriesInstanceUID))
                errors.Add("Missing Series Instance UID");

            if (!dataset.Contains(DicomTag.Rows) || !dataset.Contains(DicomTag.Columns))
                errors.Add("Missing image dimensions (Rows/Columns)");
        }

        private void ValidateImageModule(DicomDataset dataset, List<string> warnings)
        {
            // Validate pixel data exists
            try
            {
                var pixelData = DicomPixelData.Create(dataset);
                if (pixelData.NumberOfFrames == 0)
                {
                    warnings.Add("No pixel data frames found");
                }
            }
            catch
            {
                warnings.Add("Unable to read pixel data");
            }

            // Check photometric interpretation
            var photometric = dataset.GetSingleValueOrDefault<string>(DicomTag.PhotometricInterpretation, string.Empty);
            if (string.IsNullOrEmpty(photometric))
            {
                warnings.Add("Missing Photometric Interpretation");
            }
        }

        private void ValidatePatientModule(DicomDataset dataset, List<string> warnings)
        {
            if (!dataset.Contains(DicomTag.PatientName) || string.IsNullOrWhiteSpace(dataset.GetSingleValueOrDefault<string>(DicomTag.PatientName, string.Empty)))
                warnings.Add("Missing or empty Patient Name");

            if (!dataset.Contains(DicomTag.PatientID) || string.IsNullOrWhiteSpace(dataset.GetSingleValueOrDefault<string>(DicomTag.PatientID, string.Empty)))
                warnings.Add("Missing or empty Patient ID");
        }

        private void ValidateStudyModule(DicomDataset dataset, List<string> warnings)
        {
            if (!dataset.Contains(DicomTag.StudyDate))
                warnings.Add("Missing Study Date");

            if (!dataset.Contains(DicomTag.StudyTime))
                warnings.Add("Missing Study Time");
        }

        private string MapGenderToString(Gender gender)
        {
            return gender switch
            {
                Gender.Male => "M",
                Gender.Female => "F",
                Gender.Other => "O",
                _ => "O"
            };
        }
    }

    /// <summary>
    /// Result of DICOM conversion operation
    /// </summary>
    public class ConversionResult
    {
        public bool Success { get; init; }
        public string? ErrorMessage { get; init; }
        public string? DicomFilePath { get; init; }
        public string? SopInstanceUid { get; init; }
        public long FileSizeBytes { get; init; }

        public static ConversionResult CreateSuccess(string dicomFilePath, string sopInstanceUid, long fileSizeBytes)
        {
            return new ConversionResult
            {
                Success = true,
                DicomFilePath = dicomFilePath,
                SopInstanceUid = sopInstanceUid,
                FileSizeBytes = fileSizeBytes
            };
        }

        public static ConversionResult CreateFailure(string errorMessage)
        {
            return new ConversionResult
            {
                Success = false,
                ErrorMessage = errorMessage
            };
        }
    }

    /// <summary>
    /// Result of DICOM validation
    /// </summary>
    public class ValidationResult
    {
        public bool IsValid { get; init; }
        public string? Message { get; init; }

        public static ValidationResult Valid() => new() { IsValid = true };
        public static ValidationResult ValidWithWarnings(string warnings) => new() { IsValid = true, Message = warnings };
        public static ValidationResult Invalid(string errors) => new() { IsValid = false, Message = errors };
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\DicomStoreService.cs
================================================================================

// src\CamBridge.Infrastructure\Services\DicomStoreService.cs
// Version: 0.8.3
// Description: DICOM C-STORE service with enhanced error handling and user-friendly messages
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.IO;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.Logging;
using FellowOakDicom;
using FellowOakDicom.Network;
using FellowOakDicom.Network.Client;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Result of DICOM C-STORE operation
    /// </summary>
    public class StoreResult
    {
        public bool Success { get; init; }
        public string? ErrorMessage { get; init; }
        public string? UserFriendlyMessage { get; init; }
        public DateTime Timestamp { get; init; } = DateTime.UtcNow;
        public string? TransactionUid { get; init; }
        public DicomErrorType ErrorType { get; init; } = DicomErrorType.None;

        public static StoreResult CreateSuccess(string transactionUid = "")
            => new() { Success = true, TransactionUid = transactionUid };

        public static StoreResult CreateFailure(string errorMessage, string? userFriendlyMessage = null, DicomErrorType errorType = DicomErrorType.Unknown)
            => new()
            {
                Success = false,
                ErrorMessage = errorMessage,
                UserFriendlyMessage = userFriendlyMessage ?? errorMessage,
                ErrorType = errorType
            };
    }

    /// <summary>
    /// Types of DICOM errors for better handling
    /// </summary>
    public enum DicomErrorType
    {
        None,
        FileNotFound,
        NetworkConnection,
        Authentication,
        Timeout,
        InvalidConfiguration,
        PacsRejection,
        Unknown
    }

    /// <summary>
    /// Service for DICOM C-STORE operations to PACS with enhanced error handling
    /// </summary>
    public class DicomStoreService
    {
        private readonly ILogger<DicomStoreService> _logger;

        public DicomStoreService(ILogger<DicomStoreService> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Store DICOM file to PACS with enhanced error messages
        /// </summary>
        public async Task<StoreResult> StoreFileAsync(string dicomPath, PacsConfiguration config)
        {
            if (config == null) throw new ArgumentNullException(nameof(config));
            if (string.IsNullOrEmpty(dicomPath)) throw new ArgumentException("Path required", nameof(dicomPath));

            if (!File.Exists(dicomPath))
            {
                _logger.LogError("DICOM file not found: {Path}", dicomPath);
                return StoreResult.CreateFailure(
                    $"File not found: {dicomPath}",
                    $"DICOM-Datei nicht gefunden: {Path.GetFileName(dicomPath)}",
                    DicomErrorType.FileNotFound);
            }

            _logger.LogInformation("Starting C-STORE to {Host}:{Port} for {File}",
                config.Host, config.Port, Path.GetFileName(dicomPath));

            try
            {
                // Load DICOM file
                var dicomFile = await DicomFile.OpenAsync(dicomPath);
                var sopInstanceUid = dicomFile.Dataset.GetSingleValue<string>(DicomTag.SOPInstanceUID);
                var patientName = dicomFile.Dataset.GetSingleValueOrDefault<string>(DicomTag.PatientName, "Unknown");

                _logger.LogDebug("Loaded DICOM: SOP Instance UID={Uid}, Patient={Patient}",
                    sopInstanceUid, patientName);

                // Create client
                var client = DicomClientFactory.Create(
                    config.Host,
                    config.Port,
                    false,  // No TLS for now
                    config.CallingAeTitle,
                    config.CalledAeTitle);

                client.NegotiateAsyncOps();

                // Setup response handling with TaskCompletionSource
                DicomCStoreResponse? response = null;
                var responseReceived = new TaskCompletionSource<bool>();

                var request = new DicomCStoreRequest(dicomFile)
                {
                    OnResponseReceived = (req, res) =>
                    {
                        response = res;
                        _logger.LogDebug("C-STORE Response: Status={Status} ({Code:X4})",
                            res.Status.State, res.Status.Code);
                        responseReceived.TrySetResult(true);
                    }
                };

                await client.AddRequestAsync(request);

                // Send with timeout
                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(config.TimeoutSeconds));

                try
                {
                    await Task.WhenAll(
                        client.SendAsync(cts.Token),
                        responseReceived.Task);
                }
                catch (OperationCanceledException)
                {
                    _logger.LogError("C-STORE timeout after {Timeout}s", config.TimeoutSeconds);
                    return StoreResult.CreateFailure(
                        $"Timeout after {config.TimeoutSeconds} seconds",
                        $"PACS antwortet nicht nach {config.TimeoutSeconds} Sekunden. Ist der PACS-Server erreichbar?",
                        DicomErrorType.Timeout);
                }

                // Check response
                if (response?.Status == DicomStatus.Success)
                {
                    _logger.LogInformation("C-STORE successful for {File}, SOP Instance UID: {Uid}",
                        Path.GetFileName(dicomPath), sopInstanceUid);
                    return StoreResult.CreateSuccess(sopInstanceUid);
                }
                else
                {
                    var errorMsg = $"C-STORE failed with status: {response?.Status?.Description ?? "Unknown"}";
                    var userMsg = TranslateDicomStatus(response?.Status);
                    _logger.LogWarning(errorMsg);
                    return StoreResult.CreateFailure(errorMsg, userMsg, DicomErrorType.PacsRejection);
                }
            }
            catch (DicomAssociationRejectedException ex)
            {
                _logger.LogError(ex, "DICOM association rejected");
                var userMsg = TranslateAssociationRejection(ex);
                return StoreResult.CreateFailure(
                    $"Association rejected: {ex.Message}",
                    userMsg,
                    DicomErrorType.Authentication);
            }
            catch (DicomNetworkException ex) when (ex.InnerException is SocketException socketEx)
            {
                _logger.LogError(ex, "Network error during C-STORE");
                var userMsg = TranslateSocketError(socketEx, config);
                return StoreResult.CreateFailure(
                    $"Network error: {ex.Message}",
                    userMsg,
                    DicomErrorType.NetworkConnection);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "C-STORE failed for {File}", Path.GetFileName(dicomPath));
                var userMsg = $"Unerwarteter Fehler beim PACS-Upload: {ex.GetType().Name}. Details siehe Log.";
                return StoreResult.CreateFailure($"Store failed: {ex.Message}", userMsg);
            }
        }

        /// <summary>
        /// Test PACS connection with C-ECHO and enhanced feedback
        /// </summary>
        public async Task<StoreResult> TestConnectionAsync(PacsConfiguration config)
        {
            if (config == null) throw new ArgumentNullException(nameof(config));

            if (!config.IsValid())
            {
                var issues = new System.Text.StringBuilder();
                if (string.IsNullOrWhiteSpace(config.Host))
                    issues.AppendLine("- Host/IP-Adresse fehlt");
                if (config.Port <= 0 || config.Port > 65535)
                    issues.AppendLine($"- UngÃ¼ltiger Port: {config.Port}");
                if (string.IsNullOrWhiteSpace(config.CallingAeTitle))
                    issues.AppendLine("- Calling AE Title fehlt");
                if (string.IsNullOrWhiteSpace(config.CalledAeTitle))
                    issues.AppendLine("- Called AE Title fehlt");

                return StoreResult.CreateFailure(
                    "Invalid PACS configuration",
                    $"PACS-Konfiguration ungÃ¼ltig:\n{issues}",
                    DicomErrorType.InvalidConfiguration);
            }

            _logger.LogInformation("Testing connection to {Host}:{Port} as {CallingAe} â†’ {CalledAe}",
                config.Host, config.Port, config.CallingAeTitle, config.CalledAeTitle);

            try
            {
                // Create client
                var client = DicomClientFactory.Create(
                    config.Host,
                    config.Port,
                    false,  // No TLS
                    config.CallingAeTitle,
                    config.CalledAeTitle);

                client.NegotiateAsyncOps();

                // Setup response handling
                DicomCEchoResponse? response = null;
                var responseReceived = new TaskCompletionSource<bool>();

                var request = new DicomCEchoRequest
                {
                    OnResponseReceived = (req, res) =>
                    {
                        response = res;
                        _logger.LogDebug("C-ECHO Response: {Status}", res.Status);
                        responseReceived.TrySetResult(true);
                    }
                };

                await client.AddRequestAsync(request);

                // Send with timeout
                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(config.TimeoutSeconds));

                try
                {
                    await Task.WhenAll(
                        client.SendAsync(cts.Token),
                        responseReceived.Task);
                }
                catch (OperationCanceledException)
                {
                    _logger.LogError("C-ECHO timeout after {Timeout}s", config.TimeoutSeconds);
                    return StoreResult.CreateFailure(
                        $"Connection timeout after {config.TimeoutSeconds} seconds",
                        $"Verbindungstimeout nach {config.TimeoutSeconds} Sekunden.\n" +
                        $"MÃ¶gliche Ursachen:\n" +
                        $"- PACS-Server lÃ¤uft nicht (z.B. Orthanc Docker Container gestoppt)\n" +
                        $"- Falsche IP/Port ({config.Host}:{config.Port})\n" +
                        $"- Firewall blockiert Verbindung",
                        DicomErrorType.Timeout);
                }

                // Check response
                if (response?.Status == DicomStatus.Success)
                {
                    _logger.LogInformation("C-ECHO successful - PACS connection verified");
                    return StoreResult.CreateSuccess("ECHO-OK");
                }
                else
                {
                    var errorMsg = $"C-ECHO failed: {response?.Status?.Description ?? "No response"}";
                    var userMsg = TranslateDicomStatus(response?.Status);
                    _logger.LogWarning(errorMsg);
                    return StoreResult.CreateFailure(errorMsg, userMsg, DicomErrorType.PacsRejection);
                }
            }
            catch (DicomAssociationRejectedException ex)
            {
                _logger.LogError(ex, "C-ECHO association rejected");
                var userMsg = TranslateAssociationRejection(ex);
                return StoreResult.CreateFailure(
                    $"Association rejected: {ex.Message}",
                    userMsg,
                    DicomErrorType.Authentication);
            }
            catch (DicomNetworkException ex) when (ex.InnerException is SocketException socketEx)
            {
                _logger.LogError(ex, "Network error during C-ECHO");
                var userMsg = TranslateSocketError(socketEx, config);
                return StoreResult.CreateFailure(
                    $"Network error: {ex.Message}",
                    userMsg,
                    DicomErrorType.NetworkConnection);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "C-ECHO failed");
                return StoreResult.CreateFailure(
                    $"Connection test failed: {ex.Message}",
                    $"Verbindungstest fehlgeschlagen: {ex.GetType().Name}\nDetails siehe Log.",
                    DicomErrorType.Unknown);
            }
        }

        /// <summary>
        /// Store DICOM file with retry logic and improved logging
        /// </summary>
        public async Task<StoreResult> StoreFileWithRetryAsync(
            string dicomPath,
            PacsConfiguration config,
            CancellationToken cancellationToken = default)
        {
            if (!config.RetryOnFailure)
            {
                return await StoreFileAsync(dicomPath, config);
            }

            var attempts = 0;
            StoreResult? lastResult = null;
            var fileName = Path.GetFileName(dicomPath);

            while (attempts < config.MaxRetryAttempts && !cancellationToken.IsCancellationRequested)
            {
                attempts++;
                _logger.LogInformation("C-STORE attempt {Attempt}/{Max} for {File}",
                    attempts, config.MaxRetryAttempts, fileName);

                lastResult = await StoreFileAsync(dicomPath, config);

                if (lastResult.Success)
                {
                    if (attempts > 1)
                    {
                        _logger.LogInformation("C-STORE succeeded after {Attempts} attempts for {File}",
                            attempts, fileName);
                    }
                    return lastResult;
                }

                // Check if error is retryable
                if (IsNonRetryableError(lastResult.ErrorType))
                {
                    _logger.LogWarning("Non-retryable error detected for {File}: {ErrorType}",
                        fileName, lastResult.ErrorType);
                    break;
                }

                if (attempts < config.MaxRetryAttempts)
                {
                    var delay = TimeSpan.FromSeconds(config.RetryDelaySeconds * attempts);
                    _logger.LogWarning("C-STORE failed for {File}, retrying in {Delay}s. Error: {Error}",
                        fileName, delay.TotalSeconds, lastResult.UserFriendlyMessage);

                    await Task.Delay(delay, cancellationToken);
                }
            }

            if (attempts >= config.MaxRetryAttempts)
            {
                _logger.LogError("C-STORE failed after {Attempts} attempts for {File}. Final error: {Error}",
                    attempts, fileName, lastResult?.UserFriendlyMessage);
            }

            return lastResult ?? StoreResult.CreateFailure("No attempts made");
        }

        /// <summary>
        /// Determine if an error should not be retried
        /// </summary>
        private bool IsNonRetryableError(DicomErrorType errorType)
        {
            return errorType switch
            {
                DicomErrorType.FileNotFound => true,
                DicomErrorType.InvalidConfiguration => true,
                DicomErrorType.Authentication => true,  // Wrong AE Title won't fix itself
                _ => false  // Network errors, timeouts, etc. are retryable
            };
        }

        /// <summary>
        /// Translate DICOM status codes to user-friendly messages
        /// </summary>
        private string TranslateDicomStatus(DicomStatus? status)
        {
            if (status == null)
                return "Keine Antwort vom PACS-Server erhalten.";

            // Check common status codes
            if (status == DicomStatus.QueryRetrieveOutOfResources)
                return "PACS-Server hat nicht genÃ¼gend Ressourcen. Speicherplatz voll?";

            if (status == DicomStatus.StorageStorageOutOfResources)
                return "PACS-Speicher voll. Administrator kontaktieren.";

            if (status == DicomStatus.ProcessingFailure)
                return "PACS konnte die Datei nicht verarbeiten. DICOM-Format prÃ¼fen.";

            if (status == DicomStatus.NoSuchObjectInstance)
                return "PACS erkennt das Bildformat nicht. Transfer Syntax prÃ¼fen.";

            // Generic message with status code
            return $"PACS-Server meldet: {status.Description} (Code: {status.Code:X4})";
        }

        /// <summary>
        /// Translate association rejection reasons
        /// </summary>
        private string TranslateAssociationRejection(DicomAssociationRejectedException ex)
        {
            var msg = new System.Text.StringBuilder();
            msg.AppendLine("PACS-Verbindung abgelehnt!");

            // Check common rejection reasons in the message
            if (ex.Message.Contains("Called AE Title Not Recognized", StringComparison.OrdinalIgnoreCase))
            {
                msg.AppendLine($"Der Called AE Title wird vom PACS nicht erkannt.");
                msg.AppendLine($"Tipp: Bei Orthanc muss 'DICOM_CHECK_CALLED_AE_TITLE=false' gesetzt sein.");
            }
            else if (ex.Message.Contains("Calling AE Title Not Recognized", StringComparison.OrdinalIgnoreCase))
            {
                msg.AppendLine($"Der Calling AE Title wird vom PACS nicht akzeptiert.");
                msg.AppendLine($"Tipp: AE Title im PACS als bekannter Client registrieren.");
            }
            else
            {
                msg.AppendLine($"Grund: {ex.RejectReason}");
                msg.AppendLine($"Source: {ex.RejectSource}");
                msg.AppendLine($"Result: {ex.RejectResult}");
            }

            return msg.ToString();
        }

        /// <summary>
        /// Translate socket errors to user-friendly messages
        /// </summary>
        private string TranslateSocketError(SocketException socketEx, PacsConfiguration config)
        {
            var msg = new System.Text.StringBuilder();
            msg.AppendLine($"Netzwerkfehler beim Verbinden zu {config.Host}:{config.Port}");

            switch (socketEx.SocketErrorCode)
            {
                case SocketError.ConnectionRefused:
                    msg.AppendLine("Verbindung verweigert!");
                    msg.AppendLine("MÃ¶gliche Ursachen:");
                    msg.AppendLine("- PACS-Server lÃ¤uft nicht (Orthanc Docker Container prÃ¼fen)");
                    msg.AppendLine($"- Falscher Port (aktuell: {config.Port}, Orthanc Standard: 4242)");
                    msg.AppendLine("- Firewall blockiert Verbindung");
                    break;

                case SocketError.HostNotFound:
                case SocketError.HostUnreachable:
                    msg.AppendLine("Host nicht erreichbar!");
                    msg.AppendLine($"- Hostname/IP prÃ¼fen: {config.Host}");
                    msg.AppendLine("- Netzwerkverbindung prÃ¼fen");
                    msg.AppendLine("- DNS-AuflÃ¶sung prÃ¼fen");
                    break;

                case SocketError.TimedOut:
                    msg.AppendLine("Verbindung Timeout!");
                    msg.AppendLine("- PACS-Server Ã¼berlastet?");
                    msg.AppendLine("- Netzwerk zu langsam?");
                    msg.AppendLine($"- Timeout erhÃ¶hen (aktuell: {config.TimeoutSeconds}s)");
                    break;

                default:
                    msg.AppendLine($"Socket-Fehler: {socketEx.SocketErrorCode}");
                    msg.AppendLine($"Details: {socketEx.Message}");
                    break;
            }

            return msg.ToString();
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\DicomTagMapper.cs
================================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Extensions.Logging;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using FellowOakDicom;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Service responsible for mapping values to DICOM tags according to mapping rules
    /// </summary>
    public class DicomTagMapper : IDicomTagMapper
    {
        private readonly ILogger<DicomTagMapper> _logger;

        public DicomTagMapper(ILogger<DicomTagMapper> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Applies a mapping rule to transform a value
        /// </summary>
        public string? ApplyTransform(string? value, string? transform)
        {
            if (string.IsNullOrEmpty(value) || string.IsNullOrEmpty(transform) || transform == "None")
            {
                return value;
            }

            // Parse transform string to enum
            if (!Enum.TryParse<ValueTransform>(transform, out var transformEnum))
            {
                _logger.LogWarning("Unknown transform: {Transform}", transform);
                return value;
            }

            try
            {
                return transformEnum switch
                {
                    ValueTransform.DateToDicom => ConvertDateToDicom(value),
                    ValueTransform.TimeToDicom => ConvertTimeToDicom(value),
                    ValueTransform.DateTimeToDicom => ConvertDateTimeToDicom(value),
                    ValueTransform.MapGender => MapGenderCode(value),
                    ValueTransform.RemovePrefix => RemovePrefix(value),
                    ValueTransform.ExtractDate => ExtractDate(value),
                    ValueTransform.ExtractTime => ExtractTime(value),
                    ValueTransform.ToUpperCase => value.ToUpperInvariant(),
                    ValueTransform.ToLowerCase => value.ToLowerInvariant(),
                    ValueTransform.Trim => value.Trim(),
                    _ => value
                };
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to apply transform {Transform} to value '{Value}'", transform, value);
                return value;
            }
        }

        private string ConvertDateToDicom(string date)
        {
            // Convert various date formats to DICOM format (YYYYMMDD)
            if (DateTime.TryParse(date, out var dt))
            {
                return dt.ToString("yyyyMMdd");
            }

            // Already in DICOM format?
            if (date.Length == 8 && int.TryParse(date, out _))
            {
                return date;
            }

            _logger.LogWarning("Unable to convert date '{Date}' to DICOM format", date);
            return date;
        }

        private string ConvertTimeToDicom(string time)
        {
            // Convert various time formats to DICOM format (HHMMSS)
            if (DateTime.TryParse(time, out var dt))
            {
                return dt.ToString("HHmmss");
            }

            if (TimeSpan.TryParse(time, out var ts))
            {
                return $"{ts.Hours:D2}{ts.Minutes:D2}{ts.Seconds:D2}";
            }

            _logger.LogWarning("Unable to convert time '{Time}' to DICOM format", time);
            return time;
        }

        private string ConvertDateTimeToDicom(string dateTime)
        {
            if (DateTime.TryParse(dateTime, out var dt))
            {
                return dt.ToString("yyyyMMddHHmmss");
            }

            _logger.LogWarning("Unable to convert datetime '{DateTime}' to DICOM format", dateTime);
            return dateTime;
        }

        /// <summary>
        /// Maps source data to a DICOM dataset using mapping rules
        /// </summary>
        public void MapToDataset(DicomDataset dataset, Dictionary<string, string> sourceData, IEnumerable<MappingRule> mappingRules)
        {
            if (dataset == null) throw new ArgumentNullException(nameof(dataset));
            if (sourceData == null) throw new ArgumentNullException(nameof(sourceData));
            if (mappingRules == null) throw new ArgumentNullException(nameof(mappingRules));

            foreach (var rule in mappingRules)
            {
                try
                {
                    // Get source value
                    if (!sourceData.TryGetValue(rule.SourceField, out var sourceValue))
                    {
                        if (rule.Required)
                        {
                            _logger.LogWarning("Required source field '{Field}' not found in data", rule.SourceField);
                        }

                        // Use default value if available
                        sourceValue = rule.DefaultValue;

                        if (string.IsNullOrEmpty(sourceValue))
                        {
                            continue;
                        }
                    }

                    // Apply transform if specified
                    var transformedValue = ApplyTransform(sourceValue, rule.Transform);

                    if (string.IsNullOrEmpty(transformedValue) && rule.Required)
                    {
                        _logger.LogWarning("Required field '{Field}' resulted in empty value after transform", rule.SourceField);
                    }

                    // Parse DICOM tag
                    if (!TryParseDicomTag(rule.DicomTag, out var group, out var element))
                    {
                        _logger.LogError("Invalid DICOM tag format: {Tag}", rule.DicomTag);
                        continue;
                    }

                    // Add to dataset
                    var tag = new DicomTag(group, element);

                    if (!string.IsNullOrEmpty(transformedValue))
                    {
                        dataset.AddOrUpdate(tag, transformedValue);
                        _logger.LogDebug("Mapped {Source} -> {Tag}: {Value}",
                            rule.SourceField, rule.DicomTag, transformedValue);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error mapping rule {Source} -> {Tag}",
                        rule.SourceField, rule.DicomTag);
                }
            }
        }

        /// <summary>
        /// Parses a DICOM tag string like "(0010,0010)" into group and element
        /// </summary>
        private bool TryParseDicomTag(string tagString, out ushort group, out ushort element)
        {
            group = 0;
            element = 0;

            if (string.IsNullOrEmpty(tagString))
                return false;

            // Remove parentheses and spaces
            var cleaned = tagString.Trim('(', ')', ' ');
            var parts = cleaned.Split(',');

            if (parts.Length != 2)
                return false;

            try
            {
                group = Convert.ToUInt16(parts[0].Trim(), 16);
                element = Convert.ToUInt16(parts[1].Trim(), 16);
                return true;
            }
            catch
            {
                return false;
            }
        }

        private string MapGenderCode(string gender)
        {
            return gender?.ToUpperInvariant() switch
            {
                "M" or "MALE" => "M",
                "F" or "FEMALE" => "F",
                "O" or "OTHER" => "O",
                _ => ""
            };
        }

        private string RemovePrefix(string value)
        {
            // Remove common prefixes like "GCM_TAG"
            if (value.StartsWith("GCM_TAG", StringComparison.OrdinalIgnoreCase))
            {
                return value.Substring(7).Trim();
            }

            return value;
        }

        private string ExtractDate(string dateTime)
        {
            if (DateTime.TryParse(dateTime, out var dt))
            {
                return dt.ToString("yyyyMMdd");
            }

            return dateTime;
        }

        private string ExtractTime(string dateTime)
        {
            if (DateTime.TryParse(dateTime, out var dt))
            {
                return dt.ToString("HHmmss");
            }

            return dateTime;
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\ExifToolReader.cs
================================================================================

// src/CamBridge.Infrastructure/Services/ExifToolReader.cs
// Version: 0.8.10
// Description: EXIF data extraction service - with correlation ID support
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Entities;
using CamBridge.Core.ValueObjects;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Service for reading EXIF data from image files using ExifTool
    /// Clean UTF-8 implementation without workarounds
    /// </summary>
    public class ExifToolReader
    {
        private readonly ILogger<ExifToolReader> _logger;
        private readonly string _exifToolPath;
        private readonly string? _correlationId;

        public ExifToolReader(ILogger<ExifToolReader> logger, string exifToolPath, string? correlationId = null)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _correlationId = correlationId;

            if (string.IsNullOrWhiteSpace(exifToolPath))
            {
                throw new ArgumentException("ExifTool path cannot be empty", nameof(exifToolPath));
            }

            // Resolve to absolute path if relative
            _exifToolPath = Path.IsPathRooted(exifToolPath)
                ? exifToolPath
                : Path.Combine(AppDomain.CurrentDomain.BaseDirectory, exifToolPath);

            // Try to find ExifTool in various locations
            if (!File.Exists(_exifToolPath))
            {
                var searchPaths = new[]
                {
                    _exifToolPath,
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Tools", "exiftool.exe"),
                    Path.Combine(Environment.CurrentDirectory, "Tools", "exiftool.exe"),
                    Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)!, "Tools", "exiftool.exe")
                };

                _exifToolPath = searchPaths.FirstOrDefault(File.Exists) ?? _exifToolPath;
            }

            if (!File.Exists(_exifToolPath))
            {
                throw new FileNotFoundException($"ExifTool not found at: {_exifToolPath}");
            }

            if (!string.IsNullOrEmpty(_correlationId))
            {
                _logger.LogInformation("[{CorrelationId}] [ExifInit] ExifToolReader initialized with path: {Path}", _correlationId, _exifToolPath);
            }
            else
            {
                _logger.LogInformation("ExifToolReader initialized with path: {Path}", _exifToolPath);
            }
        }

        /// <summary>
        /// Extract metadata from an image file
        /// </summary>
        public async Task<ImageMetadata> ExtractMetadataAsync(string imagePath)
        {
            // FIXED: Use correlation ID in all logs!
            if (!string.IsNullOrEmpty(_correlationId))
            {
                _logger.LogDebug("[{CorrelationId}] [ExifExtraction] Extracting metadata from: {ImagePath}", _correlationId, imagePath);
            }
            else
            {
                _logger.LogDebug("Extracting metadata from: {ImagePath}", imagePath);
            }

            if (!File.Exists(imagePath))
            {
                throw new FileNotFoundException($"Image file not found: {imagePath}");
            }

            var stopwatch = Stopwatch.StartNew();

            try
            {
                var exifData = await ReadExifDataAsync(imagePath);
                var metadata = ParseExifData(exifData, imagePath);

                stopwatch.Stop();

                // FIXED: Use correlation ID in completion log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogDebug("[{CorrelationId}] [ExifExtraction] EXIF extraction completed in {ElapsedMs}ms",
                        _correlationId, stopwatch.ElapsedMilliseconds);
                }
                else
                {
                    _logger.LogDebug("EXIF extraction completed in {ElapsedMs}ms", stopwatch.ElapsedMilliseconds);
                }

                return metadata;
            }
            catch (Exception ex)
            {
                // FIXED: Use correlation ID in error log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogError(ex, "[{CorrelationId}] [ExifError] Failed to extract EXIF data from {ImagePath}",
                        _correlationId, imagePath);
                }
                else
                {
                    _logger.LogError(ex, "Failed to extract EXIF data from {ImagePath}", imagePath);
                }
                throw new InvalidOperationException($"Failed to extract EXIF data: {ex.Message}", ex);
            }
        }

        private async Task<Dictionary<string, string>> ReadExifDataAsync(string imagePath)
        {
            var arguments = $"-j -a -G1 -s \"{imagePath}\"";

            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = _exifToolPath,
                    Arguments = arguments,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    // Use UTF-8 encoding for clean data
                    StandardOutputEncoding = Encoding.UTF8
                }
            };

            // FIXED: Use correlation ID in debug log
            if (!string.IsNullOrEmpty(_correlationId))
            {
                _logger.LogDebug("[{CorrelationId}] [ExifExtraction] Executing: {FileName} {Arguments}",
                    _correlationId, _exifToolPath, arguments);
            }
            else
            {
                _logger.LogDebug("Executing: {FileName} {Arguments}", _exifToolPath, arguments);
            }

            process.Start();

            var outputTask = process.StandardOutput.ReadToEndAsync();
            var errorTask = process.StandardError.ReadToEndAsync();

            await Task.WhenAll(outputTask, errorTask);
            await process.WaitForExitAsync();

            if (process.ExitCode != 0)
            {
                var error = await errorTask;
                throw new InvalidOperationException($"ExifTool returned exit code {process.ExitCode}: {error}");
            }

            var output = await outputTask;
            return ParseExifToolOutput(output);
        }

        private Dictionary<string, string> ParseExifToolOutput(string output)
        {
            var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            try
            {
                using var doc = JsonDocument.Parse(output);
                var root = doc.RootElement;

                if (root.ValueKind == JsonValueKind.Array && root.GetArrayLength() > 0)
                {
                    var firstElement = root[0];
                    var duplicateKeys = new HashSet<string>();

                    foreach (var property in firstElement.EnumerateObject())
                    {
                        var key = property.Name;
                        // Handle different JSON value types
                        var value = property.Value.ValueKind switch
                        {
                            JsonValueKind.String => property.Value.GetString() ?? string.Empty,
                            JsonValueKind.Number => property.Value.GetRawText(),
                            JsonValueKind.True => "true",
                            JsonValueKind.False => "false",
                            JsonValueKind.Null => string.Empty,
                            _ => property.Value.GetRawText()
                        };

                        // Handle duplicate keys
                        if (result.ContainsKey(key))
                        {
                            duplicateKeys.Add(key);
                            var newKey = $"{key}_{duplicateKeys.Count(k => k == key)}";

                            // FIXED: Use correlation ID in debug log
                            if (!string.IsNullOrEmpty(_correlationId))
                            {
                                _logger.LogDebug("[{CorrelationId}] [ExifExtraction] Duplicate key found: {Key}, renamed to: {NewKey}",
                                    _correlationId, key, newKey);
                            }
                            else
                            {
                                _logger.LogDebug("Duplicate key found: {Key}, renamed to: {NewKey}", key, newKey);
                            }
                            result[newKey] = value;
                        }
                        else
                        {
                            result[key] = value;
                        }
                    }
                }
            }
            catch (JsonException ex)
            {
                // FIXED: Use correlation ID in error log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogError(ex, "[{CorrelationId}] [ExifError] Failed to parse ExifTool JSON output", _correlationId);
                }
                else
                {
                    _logger.LogError(ex, "Failed to parse ExifTool JSON output");
                }
                throw new InvalidOperationException("Failed to parse ExifTool output", ex);
            }

            return result;
        }

        private ImageMetadata ParseExifData(Dictionary<string, string> exifData, string imagePath)
        {
            // Log barcode data if present
            if ((exifData.TryGetValue("RMETA:Barcode", out var barcodeData) ||
                 exifData.TryGetValue("Barcode", out barcodeData)) &&
                !string.IsNullOrEmpty(barcodeData))
            {
                // FIXED: Use correlation ID in barcode log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogInformation("[{CorrelationId}] [ExifExtraction] Found Ricoh barcode data: '{BarcodeData}'",
                        _correlationId, barcodeData);
                }
                else
                {
                    _logger.LogInformation("Found Ricoh barcode data: '{BarcodeData}'", barcodeData);
                }
            }

            // Check for UserComment (alternative location for camera data)
            if (exifData.TryGetValue("ExifIFD:UserComment", out var userComment) ||
                exifData.TryGetValue("UserComment", out userComment))
            {
                // FIXED: Use correlation ID in debug log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogDebug("[{CorrelationId}] [ExifExtraction] UserComment field: '{UserComment}'",
                        _correlationId, userComment);
                }
                else
                {
                    _logger.LogDebug("UserComment field: '{UserComment}'", userComment);
                }
            }

            // Extract patient and study info from barcode data
            var (patientInfo, studyInfo) = ParsePatientAndStudyInfo(exifData);

            // Extract technical data
            var technicalData = new ImageTechnicalData
            {
                ImageWidth = this.GetIntValue(exifData, "File:ImageWidth", "ExifIFD:ExifImageWidth", "ImageWidth", "ExifImageWidth") ?? 0,
                ImageHeight = this.GetIntValue(exifData, "File:ImageHeight", "ExifIFD:ExifImageHeight", "ImageHeight", "ExifImageHeight") ?? 0,
                BitsPerSample = this.GetIntValue(exifData, "File:BitsPerSample", "BitsPerSample") ?? 8,
                Manufacturer = exifData.GetValueOrDefault("IFD0:Make") ?? exifData.GetValueOrDefault("Make") ?? "Unknown",
                Model = exifData.GetValueOrDefault("IFD0:Model") ?? exifData.GetValueOrDefault("Model") ?? "Unknown",
                Software = exifData.GetValueOrDefault("IFD0:Software") ?? exifData.GetValueOrDefault("Software"),
                ColorSpace = exifData.GetValueOrDefault("ExifIFD:ColorSpace") ?? exifData.GetValueOrDefault("ColorSpace"),
                Compression = exifData.GetValueOrDefault("File:Compression") ?? exifData.GetValueOrDefault("Compression"),
                Orientation = this.GetIntValue(exifData, "IFD0:Orientation", "Orientation")
            };

            // Get capture date
            var captureDateTime = ParseDateTime(
                exifData.GetValueOrDefault("ExifIFD:DateTimeOriginal") ??
                exifData.GetValueOrDefault("DateTimeOriginal") ??
                exifData.GetValueOrDefault("ExifIFD:CreateDate") ??
                exifData.GetValueOrDefault("CreateDate") ??
                exifData.GetValueOrDefault("IFD0:ModifyDate") ??
                exifData.GetValueOrDefault("ModifyDate")) ?? DateTime.Now;

            // Create metadata using the actual constructor
            return new ImageMetadata(
                sourceFilePath: imagePath,
                captureDateTime: captureDateTime,
                patient: patientInfo,
                study: studyInfo,
                technicalData: technicalData,
                userComment: userComment,
                barcodeData: barcodeData,
                instanceNumber: 1,
                instanceUid: null, // Will be auto-generated
                exifData: exifData
            );
        }

        private (PatientInfo, StudyInfo) ParsePatientAndStudyInfo(Dictionary<string, string> exifData)
        {
            // Check for barcode data first (Ricoh G900 II stores QR code payload here)
            // Try both with and without prefix
            if ((exifData.TryGetValue("RMETA:Barcode", out var barcodeData) ||
                 exifData.TryGetValue("Barcode", out barcodeData)) &&
                !string.IsNullOrEmpty(barcodeData))
            {
                // FIXED: Use correlation ID in debug log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogDebug("[{CorrelationId}] [ExifExtraction] Found barcode data in Barcode field: '{BarcodeData}'",
                        _correlationId, barcodeData);
                }
                else
                {
                    _logger.LogDebug("Found barcode data in Barcode field: '{BarcodeData}'", barcodeData);
                }
                return ParseBarcodeData(barcodeData);
            }

            // Check UserComment as fallback
            if (exifData.TryGetValue("UserComment", out var userComment) &&
                !string.IsNullOrEmpty(userComment) &&
                userComment.Contains("|"))
            {
                // FIXED: Use correlation ID in debug log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogDebug("[{CorrelationId}] [ExifExtraction] Found barcode data in UserComment field: '{UserComment}'",
                        _correlationId, userComment);
                }
                else
                {
                    _logger.LogDebug("Found barcode data in UserComment field: '{UserComment}'", userComment);
                }
                return ParseBarcodeData(userComment);
            }

            // No barcode data found
            return CreateDefaultPatientAndStudy();
        }

        private (PatientInfo, StudyInfo) ParseBarcodeData(string barcodeData)
        {
            try
            {
                // FIXED: Use correlation ID in debug log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogDebug("[{CorrelationId}] [ExifExtraction] Parsing barcode data: '{BarcodeData}'",
                        _correlationId, barcodeData);
                }
                else
                {
                    _logger.LogDebug("Parsing barcode data: '{BarcodeData}'", barcodeData);
                }

                // Expected format: "ExamId|PatientName|BirthDate|Gender|StudyDescription"
                var parts = barcodeData.Split('|');

                for (int i = 0; i < parts.Length; i++)
                {
                    // FIXED: Use correlation ID in debug log
                    if (!string.IsNullOrEmpty(_correlationId))
                    {
                        _logger.LogDebug("[{CorrelationId}] [ExifExtraction] Barcode field [{Index}]: '{Value}'",
                            _correlationId, i, parts[i]);
                    }
                    else
                    {
                        _logger.LogDebug("Barcode field [{Index}]: '{Value}'", i, parts[i]);
                    }
                }

                if (parts.Length >= 4)
                {
                    // Parse patient info
                    var examId = parts[0]?.Trim() ?? string.Empty;
                    var patientName = parts[1]?.Trim() ?? "Unknown";
                    var birthDateStr = parts[2]?.Trim();
                    var genderStr = parts[3]?.Trim();
                    var studyDescription = parts.Length > 4 ? parts[4]?.Trim() : null;

                    // Parse birth date
                    DateTime? birthDate = null;
                    if (!string.IsNullOrEmpty(birthDateStr))
                    {
                        if (DateTime.TryParse(birthDateStr, out var parsed))
                        {
                            birthDate = parsed;
                        }
                    }

                    // Parse gender
                    var gender = ParseGender(genderStr);

                    // Create patient info
                    var patientInfo = new PatientInfo(
                        id: new PatientId(examId),
                        name: patientName,
                        birthDate: birthDate,
                        gender: gender
                    );

                    // Create study info
                    var studyIdValue = examId.Length > 14 ? examId.Substring(0, 14) : examId;
                    var studyInfo = new StudyInfo(
                        studyId: new StudyId($"S{studyIdValue}"), // Max 16 chars total
                        examId: examId,
                        description: studyDescription ?? "Clinical Photography",
                        modality: "VL", // Visible Light photography
                        studyDate: DateTime.Now
                    );

                    // FIXED: Use correlation ID in success log
                    if (!string.IsNullOrEmpty(_correlationId))
                    {
                        _logger.LogInformation("[{CorrelationId}] [ExifExtraction] Successfully parsed barcode: ExamId={ExamId}, Patient={PatientName}, Study={StudyDescription}",
                            _correlationId, examId, patientName, studyDescription);
                    }
                    else
                    {
                        _logger.LogInformation("Successfully parsed barcode: ExamId={ExamId}, Patient={PatientName}, Study={StudyDescription}",
                            examId, patientName, studyDescription);
                    }

                    return (patientInfo, studyInfo);
                }
            }
            catch (Exception ex)
            {
                // FIXED: Use correlation ID in error log
                if (!string.IsNullOrEmpty(_correlationId))
                {
                    _logger.LogError(ex, "[{CorrelationId}] [ExifError] Error parsing barcode data", _correlationId);
                }
                else
                {
                    _logger.LogError(ex, "Error parsing barcode data");
                }
            }

            return CreateDefaultPatientAndStudy();
        }

        private Gender ParseGender(string? genderStr)
        {
            if (string.IsNullOrWhiteSpace(genderStr))
                return Gender.Other;

            return genderStr.ToUpperInvariant() switch
            {
                "M" or "MALE" => Gender.Male,
                "F" or "FEMALE" => Gender.Female,
                "O" or "OTHER" => Gender.Other,
                _ => Gender.Other
            };
        }

        private (PatientInfo, StudyInfo) CreateDefaultPatientAndStudy()
        {
            var timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
            var shortTimestamp = DateTime.Now.ToString("MMddHHmm");

            var patientInfo = new PatientInfo(
                id: new PatientId($"AUTO_{timestamp}"),
                name: "Unknown Patient",
                birthDate: null,
                gender: Gender.Other
            );

            var studyInfo = new StudyInfo(
                studyId: new StudyId($"S{shortTimestamp}"), // Max 16 chars
                examId: $"AUTO_{timestamp}",
                description: "Unidentified Clinical Photography",
                modality: "VL",
                studyDate: DateTime.Now
            );

            // FIXED: Use correlation ID in warning log
            if (!string.IsNullOrEmpty(_correlationId))
            {
                _logger.LogWarning("[{CorrelationId}] [ExifExtraction] Created default patient/study info with ID: AUTO_{Timestamp}",
                    _correlationId, timestamp);
            }
            else
            {
                _logger.LogWarning("Created default patient/study info with ID: AUTO_{Timestamp}", timestamp);
            }

            return (patientInfo, studyInfo);
        }

        private DateTime? ParseDateTime(string? dateTimeStr)
        {
            if (string.IsNullOrWhiteSpace(dateTimeStr))
                return null;

            // ExifTool format: "2023:12:25 14:30:45"
            if (DateTime.TryParseExact(dateTimeStr, "yyyy:MM:dd HH:mm:ss",
                System.Globalization.CultureInfo.InvariantCulture,
                System.Globalization.DateTimeStyles.None,
                out var result))
            {
                return result;
            }

            // Fallback to standard parsing
            if (DateTime.TryParse(dateTimeStr, out result))
            {
                return result;
            }

            return null;
        }

        private int? GetIntValue(Dictionary<string, string> exifData, params string[] keys)
        {
            foreach (var key in keys)
            {
                if (exifData.TryGetValue(key, out var value))
                {
                    // Handle values like "8 8 8" for BitsPerSample
                    var firstValue = value.Split(' ')[0];

                    if (int.TryParse(firstValue, out var result))
                        return result;
                }
            }
            return null;
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\FileProcessor.cs
================================================================================

// src/CamBridge.Infrastructure/Services/FileProcessor.cs
// Version: 0.8.6
// Description: Pipeline-aware file processor with LogContext integration
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.Entities;
using CamBridge.Core.Interfaces;
using CamBridge.Core.ValueObjects;
using CamBridge.Core.Logging;
using CamBridge.Core.Enums; // FIXED: Import LogVerbosity from correct namespace
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Orchestrates the complete JPEG to DICOM conversion process for a specific pipeline
    /// ENHANCED: Now uses LogContext for structured hierarchical logging
    /// </summary>
    public class FileProcessor
    {
        private readonly ILogger _logger;
        private readonly ExifToolReader _exifToolReader;
        private readonly DicomConverter _dicomConverter;
        private readonly PipelineConfiguration _pipelineConfig;
        private readonly DicomSettings _dicomSettings;
        private readonly IDicomTagMapper? _tagMapper;
        private readonly IMappingConfiguration? _mappingConfiguration;
        private readonly PacsUploadQueue? _pacsUploadQueue;
        private readonly LogVerbosity _logVerbosity;

        public event EventHandler<FileProcessingEventArgs>? ProcessingStarted;
        public event EventHandler<FileProcessingEventArgs>? ProcessingCompleted;
        public event EventHandler<FileProcessingErrorEventArgs>? ProcessingError;

        /// <summary>
        /// Creates a FileProcessor for a specific pipeline with optional PACS upload support
        /// </summary>
        public FileProcessor(
            ILogger logger,
            ExifToolReader exifToolReader,
            DicomConverter dicomConverter,
            PipelineConfiguration pipelineConfig,
            DicomSettings globalDicomSettings,
            IDicomTagMapper? tagMapper = null,
            IMappingConfiguration? mappingConfiguration = null,
            PacsUploadQueue? pacsUploadQueue = null,
            LogVerbosity logVerbosity = LogVerbosity.Detailed,
            string? correlationId = null)  // NEU: Optional correlation ID
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _exifToolReader = exifToolReader ?? throw new ArgumentNullException(nameof(exifToolReader));
            _dicomConverter = dicomConverter ?? throw new ArgumentNullException(nameof(dicomConverter));
            _pipelineConfig = pipelineConfig ?? throw new ArgumentNullException(nameof(pipelineConfig));
            _dicomSettings = ApplyDicomOverrides(globalDicomSettings, pipelineConfig.DicomOverrides);
            _tagMapper = tagMapper;
            _mappingConfiguration = mappingConfiguration;
            _pacsUploadQueue = pacsUploadQueue;
            _logVerbosity = logVerbosity;

            // Log mit Correlation ID wenn vorhanden
            if (!string.IsNullOrEmpty(correlationId))
            {
                _logger.LogDebug("[{CorrelationId}] [ProcessorInit] Created FileProcessor for pipeline: {PipelineName} (\"{PipelineId}\")",
                    correlationId, pipelineConfig.Name, pipelineConfig.Id);

                if (_pacsUploadQueue != null)
                {
                    _logger.LogInformation("[{CorrelationId}] [PacsInit] PACS upload queue attached to pipeline: {PipelineName}",
                        correlationId, pipelineConfig.Name);
                }
            }
            else
            {
                // Fallback ohne Correlation ID
                _logger.LogDebug("Created FileProcessor for pipeline: {PipelineName} (\"{PipelineId}\")",
                    pipelineConfig.Name, pipelineConfig.Id);

                if (_pacsUploadQueue != null)
                {
                    _logger.LogInformation("PACS upload queue attached to pipeline: {PipelineName}",
                        pipelineConfig.Name);
                }
            }
        }

        /// <summary>
        /// Processes a single JPEG file through the pipeline using LogContext
        /// </summary>
        public async Task<FileProcessingResult> ProcessFileAsync(string filePath)
        {
            // Generate correlation ID and create LogContext
            var correlationId = GenerateCorrelationId(filePath);
            var logContext = _logger.CreateContext(correlationId, _pipelineConfig.Name, _logVerbosity);

            var result = new FileProcessingResult
            {
                SourceFile = filePath,
                StartTime = DateTime.UtcNow,
                PipelineId = _pipelineConfig.Id,
                CorrelationId = correlationId
            };

            try
            {
                using (logContext.BeginStage(ProcessingStage.FileDetected, $"Processing file: {Path.GetFileName(filePath)}"))
                {
                    ProcessingStarted?.Invoke(this, new FileProcessingEventArgs
                    {
                        FilePath = filePath,
                        CorrelationId = correlationId,
                        PipelineName = _pipelineConfig.Name,
                        Stage = ProcessingStage.FileDetected
                    });

                    // Validate input file
                    ValidateInputFile(filePath);
                }

                // Extract EXIF data with timing
                ImageMetadata? metadata;
                using (logContext.BeginStage(ProcessingStage.ExifExtraction, "Extracting EXIF metadata"))
                {
                    metadata = await _exifToolReader.ExtractMetadataAsync(filePath);

                    if (metadata == null)
                    {
                        logContext.LogWarning("Failed to extract metadata, creating default DICOM with minimal tags");
                        metadata = CreateDefaultMetadata(filePath);
                    }
                    else if (metadata.Patient != null)
                    {
                        logContext.LogInformation($"Patient: {metadata.Patient.PatientName}");
                    }
                }

                // Apply tag mapping if configured
                if (_tagMapper != null && _mappingConfiguration != null)
                {
                    using (logContext.BeginStage(ProcessingStage.TagMapping, "Applying tag mapping rules"))
                    {
                        var mappingRules = _mappingConfiguration.GetMappingRules();
                        if (mappingRules.Any())
                        {
                            logContext.LogDebug($"Applying {mappingRules.Count()} mapping rules");
                        }
                    }
                }

                // Determine output path based on pipeline configuration
                var outputPath = DetermineOutputPath(metadata, filePath);

                // Ensure output directory exists
                var outputDir = Path.GetDirectoryName(outputPath);
                if (!string.IsNullOrEmpty(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }

                // Convert to DICOM with timing
                ConversionResult conversionResult;
                using (logContext.BeginStage(ProcessingStage.DicomConversion, $"Converting to DICOM: {Path.GetFileName(outputPath)}"))
                {
                    // Create converter with mapper if available
                    var converterWithMapping = new DicomConverter(
                        _logger as ILogger<DicomConverter> ?? Microsoft.Extensions.Logging.Abstractions.NullLogger<DicomConverter>.Instance,
                        _tagMapper,
                        _mappingConfiguration);

                    conversionResult = await converterWithMapping.ConvertToDicomAsync(
                        filePath,
                        outputPath,
                        metadata);
                }

                result.Success = conversionResult.Success;
                result.OutputFile = outputPath;
                result.DicomFile = outputPath;
                result.EndTime = DateTime.UtcNow;
                result.ProcessingTimeMs = (long)(result.EndTime - result.StartTime).TotalMilliseconds;

                if (result.Success)
                {
                    // Queue for PACS upload if enabled
                    if (_pacsUploadQueue != null && _pipelineConfig.PacsConfiguration?.Enabled == true)
                    {
                        using (logContext.BeginStage(ProcessingStage.PacsUpload, $"Queueing for PACS upload to {_pipelineConfig.PacsConfiguration.Host}:{_pipelineConfig.PacsConfiguration.Port}"))
                        {
                            try
                            {
                                await _pacsUploadQueue.EnqueueAsync(conversionResult.DicomFilePath!, correlationId);
                            }
                            catch (Exception ex)
                            {
                                logContext.LogError(ex, "Failed to queue DICOM for PACS upload");
                                // Don't fail the overall processing if PACS queue fails
                            }
                        }
                    }

                    // Handle post-processing
                    using (logContext.BeginStage(ProcessingStage.PostProcessing, "Performing post-processing"))
                    {
                        await HandlePostProcessingAsync(filePath, outputPath, result.Success, logContext);
                    }

                    // Final success log
                    using (logContext.BeginStage(ProcessingStage.Complete, $"Successfully processed {Path.GetFileName(filePath)}"))
                    {
                        // Performance warning for slow processing
                        if (result.ProcessingTimeMs > 5000)
                        {
                            logContext.LogWarning($"Slow processing detected: {result.ProcessingTimeMs}ms");
                        }

                        ProcessingCompleted?.Invoke(this, new FileProcessingEventArgs
                        {
                            FilePath = filePath,
                            OutputPath = outputPath,
                            CorrelationId = correlationId,
                            PipelineName = _pipelineConfig.Name,
                            Stage = ProcessingStage.Complete
                        });
                    }
                }
                else
                {
                    throw new InvalidOperationException(
                        $"DICOM conversion failed: {conversionResult.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.ErrorMessage = ex.Message;
                result.EndTime = DateTime.UtcNow;
                result.ProcessingTimeMs = (long)(result.EndTime - result.StartTime).TotalMilliseconds;

                using (logContext.BeginStage(ProcessingStage.Error, $"Processing failed: {ex.Message}"))
                {
                    logContext.LogError(ex, $"Failed to process {Path.GetFileName(filePath)}");

                    // Critical error detection
                    if (ex is UnauthorizedAccessException && filePath.StartsWith(_pipelineConfig.WatchSettings.Path))
                    {
                        _logger.LogCritical(ex, "[{CorrelationId}] [Error] Cannot access watch folder {Path} - pipeline will fail! [{Pipeline}]",
                            correlationId, _pipelineConfig.WatchSettings.Path, _pipelineConfig.Name);
                    }

                    // Handle failure post-processing
                    await HandlePostProcessingAsync(filePath, null, false, logContext);

                    ProcessingError?.Invoke(this, new FileProcessingErrorEventArgs
                    {
                        FilePath = filePath,
                        Error = ex,
                        CorrelationId = correlationId,
                        PipelineName = _pipelineConfig.Name,
                        Stage = ProcessingStage.Error
                    });
                }
            }

            return result;
        }

        /// <summary>
        /// Handles post-processing with LogContext
        /// </summary>
        private async Task HandlePostProcessingAsync(string sourceFilePath, string? dicomFilePath, bool success, LogContext logContext)
        {
            var action = success
                ? _pipelineConfig.ProcessingOptions.SuccessAction
                : _pipelineConfig.ProcessingOptions.FailureAction;

            try
            {
                logContext.LogDebug($"Performing {action} on source file");

                switch (action)
                {
                    case PostProcessingAction.Delete:
                        // Delete only the source file
                        if (File.Exists(sourceFilePath))
                        {
                            File.Delete(sourceFilePath);
                            logContext.LogDebug("Deleted source file");
                        }
                        break;

                    case PostProcessingAction.Archive:
                        var jpegArchiveFolder = _pipelineConfig.ProcessingOptions.BackupFolder
                            ?? Path.Combine(_pipelineConfig.ProcessingOptions.ArchiveFolder, "ProcessedJPEGs");

                        var archivePath = Path.Combine(
                            jpegArchiveFolder,
                            Path.GetFileName(sourceFilePath));

                        Directory.CreateDirectory(Path.GetDirectoryName(archivePath)!);

                        if (File.Exists(sourceFilePath))
                        {
                            File.Move(sourceFilePath, archivePath, true);
                            logContext.LogDebug($"Archived source JPEG to {Path.GetFullPath(archivePath)}");
                        }

                        // DICOM file stays in output folder
                        if (success && !string.IsNullOrEmpty(dicomFilePath))
                        {
                            logContext.LogInformation($"DICOM file created at: {Path.GetFullPath(dicomFilePath)}");
                        }
                        break;

                    case PostProcessingAction.MoveToError:
                        // Move source file to error folder (typically for failures)
                        if (!success)
                        {
                            await MoveToErrorFolderAsync(sourceFilePath, "Processing failed", logContext);

                            // If DICOM was partially created, clean it up
                            if (!string.IsNullOrEmpty(dicomFilePath) && File.Exists(dicomFilePath))
                            {
                                try
                                {
                                    File.Delete(dicomFilePath);
                                    logContext.LogDebug("Cleaned up partial DICOM file");
                                }
                                catch (Exception ex)
                                {
                                    logContext.LogWarning($"Failed to clean up partial DICOM: {ex.Message}");
                                }
                            }
                        }
                        break;

                    default:
                        // Leave files as-is
                        logContext.LogDebug("No post-processing action");
                        break;
                }
            }
            catch (Exception ex)
            {
                logContext.LogWarning($"Failed to perform {action}: {ex.Message}");
                // Don't fail the overall processing for post-processing errors
            }
        }

        private async Task MoveToErrorFolderAsync(string filePath, string errorMessage, LogContext logContext)
        {
            try
            {
                var errorFolder = _pipelineConfig.ProcessingOptions.ErrorFolder;
                Directory.CreateDirectory(errorFolder);

                var errorFileName = $"{Path.GetFileNameWithoutExtension(filePath)}" +
                                   $"_{DateTime.Now:yyyyMMdd_HHmmss}" +
                                   $"{Path.GetExtension(filePath)}";

                var errorPath = Path.Combine(errorFolder, errorFileName);

                // Write error info file
                var errorInfoPath = Path.ChangeExtension(errorPath, ".error.txt");
                await File.WriteAllTextAsync(errorInfoPath,
                    $"Error Time: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\n" +
                    $"Pipeline: {_pipelineConfig.Name}\n" +
                    $"Source File: {filePath}\n" +
                    $"Correlation ID: {logContext.CorrelationId}\n" +
                    $"Error: {errorMessage}");

                // Move the file
                if (File.Exists(filePath))
                {
                    File.Move(filePath, errorPath, true);
                    logContext.LogDebug("Moved failed file to error folder");
                }
            }
            catch (Exception ex)
            {
                logContext.LogError(ex, "Failed to move file to error folder");
            }
        }

        // Rest of the methods remain the same...

        /// <summary>
        /// Determines if a file should be processed based on pipeline configuration
        /// </summary>
        public bool ShouldProcessFile(string filePath)
        {
            try
            {
                var fileInfo = new FileInfo(filePath);
                var extension = fileInfo.Extension.ToLowerInvariant();

                // Check file extension
                var filePattern = _pipelineConfig.WatchSettings.FilePattern;
                var patterns = string.IsNullOrEmpty(filePattern)
                    ? new[] { "*.jpg", "*.jpeg" }
                    : filePattern.Split(';', StringSplitOptions.RemoveEmptyEntries);

                var isValidExtension = patterns.Any(pattern =>
                {
                    var patternExt = Path.GetExtension(pattern).ToLowerInvariant();
                    return patternExt == extension || patternExt == ".*";
                });

                if (!isValidExtension)
                {
                    return false;
                }

                // Check file age
                if (_pipelineConfig.ProcessingOptions.MaxFileAge.HasValue)
                {
                    var age = DateTime.UtcNow - fileInfo.CreationTimeUtc;
                    if (age > _pipelineConfig.ProcessingOptions.MaxFileAge.Value)
                    {
                        _logger.LogDebug("File {FileName} is too old ({Age} days)",
                            fileInfo.Name, age.TotalDays);
                        return false;
                    }
                }

                // Check file size
                if (_pipelineConfig.ProcessingOptions.MinimumFileSizeBytes.HasValue &&
                    fileInfo.Length < _pipelineConfig.ProcessingOptions.MinimumFileSizeBytes.Value)
                {
                    _logger.LogDebug("File {FileName} is too small ({Size} bytes)",
                        fileInfo.Name, fileInfo.Length);
                    return false;
                }

                if (_pipelineConfig.ProcessingOptions.MaximumFileSizeBytes.HasValue &&
                    fileInfo.Length > _pipelineConfig.ProcessingOptions.MaximumFileSizeBytes.Value)
                {
                    _logger.LogDebug("File {FileName} is too large ({Size} bytes)",
                        fileInfo.Name, fileInfo.Length);
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error checking file {FilePath}", filePath);
                return false;
            }
        }

        private string GenerateCorrelationId(string filePath)
        {
            // Format: F{HHmmssff}-{FilePrefix8}
            // Example: F10234512-IMG_1234
            var timestamp = DateTime.Now.ToString("HHmmssff");
            var fileNameWithoutExt = Path.GetFileNameWithoutExtension(filePath);
            var filePrefix = fileNameWithoutExt.Length > 8
                ? fileNameWithoutExt.Substring(0, 8)
                : fileNameWithoutExt;

            return $"F{timestamp}-{filePrefix}";
        }

        private void ValidateInputFile(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException($"Source file not found: {filePath}");
            }

            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            if (extension != ".jpg" && extension != ".jpeg")
            {
                throw new InvalidOperationException($"Invalid file type: {extension}. Expected JPEG file.");
            }
        }

        private string DetermineOutputPath(ImageMetadata metadata, string sourceFile)
        {
            // FIXED: Use ArchiveFolder as DICOM output if no OutputPath configured
            var baseOutputPath = _pipelineConfig.WatchSettings.OutputPath;

            if (string.IsNullOrEmpty(baseOutputPath))
            {
                // Fallback to ArchiveFolder if no OutputPath (current config behavior)
                baseOutputPath = _pipelineConfig.ProcessingOptions.ArchiveFolder;
                _logger.LogWarning("No OutputPath in WatchSettings, using ArchiveFolder as output: {Path}",
                    Path.GetFullPath(baseOutputPath));
            }

            // ALWAYS make path absolute!
            if (!Path.IsPathRooted(baseOutputPath))
            {
                // If relative path, make it relative to service executable location
                var serviceDir = AppDomain.CurrentDomain.BaseDirectory;
                baseOutputPath = Path.Combine(serviceDir, baseOutputPath);
                _logger.LogWarning("OutputPath was relative, converted to absolute: {Path}",
                    Path.GetFullPath(baseOutputPath));
            }

            _logger.LogDebug("Base output path for pipeline {Pipeline}: {Path}",
                _pipelineConfig.Name, Path.GetFullPath(baseOutputPath));

            var organization = _pipelineConfig.ProcessingOptions.OutputOrganization;
            var fileName = Path.GetFileNameWithoutExtension(sourceFile);

            // Build organized path based on configuration
            var outputDir = baseOutputPath;

            switch (organization)
            {
                case OutputOrganization.ByPatient:
                    if (!string.IsNullOrEmpty(metadata.Patient?.PatientName))
                    {
                        var safeName = SanitizeForPath(metadata.Patient.PatientName);
                        outputDir = Path.Combine(baseOutputPath, safeName);
                        _logger.LogDebug("Output organized by patient: {PatientName} -> {SafeName}",
                            metadata.Patient.PatientName, safeName);
                    }
                    else
                    {
                        outputDir = Path.Combine(baseOutputPath, "Unknown Patient");
                        _logger.LogWarning("No patient name found, using 'Unknown Patient' folder");
                    }
                    break;

                case OutputOrganization.ByDate:
                    // ALWAYS use current date for organization
                    var dateFolder = DateTime.Now.ToString("yyyy-MM-dd");
                    outputDir = Path.Combine(baseOutputPath, dateFolder);
                    _logger.LogDebug("Output organized by date: {Date}", dateFolder);
                    break;

                case OutputOrganization.ByPatientAndDate:
                    if (!string.IsNullOrEmpty(metadata.Patient?.PatientName))
                    {
                        var safeName = SanitizeForPath(metadata.Patient.PatientName);
                        // ALWAYS use current date for organization
                        var dateFolder2 = DateTime.Now.ToString("yyyy-MM-dd");
                        outputDir = Path.Combine(baseOutputPath, safeName, dateFolder2);
                        _logger.LogDebug("Output organized by patient/date: {PatientName}/{Date}",
                            safeName, dateFolder2);
                    }
                    else
                    {
                        var dateFolder3 = DateTime.Now.ToString("yyyy-MM-dd");
                        outputDir = Path.Combine(baseOutputPath, "Unknown Patient", dateFolder3);
                        _logger.LogWarning("No patient name found, using 'Unknown Patient/{Date}' folder", dateFolder3);
                    }
                    break;

                case OutputOrganization.None:
                default:
                    // Use base output path as-is
                    break;
            }

            // Add DICOM extension
            var dicomPath = Path.Combine(outputDir, $"{fileName}.dcm");

            // CRITICAL: ALWAYS return ABSOLUTE path!
            var absolutePath = Path.GetFullPath(dicomPath);
            _logger.LogInformation("Determined DICOM output path: {FullPath}", absolutePath);
            return absolutePath;
        }

        private string SanitizeForPath(string input)
        {
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(Path.GetInvalidPathChars())
                .Distinct()
                .ToArray();

            return string.Join("_", input.Split(invalid, StringSplitOptions.RemoveEmptyEntries));
        }

        private DicomSettings ApplyDicomOverrides(DicomSettings global, DicomOverrides? overrides)
        {
            if (overrides == null)
                return global;

            // Create a copy of global settings with overrides applied
            var settings = new DicomSettings
            {
                InstitutionName = overrides.InstitutionName ?? global.InstitutionName,
                InstitutionDepartment = overrides.InstitutionDepartment ?? global.InstitutionDepartment,
                StationName = global.StationName,
                SourceApplicationEntityTitle = global.SourceApplicationEntityTitle,
                ImplementationVersionName = global.ImplementationVersionName,
                ImplementationClassUid = global.ImplementationClassUid,
                Modality = global.Modality,
                ValidateAfterCreation = global.ValidateAfterCreation
            };

            _logger.LogDebug("Applied DICOM overrides for pipeline: {PipelineName}", _pipelineConfig.Name);
            return settings;
        }

        /// <summary>
        /// Creates minimal default metadata when extraction fails
        /// </summary>
        private ImageMetadata CreateDefaultMetadata(string sourceFile)
        {
            var fileName = Path.GetFileNameWithoutExtension(sourceFile);
            var now = DateTime.Now;

            _logger.LogWarning("Creating default metadata for {FileName} with date {Date}",
                fileName, now.ToString("yyyy-MM-dd"));

            // Create default patient info with constructor
            var patientId = new PatientId($"DEFAULT_{now:yyyyMMddHHmmss}");
            var patient = new PatientInfo(
                id: patientId,
                name: "Unknown Patient",
                birthDate: null,
                gender: Gender.Other
            );

            // Create default study info with constructor
            var studyId = new StudyId(Guid.NewGuid().ToString().Substring(0, 16)); // Max 16 chars
            var study = new StudyInfo(
                studyId: studyId,
                examId: null,
                description: "CamBridge JPEG to DICOM Conversion",
                modality: "XC",  // Photographic Image
                studyDate: now,
                accessionNumber: $"ACC{now:yyyyMMddHHmmss}",
                referringPhysician: null,
                comment: null
            );

            // Create technical data (minimal)
            var technicalData = new ImageTechnicalData
            {
                Manufacturer = "Unknown",
                Model = "Unknown"
            };

            // Create EXIF data dictionary
            var exifData = new Dictionary<string, string>
            {
                ["FileName"] = fileName,
                ["FileDate"] = now.ToString("yyyy-MM-dd HH:mm:ss"),
                ["Source"] = "CamBridge Default"
            };

            // Create metadata with full constructor
            var metadata = new ImageMetadata(
                sourceFilePath: sourceFile,
                captureDateTime: now,
                patient: patient,
                study: study,
                technicalData: technicalData,
                userComment: null,
                barcodeData: null,
                instanceNumber: 1,
                instanceUid: null,
                exifData: exifData
            );

            return metadata;
        }
    }

    /// <summary>
    /// Event arguments for file processing events with correlation support
    /// </summary>
    public class FileProcessingEventArgs : EventArgs
    {
        public string FilePath { get; set; } = string.Empty;
        public string? OutputPath { get; set; }
        public string CorrelationId { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public ProcessingStage Stage { get; set; } = ProcessingStage.FileDetected;
    }

    /// <summary>
    /// Event arguments for file processing errors with correlation support
    /// </summary>
    public class FileProcessingErrorEventArgs : EventArgs
    {
        public string FilePath { get; set; } = string.Empty;
        public Exception Error { get; set; } = null!;
        public string CorrelationId { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public ProcessingStage Stage { get; set; } = ProcessingStage.Error;
    }

    /// <summary>
    /// Result of file processing operation with correlation tracking
    /// </summary>
    public class FileProcessingResult
    {
        public string SourceFile { get; set; } = string.Empty;
        public string? OutputFile { get; set; }
        public string? DicomFile { get; set; }
        public bool Success { get; set; }
        public string? ErrorMessage { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public long ProcessingTimeMs { get; set; }
        public Guid PipelineId { get; set; }
        public string CorrelationId { get; set; } = string.Empty;
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\MappingConfigurationLoader.cs
================================================================================

// File: src/CamBridge.Infrastructure/Services/MappingConfigurationLoader.cs
// Version: 0.8.10
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-30
// Status: Correlation IDs added

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Loads and manages DICOM mapping configurations from JSON files
    /// </summary>
    public class MappingConfigurationLoader : IMappingConfiguration
    {
        private readonly ILogger<MappingConfigurationLoader> _logger;
        private readonly string _configPath;
        private List<MappingRule> _mappingRules;
        private bool _isInitialized = false;

        public MappingConfigurationLoader(ILogger<MappingConfigurationLoader> logger, string configPath = "mappings.json")
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _configPath = configPath;
            _mappingRules = new List<MappingRule>();

            // REMOVED: LoadConfigurationAsync().GetAwaiter().GetResult();
            // This was causing the UI freeze!
            // Configuration will be loaded lazily or explicitly via LoadConfigurationAsync
        }

        /// <inheritdoc />
        public IReadOnlyList<MappingRule> GetMappingRules()
        {
            // Return default rules if not initialized
            if (!_isInitialized)
            {
                LoadDefaultMappings(null);
                _isInitialized = true;
            }
            return _mappingRules.AsReadOnly();
        }

        /// <inheritdoc />
        public async Task<bool> LoadConfigurationAsync(string? filePath = null)
        {
            return await LoadConfigurationAsync(filePath, null);
        }

        /// <summary>
        /// Loads mapping configuration from a JSON file with correlation ID support
        /// </summary>
        public async Task<bool> LoadConfigurationAsync(string? filePath, string? correlationId)
        {
            var path = filePath ?? _configPath;

            try
            {
                // Make path absolute if relative
                if (!Path.IsPathRooted(path))
                {
                    // Try multiple locations for the config file
                    var possiblePaths = new[]
                    {
                        Path.Combine(AppDomain.CurrentDomain.BaseDirectory, path),
                        Path.Combine(Environment.CurrentDirectory, path),
                        Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)!, path),
                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "CamBridge", path)
                    };

                    path = possiblePaths.FirstOrDefault(File.Exists) ?? possiblePaths[0];
                }

                if (!File.Exists(path))
                {
                    if (!string.IsNullOrEmpty(correlationId))
                    {
                        _logger.LogWarning("[{CorrelationId}] [MappingConfig] Mapping configuration file not found: {Path}. Using default mappings.",
                            correlationId, path);
                    }
                    else
                    {
                        _logger.LogWarning("Mapping configuration file not found: {Path}. Using default mappings.", path);
                    }
                    LoadDefaultMappings(correlationId);
                    _isInitialized = true;
                    return false;
                }

                var json = await File.ReadAllTextAsync(path);
                var config = JsonSerializer.Deserialize<MappingConfiguration>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });

                if (config?.Rules != null && config.Rules.Count > 0)
                {
                    _mappingRules = config.Rules;
                    if (!string.IsNullOrEmpty(correlationId))
                    {
                        _logger.LogInformation("[{CorrelationId}] [MappingConfig] Loaded {Count} mapping rules from {Path}",
                            correlationId, _mappingRules.Count, path);
                    }
                    else
                    {
                        _logger.LogInformation("Loaded {Count} mapping rules from {Path}", _mappingRules.Count, path);
                    }
                    _isInitialized = true;
                    return true;
                }
                else
                {
                    if (!string.IsNullOrEmpty(correlationId))
                    {
                        _logger.LogWarning("[{CorrelationId}] [MappingConfig] No mapping rules found in {Path}. Using default mappings.",
                            correlationId, path);
                    }
                    else
                    {
                        _logger.LogWarning("No mapping rules found in {Path}. Using default mappings.", path);
                    }
                    LoadDefaultMappings(correlationId);
                    _isInitialized = true;
                    return false;
                }
            }
            catch (Exception ex)
            {
                if (!string.IsNullOrEmpty(correlationId))
                {
                    _logger.LogError(ex, "[{CorrelationId}] [MappingConfig] Error loading mapping configuration from {Path}",
                        correlationId, path);
                }
                else
                {
                    _logger.LogError(ex, "Error loading mapping configuration from {Path}", path);
                }
                LoadDefaultMappings(correlationId);
                _isInitialized = true;
                return false;
            }
        }

        /// <inheritdoc />
        public async Task<bool> SaveConfigurationAsync(IEnumerable<MappingRule> rules, string? filePath = null)
        {
            var path = filePath ?? _configPath;

            try
            {
                // Make path absolute if relative
                if (!Path.IsPathRooted(path))
                {
                    path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, path);
                }

                // Ensure directory exists
                var directory = Path.GetDirectoryName(path);
                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                var config = new MappingConfiguration
                {
                    Version = "1.0",
                    Rules = rules.ToList()
                };

                var json = JsonSerializer.Serialize(config, new JsonSerializerOptions
                {
                    WriteIndented = true,
                    PropertyNameCaseInsensitive = true
                });

                await File.WriteAllTextAsync(path, json);

                _mappingRules = config.Rules;
                _logger.LogInformation("Saved {Count} mapping rules to {Path}", _mappingRules.Count, path);

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving mapping configuration to {Path}", path);
                return false;
            }
        }

        /// <inheritdoc />
        public void AddRule(MappingRule rule)
        {
            if (rule == null)
                throw new ArgumentNullException(nameof(rule));

            _mappingRules.Add(rule);
            _logger.LogDebug("Added mapping rule: {Source} -> {Target}", rule.SourceField, rule.DicomTag);
        }

        /// <inheritdoc />
        public void RemoveRule(string sourceField)
        {
            var removed = _mappingRules.RemoveAll(r => r.SourceField == sourceField);
            if (removed > 0)
            {
                _logger.LogDebug("Removed {Count} mapping rule(s) for source field: {SourceField}", removed, sourceField);
            }
        }

        /// <inheritdoc />
        public MappingRule? GetRuleForSource(string sourceField)
        {
            // Ensure we have rules loaded
            if (!_isInitialized)
            {
                LoadDefaultMappings(null);
                _isInitialized = true;
            }

            return _mappingRules.FirstOrDefault(r =>
                r.SourceField.Equals(sourceField, StringComparison.OrdinalIgnoreCase));
        }

        /// <inheritdoc />
        public IEnumerable<MappingRule> GetRulesForTag(string dicomTag)
        {
            // Ensure we have rules loaded
            if (!_isInitialized)
            {
                LoadDefaultMappings(null);
                _isInitialized = true;
            }

            return _mappingRules.Where(r =>
                r.DicomTag.Equals(dicomTag, StringComparison.OrdinalIgnoreCase));
        }

        /// <inheritdoc />
        public void ValidateRules()
        {
            foreach (var rule in _mappingRules)
            {
                if (string.IsNullOrWhiteSpace(rule.SourceField))
                    throw new InvalidOperationException($"Invalid rule: SourceField is empty");

                if (string.IsNullOrWhiteSpace(rule.DicomTag))
                    throw new InvalidOperationException($"Invalid rule: DicomTag is empty for source {rule.SourceField}");

                // Additional validation can be added here
            }
        }

        /// <summary>
        /// Loads default mapping rules for Ricoh G900 II
        /// </summary>
        private void LoadDefaultMappings(string? correlationId)
        {
            _mappingRules = new List<MappingRule>
            {
                // Patient Information
                new MappingRule
                {
                    SourceField = "name",
                    DicomTag = "(0010,0010)",
                    Description = "Patient's Name",
                    ValueRepresentation = "PN",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "examid",
                    DicomTag = "(0010,0020)",
                    Description = "Patient ID",
                    ValueRepresentation = "LO",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "birthdate",
                    DicomTag = "(0010,0030)",
                    Description = "Patient's Birth Date",
                    ValueRepresentation = "DA",
                    Transform = "DateToDicom",
                    Required = false
                },
                new MappingRule
                {
                    SourceField = "gender",
                    DicomTag = "(0010,0040)",
                    Description = "Patient's Sex",
                    ValueRepresentation = "CS",
                    Transform = "MapGender",
                    Required = false
                },

                // Study Information
                new MappingRule
                {
                    SourceField = "examid",
                    DicomTag = "(0020,0010)",
                    Description = "Study ID",
                    ValueRepresentation = "SH",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "comment",
                    DicomTag = "(0008,1030)",
                    Description = "Study Description",
                    ValueRepresentation = "LO",
                    Required = false
                },

                // Series Information
                new MappingRule
                {
                    SourceField = "_datetime",
                    DicomTag = "(0008,0021)",
                    Description = "Series Date",
                    ValueRepresentation = "DA",
                    Transform = "ExtractDate",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "_datetime",
                    DicomTag = "(0008,0031)",
                    Description = "Series Time",
                    ValueRepresentation = "TM",
                    Transform = "ExtractTime",
                    Required = true
                }
            };

            if (!string.IsNullOrEmpty(correlationId))
            {
                _logger.LogInformation("[{CorrelationId}] [MappingConfig] Loaded {Count} default mapping rules",
                    correlationId, _mappingRules.Count);
            }
            else
            {
                _logger.LogInformation("Loaded {Count} default mapping rules", _mappingRules.Count);
            }
        }

        /// <summary>
        /// Internal configuration class for JSON serialization
        /// </summary>
        private class MappingConfiguration
        {
            public string Version { get; set; } = "1.0";
            public List<MappingRule> Rules { get; set; } = new();
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\NotificationService.cs
================================================================================

// src/CamBridge.Infrastructure/Services/NotificationService.cs
// Version: 0.7.18
// Description: Ultra-minimal notification service - KISS approach without interface!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Linq;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Ultra-minimal notification service - just logs!
    /// KISS: No email implementation, no interface!
    /// v0.7.18: Direct dependency pattern
    /// </summary>
    public class NotificationService // No more interface!
    {
        private readonly ILogger<NotificationService> _logger;

        public NotificationService(ILogger<NotificationService> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Send daily summary - KISS: just log!
        /// </summary>
        public async Task SendDailySummaryAsync(ProcessingSummary summary)
        {
            await Task.CompletedTask;

            _logger.LogInformation(
                "Daily Summary: Processed {Total}, Success {Success}, Failed {Failed}, Uptime {Uptime}",
                summary.TotalProcessed,
                summary.Successful,
                summary.Failed,
                summary.Uptime);

            if (summary.TopErrors != null && summary.TopErrors.Count > 0)
            {
                _logger.LogInformation("Top Errors: {Errors}",
                    string.Join(", ", summary.TopErrors.Select(e => $"{e.Key}: {e.Value}")));
            }
        }

        /// <summary>
        /// Notify critical error - KISS: just log!
        /// </summary>
        public async Task NotifyErrorAsync(string message, Exception? exception = null)
        {
            await Task.CompletedTask;

            if (exception != null)
            {
                _logger.LogError(exception, "Critical Error: {Message}", message);
            }
            else
            {
                _logger.LogError("Critical Error: {Message}", message);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\PacsUploadQueue.cs
================================================================================

// src/CamBridge.Infrastructure/Services/PacsUploadQueue.cs
// Version: 0.8.10
// Modified: Session 108 - Added correlation ID support
// Purpose: Per-pipeline queue for PACS uploads with retry logic

using System;
using System.IO;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Queue for PACS uploads with retry logic per pipeline
    /// </summary>
    public class PacsUploadQueue : IDisposable
    {
        private readonly Channel<PacsUploadItem> _queue;
        private readonly ILogger<PacsUploadQueue> _logger;
        private readonly DicomStoreService _storeService;
        private readonly PipelineConfiguration _pipelineConfig;
        private readonly CancellationTokenSource _cts;
        private readonly Task _processingTask;
        private readonly string _correlationId;
        private int _queueLength = 0;

        /// <summary>
        /// Current number of items in the upload queue
        /// </summary>
        public int QueueLength => _queueLength;

        public PacsUploadQueue(
            PipelineConfiguration pipelineConfig,
            DicomStoreService storeService,
            ILogger<PacsUploadQueue> logger,
            string correlationId)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _storeService = storeService ?? throw new ArgumentNullException(nameof(storeService));
            _pipelineConfig = pipelineConfig ?? throw new ArgumentNullException(nameof(pipelineConfig));
            _correlationId = correlationId ?? throw new ArgumentNullException(nameof(correlationId));

            if (_pipelineConfig.PacsConfiguration == null)
                throw new ArgumentException("Pipeline must have PACS configuration", nameof(pipelineConfig));

            // Create unbounded channel for queue
            _queue = Channel.CreateUnbounded<PacsUploadItem>(new UnboundedChannelOptions
            {
                SingleReader = true
            });

            _cts = new CancellationTokenSource();
            _processingTask = ProcessQueueAsync(_cts.Token);
        }

        /// <summary>
        /// Queue a DICOM file for upload to PACS
        /// </summary>
        public async Task<bool> EnqueueAsync(string dicomFilePath, string correlationId)
        {
            if (!File.Exists(dicomFilePath))
            {
                _logger.LogWarning(
                    "[{CorrelationId}] [PacsUpload] File not found for upload: {Path} [{Pipeline}]",
                    correlationId, dicomFilePath, _pipelineConfig.Name);
                return false;
            }

            var item = new PacsUploadItem
            {
                DicomFilePath = dicomFilePath,
                CorrelationId = correlationId,
                QueuedAt = DateTime.UtcNow
            };

            try
            {
                await _queue.Writer.WriteAsync(item);
                Interlocked.Increment(ref _queueLength);

                _logger.LogInformation(
                    "[{CorrelationId}] [PacsUpload] File queued for upload (queue depth: {QueueDepth}) [{Pipeline}]",
                    correlationId, _queueLength, _pipelineConfig.Name);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "[{CorrelationId}] [PacsUpload] Failed to queue file [{Pipeline}]",
                    correlationId, _pipelineConfig.Name);
                return false;
            }
        }

        private async Task ProcessQueueAsync(CancellationToken cancellationToken)
        {
            var pacsConfig = _pipelineConfig.PacsConfiguration!;
            var maxConcurrent = Math.Max(1, Math.Min(pacsConfig.MaxConcurrentUploads, 10));

            _logger.LogInformation(
                "[{CorrelationId}] [PacsInit] Starting upload processor with {MaxConcurrent} concurrent uploads [{Pipeline}]",
                _correlationId, maxConcurrent, _pipelineConfig.Name);

            // Use semaphore to limit concurrent uploads
            using var semaphore = new SemaphoreSlim(maxConcurrent, maxConcurrent);

            try
            {
                await foreach (var item in _queue.Reader.ReadAllAsync(cancellationToken))
                {
                    await semaphore.WaitAsync(cancellationToken);

                    // Don't await - let it run in background within concurrency limit
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await ProcessUploadAsync(item, pacsConfig, cancellationToken);
                        }
                        finally
                        {
                            Interlocked.Decrement(ref _queueLength);
                            semaphore.Release();
                        }
                    }, cancellationToken);
                }
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation(
                    "[{CorrelationId}] [PacsShutdown] Upload processor cancelled [{Pipeline}]",
                    _correlationId, _pipelineConfig.Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "[{CorrelationId}] [PacsError] Upload processor failed [{Pipeline}]",
                    _correlationId, _pipelineConfig.Name);
            }
        }

        private async Task ProcessUploadAsync(PacsUploadItem item, PacsConfiguration pacsConfig, CancellationToken cancellationToken)
        {
            var correlationId = item.CorrelationId;
            var queueTime = DateTime.UtcNow - item.QueuedAt;

            _logger.LogInformation(
                "[{CorrelationId}] [PacsUpload] Starting upload after {QueueTime:F1}s queue time [{Pipeline}]",
                correlationId, queueTime.TotalSeconds, _pipelineConfig.Name);

            var result = await _storeService.StoreFileWithRetryAsync(
                item.DicomFilePath,
                pacsConfig,
                cancellationToken);

            if (result.Success)
            {
                _logger.LogInformation(
                    "[{CorrelationId}] [PacsUpload] Successfully uploaded to PACS [{Pipeline}]",
                    correlationId, _pipelineConfig.Name);
            }
            else
            {
                _logger.LogError(
                    "[{CorrelationId}] [PacsUpload] Failed to upload: {ErrorMessage} [{Pipeline}]",
                    correlationId, result.ErrorMessage, _pipelineConfig.Name);
            }
        }

        public void Dispose()
        {
            try
            {
                _cts.Cancel();
                _queue.Writer.TryComplete();

                if (!_processingTask.Wait(TimeSpan.FromSeconds(30)))
                {
                    _logger.LogWarning(
                        "[{CorrelationId}] [PacsShutdown] Upload processor did not complete within timeout [{Pipeline}]",
                        _correlationId, _pipelineConfig.Name);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "[{CorrelationId}] [PacsShutdown] Error during disposal [{Pipeline}]",
                    _correlationId, _pipelineConfig.Name);
            }
            finally
            {
                _cts.Dispose();
            }
        }

        private class PacsUploadItem
        {
            public required string DicomFilePath { get; init; }
            public required string CorrelationId { get; init; }
            public DateTime QueuedAt { get; init; }
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\PipelineManager.cs
================================================================================

// src/CamBridge.Infrastructure/Services/PipelineManager.cs
// Version: 0.8.10
// Last Modified: 2025-06-30
// Description: Manages multiple processing pipelines with hierarchical logging
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.Enums;
using CamBridge.Core.Logging;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Manages multiple file processing pipelines
    /// </summary>
    public class PipelineManager : IHostedService, IDisposable
    {
        private readonly ILogger<PipelineManager> _logger;
        private readonly ILoggerFactory _loggerFactory;
        private readonly IOptionsMonitor<CamBridgeSettingsV2> _settingsMonitor;  // FIXED: Use IOptionsMonitor
        private readonly MappingConfigurationLoader _mappingLoader;
        private readonly NotificationService _notificationService;
        private readonly DicomStoreService? _dicomStoreService;

        private readonly ConcurrentDictionary<string, PipelineStatus> _pipelines;
        private readonly SemaphoreSlim _startupSemaphore;
        private CancellationTokenSource? _shutdownTokenSource;

        public PipelineManager(
            ILogger<PipelineManager> logger,
            ILoggerFactory loggerFactory,
            IOptionsMonitor<CamBridgeSettingsV2> settingsMonitor,  // FIXED: Accept IOptionsMonitor
            MappingConfigurationLoader mappingLoader,
            NotificationService notificationService,
            DicomStoreService? dicomStoreService = null)
        {
            _logger = logger;
            _loggerFactory = loggerFactory;
            _settingsMonitor = settingsMonitor;  // FIXED: Store IOptionsMonitor
            _mappingLoader = mappingLoader;
            _notificationService = notificationService;
            _dicomStoreService = dicomStoreService;

            _pipelines = new ConcurrentDictionary<string, PipelineStatus>();
            _startupSemaphore = new SemaphoreSlim(1, 1);
        }

        /// <summary>
        /// Starts all configured pipelines
        /// </summary>
        public async Task StartAsync(CancellationToken cancellationToken)
        {
            await _startupSemaphore.WaitAsync(cancellationToken);
            try
            {
                // FIXED: Add correlation ID for startup
                var startupCorrelationId = $"PM{DateTime.Now:HHmmssff}-START";
                _logger.LogInformation("[{CorrelationId}] [ServiceStartup] Starting PipelineManager", startupCorrelationId);

                _shutdownTokenSource = new CancellationTokenSource();

                // FIXED: Get current settings value
                var settings = _settingsMonitor.CurrentValue;

                // Validate settings
                if (settings?.Pipelines == null || !settings.Pipelines.Any())
                {
                    _logger.LogWarning("[{CorrelationId}] [ServiceStartup] No pipelines configured", startupCorrelationId);
                    return;
                }

                // DEBUG: Log what we actually loaded
                foreach (var pipeline in settings.Pipelines)
                {
                    _logger.LogDebug("[{CorrelationId}] [ServiceStartup] Pipeline {Name}: Enabled={Enabled}, WatchPath={Watch}, ArchiveFolder={Archive}",
                        startupCorrelationId,
                        pipeline.Name,
                        pipeline.Enabled,
                        pipeline.WatchSettings?.Path ?? "(null)",
                        pipeline.ProcessingOptions?.ArchiveFolder ?? "(null)");
                }

                // Start each pipeline
                var startTasks = settings.Pipelines
                    .Where(p => p.Enabled)
                    .Select(p => CreateAndStartPipelineAsync(p, _shutdownTokenSource.Token));

                await Task.WhenAll(startTasks);

                // FIXED: Add correlation ID
                _logger.LogInformation("[{CorrelationId}] [ServiceStartup] Started {Count} pipelines",
                    startupCorrelationId, _pipelines.Count);
            }
            catch (Exception ex)
            {
                var errorCorrelationId = $"PM{DateTime.Now:HHmmssff}-ERROR";
                _logger.LogError(ex, "[{CorrelationId}] [Error] Failed to start pipelines", errorCorrelationId);
                await _notificationService.NotifyErrorAsync($"Failed to start pipelines: {ex.Message}", ex);
                throw;
            }
            finally
            {
                _startupSemaphore.Release();
            }
        }

        /// <summary>
        /// Stops all running pipelines
        /// </summary>
        public async Task StopAsync(CancellationToken cancellationToken)
        {
            // FIXED: Add correlation ID for shutdown
            var shutdownCorrelationId = $"PM{DateTime.Now:HHmmssff}-STOP";
            _logger.LogInformation("[{CorrelationId}] [ServiceShutdown] Stopping PipelineManager", shutdownCorrelationId);

            // Signal shutdown to all pipelines
            _shutdownTokenSource?.Cancel();

            // Stop all pipelines
            var stopTasks = _pipelines.Values.Select(p => StopPipelineAsync(p, cancellationToken));
            await Task.WhenAll(stopTasks);

            // Clear pipeline dictionary
            _pipelines.Clear();

            // FIXED: Add correlation ID
            _logger.LogInformation("[{CorrelationId}] [ServiceShutdown] PipelineManager stopped", shutdownCorrelationId);
        }

        /// <summary>
        /// Creates and starts a single pipeline
        /// </summary>
        private async Task CreateAndStartPipelineAsync(PipelineConfiguration config, CancellationToken cancellationToken)
        {
            try
            {
                // Generate correlation ID for this pipeline session
                var pipelineCorrelationId = $"P{DateTime.Now:yyyyMMddHHmmss}-{SanitizeForFileName(config.Name)}";

                // FIXED: Get current settings value
                var settings = _settingsMonitor.CurrentValue;
                var logVerbosity = settings.Service?.LogVerbosity ?? LogVerbosity.Detailed;  // Add null check with default

                // Create named logger for this pipeline
                var pipelineLogger = _loggerFactory.CreateLogger($"Pipeline.{config.Name}");
                var logContext = pipelineLogger.CreateContext(pipelineCorrelationId, config.Name, logVerbosity);

                // Note: LogContext is not IDisposable, use BeginStage for timing
                var stageContext = logContext.BeginStage(ProcessingStage.PipelineInitialization, $"Starting pipeline {config.Name}");
                try
                {
                    // Validate configuration
                    ValidatePipelineConfiguration(config);

                    // Extra validation logging
                    if (config.ProcessingOptions == null)
                    {
                        var ex = new InvalidOperationException($"ProcessingOptions is null for pipeline {config.Name}");
                        logContext.LogError(ex, "ProcessingOptions is NULL for pipeline {Pipeline}!", config.Name);
                        throw ex;
                    }

                    // Log pipeline configuration
                    logContext.LogInformation("Watch folder: {WatchFolder}", config.WatchSettings.Path);

                    // FIXED SESSION 107: Use IsNullOrWhiteSpace for empty string handling!
                    var outputPath = !string.IsNullOrWhiteSpace(config.WatchSettings.OutputPath)
                        ? config.WatchSettings.OutputPath
                        : config.ProcessingOptions.ArchiveFolder;

                    logContext.LogInformation("Output path resolution: WatchSettings.OutputPath={OutputPath}, ArchiveFolder={ArchiveFolder}, Final={Final}",
                        config.WatchSettings.OutputPath ?? "(null)",
                        config.ProcessingOptions.ArchiveFolder ?? "(null)",
                        outputPath ?? "(null)");

                    logContext.LogInformation("Output folder: {OutputFolder}", outputPath);
                    logContext.LogInformation("File pattern: {Pattern}", config.WatchSettings.FilePattern);
                    logContext.LogInformation("Max concurrent: {MaxConcurrent}", config.ProcessingOptions.MaxConcurrentProcessing);

                    if (config.PacsConfiguration?.Enabled == true)
                    {
                        // FIXED: Add correlation ID for PACS message!
                        var correlationId = $"PM{DateTime.Now:HHmmssff}-PACS-{config.Name}";
                        _logger.LogInformation("[{CorrelationId}] [PipelineInitialization] PACS upload enabled for pipeline {Pipeline} -> {Host}:{Port}",
                            correlationId, config.Name, config.PacsConfiguration.Host, config.PacsConfiguration.Port);
                    }

                    // Create output directory structure
                    // EXTRA VALIDATION: Make sure we have a valid path
                    if (string.IsNullOrWhiteSpace(outputPath))
                    {
                        outputPath = Path.Combine(
                            Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                            "CamBridge",
                            "Output",
                            config.Name
                        );
                        logContext.LogWarning("Neither OutputPath nor ArchiveFolder configured for pipeline {Pipeline}, using default: {Path}",
                            config.Name, outputPath);
                    }

                    CreateOutputDirectoryStructure(outputPath, config.ProcessingOptions, logContext);

                    // Load mapping configuration from the mapping set
                    var mappingConfigPath = GetMappingConfigPath(config);

                    try
                    {
                        // Load mapping configuration - returns bool
                        var loadSuccess = await _mappingLoader.LoadConfigurationAsync(mappingConfigPath, logContext.CorrelationId);
                        if (loadSuccess)
                        {
                            logContext.LogInformation("Mapping configuration loaded successfully");
                        }
                        else
                        {
                            logContext.LogWarning("Failed to load mapping configuration, using defaults");
                        }
                    }
                    catch (Exception ex)
                    {
                        logContext.LogWarning("Error loading mapping configuration, using defaults: {Message}", ex.Message);
                    }

                    // Create processing components
                    var components = CreateProcessingComponents(config, pipelineLogger, logContext.CorrelationId);

                    // Create PACS upload queue if enabled
                    PacsUploadQueue? pacsQueue = null;
                    if (config.PacsConfiguration?.Enabled == true && _dicomStoreService != null)
                    {
                        pacsQueue = new PacsUploadQueue(config, _dicomStoreService,
                            _loggerFactory.CreateLogger<PacsUploadQueue>(),
                            logContext.CorrelationId);
                        logContext.LogInformation("PACS upload queue created for {AeTitle}",
                            config.PacsConfiguration.CallingAeTitle);
                    }

                    // Create file processor with all components
                    // FIXED: Use _mappingLoader which implements IMappingConfiguration
                    var fileProcessor = new FileProcessor(
                        pipelineLogger,
                        components.ExifTool,
                        components.DicomConverter,
                        config,
                        settings.GlobalDicomSettings,
                        components.TagMapper,
                        _mappingLoader,
                        pacsQueue,
                        logVerbosity,
                        logContext.CorrelationId);

                    // Create processing queue with options wrapper
                    var processingOptions = Options.Create(config.ProcessingOptions);
                    var queue = new ProcessingQueue(
                        _loggerFactory.CreateLogger<ProcessingQueue>(),
                        fileProcessor,
                        processingOptions,
                        config.Name);

                    logContext.LogInformation("Created processing queue with max concurrent: {MaxConcurrent}",
                        config.ProcessingOptions.MaxConcurrentProcessing);

                    // Create file watcher
                    var watcher = CreateFileWatcher(config, queue);
                    logContext.LogInformation("Created file watcher for pattern {Pattern}",
                        config.WatchSettings.FilePattern);

                    // Start queue processing
                    var queueProcessingTask = queue.ProcessQueueAsync(cancellationToken);

                    // Create pipeline status
                    var status = new PipelineStatus
                    {
                        Configuration = config,
                        Queue = queue,
                        Watcher = watcher,
                        ProcessingTask = queueProcessingTask,
                        StartTime = DateTime.UtcNow,
                        LastActivityTime = DateTime.UtcNow,
                        IsRunning = true,
                        PacsQueue = pacsQueue,
                        CorrelationId = pipelineCorrelationId  // Store for later use
                    };

                    // Register pipeline
                    if (!_pipelines.TryAdd(config.Name, status))
                    {
                        throw new InvalidOperationException($"Pipeline {config.Name} already exists");
                    }

                    // Start watching for files
                    watcher.EnableRaisingEvents = true;
                    logContext.LogInformation("Pipeline {Name} started successfully", config.Name);
                }
                finally
                {
                    stageContext?.Dispose();
                }
            }
            catch (Exception ex)
            {
                var errorCorrelationId = $"PE{DateTime.Now:HHmmssff}-{config.Name}";
                _logger.LogError(ex, "[{CorrelationId}] [Error] Failed to start pipeline {Name}", errorCorrelationId, config.Name);
                await _notificationService.NotifyErrorAsync($"Pipeline {config.Name} failed to start: {ex.Message}", ex);
                throw;
            }
        }

        /// <summary>
        /// Gets the mapping configuration path for a pipeline
        /// </summary>
        private string GetMappingConfigPath(PipelineConfiguration config)
        {
            // For now, use a default path - later this will use MappingSetId
            return Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "mappings.json");
        }

        /// <summary>
        /// Creates the output directory structure for a pipeline
        /// </summary>
        private void CreateOutputDirectoryStructure(string outputFolder, ProcessingOptions options, LogContext logContext)
        {
            // FIXED: Validate outputFolder and provide sensible default
            if (string.IsNullOrWhiteSpace(outputFolder))
            {
                // Don't crash - use a default instead!
                outputFolder = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                    "CamBridge",
                    "Output"
                );
                logContext.LogWarning("No output folder configured, using default: {Path}", outputFolder);
            }

            // Create main output directory
            if (!Directory.Exists(outputFolder))
            {
                Directory.CreateDirectory(outputFolder);
                logContext.LogDebug("Created output directory: {Path}", outputFolder);
            }

            // FIXED: Create subdirectories based on actual configured paths
            // NOTE: BackupFolder has no UI control in PipelineConfigPage!
            // This is documented in WISDOM_DEBT.md as missing GUI element
            var subdirectories = new Dictionary<string, string?>
            {
                { "Archive", options.ArchiveFolder },
                { "Error", options.ErrorFolder }
                // Don't create Backup subdirectory - BackupFolder should be absolute path
            };

            // Handle BackupFolder separately if configured
            if (!string.IsNullOrWhiteSpace(options.BackupFolder))
            {
                try
                {
                    if (!Directory.Exists(options.BackupFolder))
                    {
                        Directory.CreateDirectory(options.BackupFolder);
                        logContext.LogDebug("Created backup directory: {Path}", options.BackupFolder);
                    }
                }
                catch (Exception ex)
                {
                    logContext.LogWarning("Failed to create backup directory at {Path}: {Error}",
                        options.BackupFolder, ex.Message);
                }
            }

            // Create other directories (these are absolute paths, not subdirectories!)
            foreach (var kvp in subdirectories)
            {
                if (!string.IsNullOrWhiteSpace(kvp.Value))
                {
                    try
                    {
                        if (!Directory.Exists(kvp.Value))
                        {
                            Directory.CreateDirectory(kvp.Value);
                            logContext.LogDebug("Created {Type} directory: {Path}", kvp.Key, kvp.Value);
                        }
                    }
                    catch (Exception ex)
                    {
                        logContext.LogWarning("Failed to create {Type} directory at {Path}: {Error}",
                            kvp.Key, kvp.Value, ex.Message);
                    }
                }
            }
        }

        /// <summary>
        /// Creates processing components for a pipeline
        /// </summary>
        private (ExifToolReader ExifTool, DicomConverter DicomConverter, DicomTagMapper TagMapper)
            CreateProcessingComponents(PipelineConfiguration config, ILogger pipelineLogger, string correlationId)
        {
            // Create DICOM converter
            var dicomConverter = new DicomConverter(_loggerFactory.CreateLogger<DicomConverter>());

            // Create tag mapper
            var tagMapper = new DicomTagMapper(_loggerFactory.CreateLogger<DicomTagMapper>());

            // Create ExifTool reader - get path from configuration
            var exifToolPath = Path.Combine(
                AppDomain.CurrentDomain.BaseDirectory,
                "Tools",
                "exiftool.exe");

            var exifTool = new ExifToolReader(
                _loggerFactory.CreateLogger<ExifToolReader>(),
                exifToolPath,
                correlationId); // NEU: Correlation ID hinzugefÃ¼gt

            return (exifTool, dicomConverter, tagMapper);
        }

        /// <summary>
        /// Validates pipeline configuration
        /// </summary>
        private void ValidatePipelineConfiguration(PipelineConfiguration config)
        {
            if (string.IsNullOrWhiteSpace(config.Name))
                throw new ArgumentException("Pipeline name is required");

            if (config.WatchSettings == null)
                throw new ArgumentException($"Watch settings are required for pipeline {config.Name}");

            if (string.IsNullOrWhiteSpace(config.WatchSettings.Path))
                throw new ArgumentException($"Watch folder is required for pipeline {config.Name}");

            if (!Directory.Exists(config.WatchSettings.Path))
                throw new DirectoryNotFoundException($"Watch folder not found for pipeline {config.Name}: {config.WatchSettings.Path}");

            if (config.ProcessingOptions == null)
                throw new ArgumentException($"Processing options are required for pipeline {config.Name}");

            // Don't require ArchiveFolder if OutputPath is set
            if (string.IsNullOrWhiteSpace(config.WatchSettings.OutputPath) &&
                string.IsNullOrWhiteSpace(config.ProcessingOptions.ArchiveFolder))
            {
                _logger.LogWarning("Pipeline {Name} has no output path configured, will use default", config.Name);
            }

            if (string.IsNullOrWhiteSpace(config.WatchSettings.FilePattern))
                throw new ArgumentException($"File pattern is required for pipeline {config.Name}");

            if (config.ProcessingOptions.MaxConcurrentProcessing <= 0)
                throw new ArgumentException($"Max concurrent processing must be positive for pipeline {config.Name}");
        }

        /// <summary>
        /// Creates a file watcher for the pipeline
        /// </summary>
        private FileSystemWatcher CreateFileWatcher(PipelineConfiguration config, ProcessingQueue queue)
        {
            var watcher = new FileSystemWatcher(config.WatchSettings.Path)
            {
                Filter = GetFirstPattern(config.WatchSettings.FilePattern),
                NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite | NotifyFilters.CreationTime,
                IncludeSubdirectories = config.WatchSettings.IncludeSubdirectories
            };

            // Handle file events
            watcher.Created += async (s, e) => await OnFileDetectedAsync(config.Name, e.FullPath, queue);
            watcher.Changed += async (s, e) => await OnFileDetectedAsync(config.Name, e.FullPath, queue);
            watcher.Error += (s, e) => OnWatcherError(config.Name, e);

            return watcher;
        }

        /// <summary>
        /// Gets the first pattern from a semicolon-separated list
        /// </summary>
        private string GetFirstPattern(string patterns)
        {
            var parts = patterns.Split(';', StringSplitOptions.RemoveEmptyEntries);
            return parts.Length > 0 ? parts[0].Trim() : "*.*";
        }

        /// <summary>
        /// Handles file detection events
        /// </summary>
        private async Task OnFileDetectedAsync(string pipelineName, string filePath, ProcessingQueue queue)
        {
            try
            {
                // Skip temporary files
                if (Path.GetFileName(filePath).StartsWith("~") ||
                    Path.GetFileName(filePath).StartsWith("."))
                {
                    return;
                }

                // Check file pattern (if multiple patterns)
                if (!IsFilePatternMatch(filePath, pipelineName))
                {
                    return;
                }

                // Add to queue
                var added = await queue.EnqueueAsync(filePath);
                if (added)
                {
                    _logger.LogDebug("[{Pipeline}] File queued: {File}", pipelineName, Path.GetFileName(filePath));

                    // Update last activity time
                    if (_pipelines.TryGetValue(pipelineName, out var status))
                    {
                        status.LastActivityTime = DateTime.UtcNow;
                    }
                }
                else
                {
                    _logger.LogWarning("[{Pipeline}] Queue full or duplicate, file skipped: {File}",
                        pipelineName, Path.GetFileName(filePath));
                }
            }
            catch (Exception ex)
            {
                var errorCorrelationId = $"FD{DateTime.Now:HHmmssff}-{pipelineName}";
                _logger.LogError(ex, "[{CorrelationId}] [Error] Error handling file detection for {File} in pipeline {Pipeline}",
                    errorCorrelationId, filePath, pipelineName);
            }
        }

        /// <summary>
        /// Checks if file matches any of the pipeline's patterns
        /// </summary>
        private bool IsFilePatternMatch(string filePath, string pipelineName)
        {
            if (_pipelines.TryGetValue(pipelineName, out var status))
            {
                var patterns = status.Configuration.WatchSettings.FilePattern
                    .Split(';', StringSplitOptions.RemoveEmptyEntries)
                    .Select(p => p.Trim());

                var fileName = Path.GetFileName(filePath);
                foreach (var pattern in patterns)
                {
                    if (FileMatchesPattern(fileName, pattern))
                        return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Simple pattern matching
        /// </summary>
        private bool FileMatchesPattern(string fileName, string pattern)
        {
            // Simple implementation - can be enhanced
            if (pattern == "*.*") return true;

            var extension = Path.GetExtension(fileName);
            var patternExt = pattern.StartsWith("*.") ? pattern.Substring(1) : pattern;

            return string.Equals(extension, patternExt, StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Handles watcher errors
        /// </summary>
        private void OnWatcherError(string pipelineName, ErrorEventArgs e)
        {
            var ex = e.GetException();
            // FIXED: Add correlation ID
            var errorCorrelationId = $"WE{DateTime.Now:HHmmssff}-{pipelineName}";
            _logger.LogError(ex, "[{CorrelationId}] [WatcherError] File watcher error for pipeline {Pipeline}",
                errorCorrelationId, pipelineName);

            // Try to recover by recreating the watcher
            Task.Run(async () =>
            {
                await Task.Delay(5000);
                await RecoverPipelineAsync(pipelineName);
            });
        }

        /// <summary>
        /// Attempts to recover a failed pipeline
        /// </summary>
        private async Task RecoverPipelineAsync(string pipelineName)
        {
            try
            {
                // FIXED: Add correlation ID
                var recoveryCorrelationId = $"PR{DateTime.Now:HHmmssff}-{pipelineName}";
                _logger.LogInformation("[{CorrelationId}] [PipelineRecovery] Attempting to recover pipeline {Pipeline}",
                    recoveryCorrelationId, pipelineName);

                if (_pipelines.TryGetValue(pipelineName, out var status))
                {
                    // Stop the current pipeline
                    await StopPipelineAsync(status, CancellationToken.None);

                    // Remove from dictionary
                    _pipelines.TryRemove(pipelineName, out _);

                    // Restart if we're not shutting down
                    if (_shutdownTokenSource != null && !_shutdownTokenSource.Token.IsCancellationRequested)
                    {
                        await CreateAndStartPipelineAsync(status.Configuration, _shutdownTokenSource.Token);
                        // FIXED: Add correlation ID
                        _logger.LogInformation("[{CorrelationId}] [PipelineRecovery] Pipeline {Pipeline} recovered successfully",
                            recoveryCorrelationId, pipelineName);
                    }
                }
            }
            catch (Exception ex)
            {
                // FIXED: Add correlation ID
                var errorCorrelationId = $"PR{DateTime.Now:HHmmssff}-{pipelineName}-FAIL";
                _logger.LogError(ex, "[{CorrelationId}] [Error] Failed to recover pipeline {Pipeline}",
                    errorCorrelationId, pipelineName);
            }
        }

        /// <summary>
        /// Stops a single pipeline
        /// </summary>
        private async Task StopPipelineAsync(PipelineStatus status, CancellationToken cancellationToken)
        {
            try
            {
                // FIXED: Use stored correlation ID or create new one
                var pipelineCorrelationId = status.CorrelationId ?? $"PS{DateTime.Now:HHmmssff}-{status.Configuration.Name}";
                // FIXED: Handle TaskCanceledException separately
                try
                {
                    _logger.LogInformation("[{CorrelationId}] [PipelineShutdown] Stopping pipeline {Name}",
                        pipelineCorrelationId, status.Configuration.Name);

                    // Stop watching for new files
                    status.Watcher.EnableRaisingEvents = false;
                    status.Watcher.Dispose();

                    // Stop queue processing
                    await status.Queue.StopAsync(cancellationToken);

                    // Wait for processing to complete
                    if (status.ProcessingTask != null)
                    {
                        try
                        {
                            await status.ProcessingTask.WaitAsync(TimeSpan.FromSeconds(30), cancellationToken);
                        }
                        catch (TimeoutException)
                        {
                            _logger.LogWarning("[{CorrelationId}] [PipelineShutdown] Pipeline {Name} processing task did not complete in time",
                                pipelineCorrelationId, status.Configuration.Name);
                        }
                    }

                    // Stop PACS queue if present
                    if (status.PacsQueue != null)
                    {
                        status.PacsQueue.Dispose();
                    }

                    status.IsRunning = false;
                    status.StopTime = DateTime.UtcNow;

                    // FIXED: Add correlation ID
                    _logger.LogInformation("[{CorrelationId}] [PipelineShutdown] Pipeline {Name} stopped",
                        pipelineCorrelationId, status.Configuration.Name);
                }
                catch (TaskCanceledException)
                {
                    // FIXED: Log cancellation as INFO, not ERROR
                    _logger.LogInformation("[{CorrelationId}] [PipelineShutdown] Pipeline {Name} cancelled",
                        pipelineCorrelationId, status.Configuration.Name);
                }
            }
            catch (Exception ex)
            {
                var errorCorrelationId = $"PS{DateTime.Now:HHmmssff}-{status.Configuration.Name}-ERROR";
                _logger.LogError(ex, "[{CorrelationId}] [Error] Error stopping pipeline {Name}",
                    errorCorrelationId, status.Configuration.Name);
            }
        }

        /// <summary>
        /// Gets the current status of all pipelines
        /// </summary>
        public IReadOnlyDictionary<string, PipelineInfo> GetPipelineStatus()
        {
            var result = new Dictionary<string, PipelineInfo>();

            foreach (var kvp in _pipelines)
            {
                var status = kvp.Value;
                var stats = status.Queue.GetStatistics();

                // FIXED SESSION 107: Use IsNullOrWhiteSpace for proper fallback
                var outputFolder = !string.IsNullOrWhiteSpace(status.Configuration.WatchSettings.OutputPath)
                    ? status.Configuration.WatchSettings.OutputPath
                    : status.Configuration.ProcessingOptions.ArchiveFolder;

                result[kvp.Key] = new PipelineInfo
                {
                    Name = kvp.Key,
                    IsRunning = status.IsRunning,
                    StartTime = status.StartTime,
                    LastActivityTime = status.LastActivityTime,
                    ProcessedCount = stats.TotalProcessed,
                    ErrorCount = stats.TotalFailed,
                    QueueLength = stats.QueueLength,
                    WatchFolder = status.Configuration.WatchSettings.Path,
                    OutputFolder = outputFolder
                };
            }

            return result;
        }

        /// <summary>
        /// Gets detailed information about a specific pipeline
        /// </summary>
        public PipelineInfo? GetPipelineInfo(string pipelineName)
        {
            if (_pipelines.TryGetValue(pipelineName, out var status))
            {
                var stats = status.Queue.GetStatistics();

                // FIXED SESSION 107: Use IsNullOrWhiteSpace for proper fallback
                var outputFolder = !string.IsNullOrWhiteSpace(status.Configuration.WatchSettings.OutputPath)
                    ? status.Configuration.WatchSettings.OutputPath
                    : status.Configuration.ProcessingOptions.ArchiveFolder;

                return new PipelineInfo
                {
                    Name = pipelineName,
                    IsRunning = status.IsRunning,
                    StartTime = status.StartTime,
                    LastActivityTime = status.LastActivityTime,
                    ProcessedCount = stats.TotalProcessed,
                    ErrorCount = stats.TotalFailed,
                    QueueLength = stats.QueueLength,
                    WatchFolder = status.Configuration.WatchSettings.Path,
                    OutputFolder = outputFolder
                };
            }

            return null;
        }

        /// <summary>
        /// Gets pipeline statuses for Worker.cs
        /// </summary>
        public List<PipelineStatusInfo> GetPipelineStatuses()
        {
            var result = new List<PipelineStatusInfo>();

            foreach (var kvp in _pipelines)
            {
                var status = kvp.Value;
                var stats = status.Queue.GetStatistics();

                result.Add(new PipelineStatusInfo
                {
                    Name = kvp.Key,
                    IsActive = status.IsRunning,
                    WatchPath = status.Configuration.WatchSettings.Path,
                    QueueDepth = stats.QueueLength,
                    ProcessedCount = stats.TotalProcessed,
                    ErrorCount = stats.TotalFailed
                });
            }

            return result;
        }

        /// <summary>
        /// Stops all pipelines (called by Worker.cs)
        /// </summary>
        public async Task StopAsync()
        {
            await StopAsync(CancellationToken.None);
        }

        /// <summary>
        /// Sanitizes a string for use in file names
        /// </summary>
        private string SanitizeForFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(new[] { ' ', '.', ',', '/', '\\', ':', '-' })
                .Distinct()
                .ToArray();

            return string.Join("_", name.Split(invalid, StringSplitOptions.RemoveEmptyEntries));
        }

        public void Dispose()
        {
            _shutdownTokenSource?.Cancel();
            _shutdownTokenSource?.Dispose();
            _startupSemaphore?.Dispose();

            // Dispose all pipeline resources
            foreach (var status in _pipelines.Values)
            {
                status.Watcher?.Dispose();
                status.PacsQueue?.Dispose();
            }

            _pipelines.Clear();
        }
    }

    /// <summary>
    /// Internal class to track pipeline status
    /// </summary>
    internal class PipelineStatus
    {
        public required PipelineConfiguration Configuration { get; init; }
        public required ProcessingQueue Queue { get; init; }
        public required FileSystemWatcher Watcher { get; init; }
        public Task? ProcessingTask { get; init; }
        public DateTime StartTime { get; init; }
        public DateTime? StopTime { get; set; }
        public DateTime LastActivityTime { get; set; }
        public bool IsRunning { get; set; }
        public PacsUploadQueue? PacsQueue { get; init; }
        public string? CorrelationId { get; set; }  // FIXED: Add for tracking
    }

    /// <summary>
    /// Public information about a pipeline
    /// </summary>
    public class PipelineInfo
    {
        public string Name { get; init; } = string.Empty;
        public bool IsRunning { get; init; }
        public DateTime StartTime { get; init; }
        public DateTime LastActivityTime { get; init; }
        public int ProcessedCount { get; init; }
        public int ErrorCount { get; init; }
        public int QueueLength { get; init; }
        public string WatchFolder { get; init; } = string.Empty;
        public string OutputFolder { get; init; } = string.Empty;
    }

    /// <summary>
    /// Status info for Worker.cs compatibility
    /// </summary>
    public class PipelineStatusInfo
    {
        public string Name { get; init; } = string.Empty;
        public bool IsActive { get; init; }
        public string WatchPath { get; init; } = string.Empty;
        public int QueueDepth { get; init; }
        public int ProcessedCount { get; init; }
        public int ErrorCount { get; init; }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\ProcessingQueue.cs
================================================================================

// src/CamBridge.Infrastructure/Services/ProcessingQueue.cs
// Version: 0.8.10
// Description: Thread-safe queue with duplicate detection and CORRELATION IDS
// Session: 107 - Added correlation IDs using PM prefix (part of PipelineManager)
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Thread-safe queue for managing file processing with retry logic
    /// FIXED: Prevents duplicate processing of successfully completed files
    /// FIXED: NullReferenceException in StopAsync
    /// FIXED: Added correlation IDs to all logs
    /// </summary>
    public class ProcessingQueue
    {
        private readonly ILogger<ProcessingQueue> _logger;
        private readonly FileProcessor _fileProcessor;
        private readonly ProcessingOptions _options;
        private readonly string _pipelineName;  // NEW: For correlation IDs
        private readonly ConcurrentQueue<ProcessingItem> _queue = new();
        private readonly ConcurrentDictionary<string, ProcessingItem> _activeItems = new();
        private readonly SemaphoreSlim _processingSlots;
        private CancellationTokenSource? _cancellationSource;
        private Task? _processingTask;

        // FIX: Track processed and enqueued files to prevent duplicates
        private readonly HashSet<string> _processedFiles = new();
        private readonly HashSet<string> _enqueuedFiles = new();
        private readonly object _trackingLock = new object();

        // Statistics
        private int _totalProcessed;
        private int _totalSuccessful;
        private int _totalFailed;
        private readonly DateTime _startTime = DateTime.UtcNow;
        private readonly ConcurrentDictionary<string, int> _errorCounts = new();
        private readonly object _statsLock = new object();

        // Public statistics properties
        public int QueueLength => _queue.Count;
        public int ActiveCount => _activeItems.Count;
        public int TotalProcessed => _totalProcessed;
        public int TotalSuccessful => _totalSuccessful;
        public int TotalFailed => _totalFailed;
        public TimeSpan UpTime => DateTime.UtcNow - _startTime;

        /// <summary>
        /// Creates a ProcessingQueue with a specific FileProcessor for this pipeline
        /// </summary>
        public ProcessingQueue(
            ILogger<ProcessingQueue> logger,
            FileProcessor fileProcessor,
            IOptions<ProcessingOptions> options,
            string pipelineName)  // NEW: Add pipeline name
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _fileProcessor = fileProcessor ?? throw new ArgumentNullException(nameof(fileProcessor));
            _options = options?.Value ?? throw new ArgumentNullException(nameof(options));
            _pipelineName = pipelineName ?? "Unknown";  // NEW: Store pipeline name

            _processingSlots = new SemaphoreSlim(
                _options.MaxConcurrentProcessing,
                _options.MaxConcurrentProcessing);
        }

        /// <summary>
        /// Enqueues a file for processing
        /// </summary>
        public bool TryEnqueue(string filePath)
        {
            if (string.IsNullOrWhiteSpace(filePath))
                return false;

            var correlationId = $"PM{DateTime.Now:HHmmssff}-QUEUE-{_pipelineName}";  // Using PM prefix!

            lock (_trackingLock)
            {
                // FIX: Check if already successfully processed
                if (_processedFiles.Contains(filePath))
                {
                    _logger.LogDebug("[{CorrelationId}] [QueueDuplicate] File {FilePath} already processed, ignoring duplicate event",
                        correlationId, filePath);
                    return false;
                }

                // FIX: Check if already in queue
                if (_enqueuedFiles.Contains(filePath))
                {
                    _logger.LogDebug("[{CorrelationId}] [QueueDuplicate] File {FilePath} already in queue, ignoring duplicate event",
                        correlationId, filePath);
                    return false;
                }

                // Check if already being processed
                if (_activeItems.ContainsKey(filePath))
                {
                    _logger.LogDebug("[{CorrelationId}] [QueueActive] File {FilePath} is currently being processed",
                        correlationId, filePath);
                    return false;
                }

                // Add to tracking
                _enqueuedFiles.Add(filePath);
            }

            var item = new ProcessingItem(filePath);
            _queue.Enqueue(item);

            _logger.LogInformation("[{CorrelationId}] [QueueEnqueue] Enqueued {FilePath} for processing (queue length: {QueueLength})",
                correlationId, filePath, _queue.Count);

            return true;
        }

        /// <summary>
        /// Async wrapper for TryEnqueue to match PipelineManager expectations
        /// </summary>
        public Task<bool> EnqueueAsync(string filePath, CancellationToken cancellationToken = default)
        {
            var result = TryEnqueue(filePath);
            return Task.FromResult(result);
        }

        /// <summary>
        /// Processes items from the queue
        /// </summary>
        public async Task ProcessAsync(CancellationToken cancellationToken)
        {
            var startCorrelationId = $"PM{DateTime.Now:HHmmssff}-QSTART-{_pipelineName}";
            _logger.LogInformation("[{CorrelationId}] [QueueStart] Processing queue started [{Pipeline}]",
                startCorrelationId, _pipelineName);

            try
            {
                while (!cancellationToken.IsCancellationRequested)
                {
                    if (_queue.TryDequeue(out var item))
                    {
                        await _processingSlots.WaitAsync(cancellationToken);

                        // Fire and forget - process in background
                        _ = Task.Run(async () =>
                        {
                            try
                            {
                                await ProcessItemAsync(item, cancellationToken);
                            }
                            catch (Exception ex)
                            {
                                var errorCorrelationId = $"PM{DateTime.Now:HHmmssff}-QERROR-{_pipelineName}";
                                _logger.LogError(ex, "[{CorrelationId}] [QueueError] Unexpected error in background processing",
                                    errorCorrelationId);
                            }
                        }, cancellationToken);
                    }
                    else
                    {
                        // No items to process, wait a bit
                        await Task.Delay(100, cancellationToken);
                    }
                }
            }
            catch (TaskCanceledException)
            {
                // This is normal during shutdown
                var cancelCorrelationId = $"PM{DateTime.Now:HHmmssff}-QCANCEL-{_pipelineName}";
                _logger.LogInformation("[{CorrelationId}] [QueueCancelled] Processing queue cancelled [{Pipeline}]",
                    cancelCorrelationId, _pipelineName);
                throw;  // Re-throw so PipelineManager can handle it
            }
            finally
            {
                var stopCorrelationId = $"PM{DateTime.Now:HHmmssff}-QSTOP-{_pipelineName}";
                _logger.LogInformation("[{CorrelationId}] [QueueStop] Processing queue stopped [{Pipeline}]",
                    stopCorrelationId, _pipelineName);
            }
        }

        /// <summary>
        /// Compatibility wrapper for PipelineManager that expects ProcessQueueAsync
        /// </summary>
        public Task ProcessQueueAsync(CancellationToken cancellationToken)
        {
            _cancellationSource = new CancellationTokenSource();
            return ProcessAsync(cancellationToken);
        }

        /// <summary>
        /// Starts the background processing
        /// </summary>
        public Task StartAsync(CancellationToken cancellationToken)
        {
            _cancellationSource = new CancellationTokenSource();
            _processingTask = ProcessAsync(_cancellationSource.Token);
            return Task.CompletedTask;
        }

        /// <summary>
        /// Stops the background processing
        /// </summary>
        public async Task StopAsync(CancellationToken cancellationToken)
        {
            // FIXED: Null checks added!
            _cancellationSource?.Cancel();

            if (_processingTask != null)
            {
                try
                {
                    await _processingTask;
                }
                catch (OperationCanceledException)
                {
                    // Expected when canceling
                }
            }

            // Dispose cancellation source
            _cancellationSource?.Dispose();
            _cancellationSource = null;
        }

        /// <summary>
        /// Gets current statistics
        /// </summary>
        public ProcessingStatistics GetStatistics()
        {
            lock (_statsLock)
            {
                return new ProcessingStatistics
                {
                    QueueLength = QueueLength,
                    ActiveCount = ActiveCount,
                    TotalProcessed = TotalProcessed,
                    TotalSuccessful = TotalSuccessful,
                    TotalFailed = TotalFailed,
                    UpTime = UpTime,
                    ProcessingRate = TotalProcessed > 0 ? TotalProcessed / UpTime.TotalMinutes : 0,
                    TopErrors = _errorCounts
                        .OrderByDescending(x => x.Value)
                        .Take(5)
                        .ToDictionary(x => x.Key, x => x.Value)
                };
            }
        }

        private async Task ProcessItemAsync(ProcessingItem item, CancellationToken cancellationToken)
        {
            // Use same format as FileProcessor: F{timestamp}-{fileprefix}
            var fileName = Path.GetFileNameWithoutExtension(item.FilePath);
            var filePrefix = fileName.Length > 8 ? fileName.Substring(0, 8) : fileName;
            var itemCorrelationId = $"F{DateTime.Now:HHmmssff}-{filePrefix}";

            try
            {
                // Mark as active
                _activeItems.TryAdd(item.FilePath, item);
                item.StartTime = DateTime.UtcNow;
                item.AttemptCount++;

                _logger.LogInformation("[{CorrelationId}] [ProcessStart] Starting processing of {FilePath} (attempt {Attempt}) [{Pipeline}]",
                    itemCorrelationId, item.FilePath, item.AttemptCount, _pipelineName);

                // Process the file with THIS pipeline's FileProcessor!
                var result = await _fileProcessor.ProcessFileAsync(item.FilePath);

                // Update statistics
                lock (_statsLock)
                {
                    _totalProcessed++;
                    if (result.Success)
                    {
                        _totalSuccessful++;
                    }
                    else
                    {
                        _totalFailed++;
                        TrackError(result.ErrorMessage ?? "Unknown error");
                    }
                }

                if (result.Success)
                {
                    // FIX: Mark as successfully processed
                    lock (_trackingLock)
                    {
                        _processedFiles.Add(item.FilePath);
                        _enqueuedFiles.Remove(item.FilePath);

                        // Cleanup old entries if too many (prevent memory leak)
                        if (_processedFiles.Count > 10000)
                        {
                            var cleanupCorrelationId = $"PM{DateTime.Now:HHmmssff}-CLEANUP-{_pipelineName}";
                            _logger.LogInformation("[{CorrelationId}] [QueueMaintenance] Cleaning up processed files tracking (>10000 entries) [{Pipeline}]",
                                cleanupCorrelationId, _pipelineName);
                            _processedFiles.Clear();
                        }
                    }
                }
                else if (ShouldRetry(item))
                {
                    // Schedule retry
                    await ScheduleRetryAsync(item, cancellationToken);
                }
                else
                {
                    // Final failure - remove from tracking
                    lock (_trackingLock)
                    {
                        _enqueuedFiles.Remove(item.FilePath);
                    }

                    _logger.LogError("[{CorrelationId}] [ProcessFailed] Failed to process {FilePath} after {Attempts} attempts: {Error} [{Pipeline}]",
                        itemCorrelationId, item.FilePath, item.AttemptCount, result.ErrorMessage, _pipelineName);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "[{CorrelationId}] [ProcessError] Unexpected error processing {FilePath} [{Pipeline}]",
                    itemCorrelationId, item.FilePath, _pipelineName);

                lock (_statsLock)
                {
                    _totalProcessed++;
                    _totalFailed++;
                    TrackError(ex.Message);
                }

                if (ShouldRetry(item))
                {
                    await ScheduleRetryAsync(item, cancellationToken);
                }
                else
                {
                    // Final failure - remove from tracking
                    lock (_trackingLock)
                    {
                        _enqueuedFiles.Remove(item.FilePath);
                    }

                    _logger.LogError("[{CorrelationId}] [ProcessAbandoned] Failed to process {FilePath} after {Attempts} attempts [{Pipeline}]",
                        itemCorrelationId, item.FilePath, item.AttemptCount, _pipelineName);
                }
            }
            finally
            {
                // Remove from active items
                _activeItems.TryRemove(item.FilePath, out _);

                // Release processing slot
                _processingSlots.Release();
            }
        }

        private bool ShouldRetry(ProcessingItem item)
        {
            return _options.RetryOnFailure &&
                   item.AttemptCount < _options.MaxRetryAttempts;
        }

        private async Task ScheduleRetryAsync(ProcessingItem item, CancellationToken cancellationToken)
        {
            var delay = TimeSpan.FromSeconds(_options.RetryDelaySeconds * item.AttemptCount);
            var retryCorrelationId = $"PM{DateTime.Now:HHmmssff}-RETRY-{_pipelineName}";

            _logger.LogInformation("[{CorrelationId}] [RetryScheduled] Scheduling retry for {FilePath} in {Delay} seconds [{Pipeline}]",
                retryCorrelationId, item.FilePath, delay.TotalSeconds, _pipelineName);

            // Wait before re-enqueueing
            await Task.Delay(delay, cancellationToken);

            if (!cancellationToken.IsCancellationRequested)
            {
                item.StartTime = null; // Reset start time
                _queue.Enqueue(item);
            }
        }

        private void TrackError(string error)
        {
            var category = CategorizeError(error);
            _errorCounts.TryGetValue(category, out var count);
            _errorCounts[category] = count + 1;
        }

        private string CategorizeError(string error)
        {
            if (error.Contains("EXIF", StringComparison.OrdinalIgnoreCase))
                return "EXIF extraction failed";
            if (error.Contains("DICOM", StringComparison.OrdinalIgnoreCase))
                return "DICOM conversion failed";
            if (error.Contains("Patient", StringComparison.OrdinalIgnoreCase))
                return "Patient data missing";
            if (error.Contains("File", StringComparison.OrdinalIgnoreCase))
                return "File access error";
            if (error.Contains("Memory", StringComparison.OrdinalIgnoreCase))
                return "Memory error";
            return "Other error";
        }

        /// <summary>
        /// Processing item with retry tracking
        /// </summary>
        private class ProcessingItem
        {
            public string FilePath { get; }
            public int AttemptCount { get; set; }
            public DateTime? StartTime { get; set; }
            public DateTime EnqueuedTime { get; }

            public ProcessingItem(string filePath)
            {
                FilePath = filePath;
                EnqueuedTime = DateTime.UtcNow;
            }
        }
    }

    // Statistics classes remain the same...
    public class ProcessingStatistics
    {
        public int QueueLength { get; set; }
        public int ActiveCount { get; set; }
        public int TotalProcessed { get; set; }
        public int TotalSuccessful { get; set; }
        public int TotalFailed { get; set; }
        public TimeSpan UpTime { get; set; }
        public double ProcessingRate { get; set; }
        public Dictionary<string, int> TopErrors { get; set; } = new();
    }

    public class ProcessingItemStatus
    {
        public string FilePath { get; set; } = string.Empty;
        public DateTime? StartTime { get; set; }
        public int AttemptCount { get; set; }
        public TimeSpan Duration { get; set; }
    }
}

