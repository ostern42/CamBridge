# CamBridge Sources - INFRASTRUCTURE
# Generated: 2025-06-23 09:56:08
# Version: 0.7.11
# Purpose: Complete source code for project knowledge
# Token-efficient access to all implementations


================================================================================
FILE: src\CamBridge.Infrastructure\GlobalUsings.cs
================================================================================

global using System;
global using System.Collections.Generic;
global using System.IO;
global using System.Linq;
global using System.Text;
global using System.Threading.Tasks;
global using Microsoft.Extensions.Logging;


================================================================================
FILE: src\CamBridge.Infrastructure\ServiceCollectionExtensions.cs
================================================================================

// src/CamBridge.Infrastructure/ServiceCollectionExtensions.cs
// Version: 0.7.20
// Description: DI container configuration - FileProcessor now created per pipeline!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
// using Microsoft.Extensions.Diagnostics.HealthChecks; // Might need this package

namespace CamBridge.Infrastructure
{
    /// <summary>
    /// Extension methods for service registration
    /// PIPELINE UPDATE: FileProcessor no longer registered as singleton!
    /// </summary>
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Adds infrastructure services to the DI container
        /// </summary>
        public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
        {
            // Add configuration
            services.Configure<CamBridgeSettingsV2>(configuration.GetSection("CamBridge"));
            services.Configure<ProcessingOptions>(configuration.GetSection("CamBridge:DefaultProcessingOptions"));

            // Add notification settings (global)
            services.Configure<NotificationSettings>(configuration.GetSection("CamBridge:Notifications"));

            // Register shared services (used by all pipelines)
            services.AddSingleton<ExifToolReader>();
            services.AddSingleton<DicomConverter>();

            // FileProcessor is NO LONGER registered here!
            // It's created per-pipeline in PipelineManager!
            // services.AddSingleton<FileProcessor>(); // REMOVED!

            // Register pipeline manager
            services.AddSingleton<PipelineManager>();

            // Register notification service (v0.7.18: Direct class, no interface!)
            services.AddSingleton<NotificationService>();

            // Register remaining interfaces (only 2 left!)
            services.AddSingleton<IMappingConfiguration, MappingConfigurationLoader>();
            services.AddSingleton<IDicomTagMapper, DicomTagMapper>();

            return services;
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: src\CamBridge.Infrastructure\obj\Release\net8.0\CamBridge.Infrastructure.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("CamBridge.Infrastructure.Tests")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.7.30.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.7.30+bb6c6b0cc9dbd04b818eea63b09a9eb46ee0d1e3")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Infrastructure")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.7.30.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Infrastructure\obj\x64\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: src\CamBridge.Infrastructure\obj\x64\Release\net8.0\CamBridge.Infrastructure.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("CamBridge.Infrastructure.Tests")]
[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.7.30.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.7.30+bb6c6b0cc9dbd04b818eea63b09a9eb46ee0d1e3")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Infrastructure")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.7.30.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Infrastructure\Services\DicomConverter.cs
================================================================================

// src/CamBridge.Infrastructure/Services/DicomConverter.cs
// Version: 0.7.30
// Description: DICOM converter with FIXED JPEG encapsulation by creating dataset with transfer syntax
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Runtime.Versioning;
using System.Threading.Tasks;
using CamBridge.Core.Entities;
using CamBridge.Core.Interfaces;
using FellowOakDicom;
using FellowOakDicom.Imaging;
using FellowOakDicom.IO.Buffer;
using Microsoft.Extensions.Logging;
using DicomTag = FellowOakDicom.DicomTag;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// DICOM converter using fo-dicom library
    /// Converts JPEG images to DICOM format while preserving JPEG compression
    /// v0.7.30: FIXED JPEG encapsulation by creating dataset with transfer syntax
    /// </summary>
    [SupportedOSPlatform("windows")]
    public class DicomConverter
    {
        private readonly ILogger<DicomConverter> _logger;
        private readonly IDicomTagMapper? _tagMapper;
        private readonly IMappingConfiguration? _mappingConfiguration;

        private const string PHOTOGRAPHIC_SOP_CLASS_UID = "1.2.840.10008.5.1.4.1.1.77.1.4";
        private const string JPEG_BASELINE_TRANSFER_SYNTAX_UID = "1.2.840.10008.1.2.4.50";

        // Implementation Class UID prefix for CamBridge
        private const string IMPLEMENTATION_CLASS_UID = "1.2.276.0.7230010.3.0.3.6.4";
        private const string IMPLEMENTATION_VERSION_NAME = "CAMBRIDGE_001";

        // Constructor for backward compatibility
        public DicomConverter(ILogger<DicomConverter> logger)
            : this(logger, null, null)
        {
        }

        // New constructor with dependency injection
        public DicomConverter(
            ILogger<DicomConverter> logger,
            IDicomTagMapper? tagMapper,
            IMappingConfiguration? mappingConfiguration)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _tagMapper = tagMapper;
            _mappingConfiguration = mappingConfiguration;
        }

        /// <summary>
        /// Converts a JPEG file to DICOM using the provided metadata
        /// </summary>
        public async Task<ConversionResult> ConvertToDicomAsync(
            string sourceJpegPath,
            string destinationDicomPath,
            ImageMetadata metadata)
        {
            try
            {
                _logger.LogInformation("Converting JPEG to DICOM: {Source} â†’ {Destination}",
                    sourceJpegPath, destinationDicomPath);

                // Validate inputs
                if (!File.Exists(sourceJpegPath))
                {
                    return ConversionResult.CreateFailure($"Source file not found: {sourceJpegPath}");
                }

                // Load JPEG data
                var jpegData = await File.ReadAllBytesAsync(sourceJpegPath);

                // Create DICOM dataset
                var dataset = CreateDicomDataset(metadata, jpegData);

                // Map custom tags if mapper is available
                if (_tagMapper != null && _mappingConfiguration != null)
                {
                    var mappingRules = _mappingConfiguration.GetMappingRules();

                    if (mappingRules.Any())
                    {
                        _tagMapper.MapToDataset(dataset, metadata.ExifData, mappingRules);
                    }
                }

                // Create DICOM file with correct structure
                var dicomFile = new DicomFile(dataset);

                // CRITICAL FIX: Set Transfer Syntax on FileMetaInfo!
                dicomFile.FileMetaInfo.TransferSyntax = DicomTransferSyntax.JPEGProcess1;

                // Also ensure File Meta Information has required tags
                dicomFile.FileMetaInfo.MediaStorageSOPClassUID = dataset.GetSingleValue<DicomUID>(DicomTag.SOPClassUID);
                dicomFile.FileMetaInfo.MediaStorageSOPInstanceUID = dataset.GetSingleValue<DicomUID>(DicomTag.SOPInstanceUID);
                dicomFile.FileMetaInfo.ImplementationClassUID = DicomUID.Parse(IMPLEMENTATION_CLASS_UID);
                dicomFile.FileMetaInfo.ImplementationVersionName = IMPLEMENTATION_VERSION_NAME;

                // Ensure output directory exists
                var outputDir = Path.GetDirectoryName(destinationDicomPath);
                if (!string.IsNullOrEmpty(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }

                // Save DICOM file - fo-dicom should handle undefined length automatically
                // when dataset has JPEG transfer syntax
                await dicomFile.SaveAsync(destinationDicomPath);

                var fileInfo = new FileInfo(destinationDicomPath);
                var sopInstanceUid = dataset.GetSingleValue<string>(DicomTag.SOPInstanceUID);

                _logger.LogInformation("Successfully created DICOM file: {Path} ({Size} bytes, Transfer Syntax: {TransferSyntax})",
                    destinationDicomPath, fileInfo.Length, dicomFile.FileMetaInfo.TransferSyntax.UID.UID);

                return ConversionResult.CreateSuccess(destinationDicomPath, sopInstanceUid, fileInfo.Length);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to convert JPEG to DICOM");
                return ConversionResult.CreateFailure($"Conversion failed: {ex.Message}");
            }
        }

        /// <summary>
        /// Validates if the generated DICOM file is compliant
        /// </summary>
        public async Task<ValidationResult> ValidateDicomFileAsync(string dicomFilePath)
        {
            try
            {
                if (!File.Exists(dicomFilePath))
                {
                    return ValidationResult.Invalid($"DICOM file not found: {dicomFilePath}");
                }

                // Load DICOM file for validation
                var dicomFile = await DicomFile.OpenAsync(dicomFilePath);
                var dataset = dicomFile.Dataset;

                var errors = new List<string>();
                var warnings = new List<string>();

                // Validate required tags
                ValidateRequiredTags(dataset, errors);

                // Validate image module
                ValidateImageModule(dataset, warnings);

                // Validate patient module
                ValidatePatientModule(dataset, warnings);

                // Validate study module
                ValidateStudyModule(dataset, warnings);

                // Check Transfer Syntax
                if (dicomFile.FileMetaInfo.TransferSyntax?.UID.UID != JPEG_BASELINE_TRANSFER_SYNTAX_UID)
                {
                    warnings.Add($"Transfer Syntax is not JPEG Baseline: {dicomFile.FileMetaInfo.TransferSyntax?.UID.UID}");
                }

                if (errors.Count > 0)
                {
                    return new ValidationResult
                    {
                        IsValid = false,
                        Errors = errors,
                        Warnings = warnings
                    };
                }

                return new ValidationResult
                {
                    IsValid = true,
                    Warnings = warnings
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to validate DICOM file");
                return ValidationResult.Invalid($"Validation failed: {ex.Message}");
            }
        }

        /// <summary>
        /// Gets the SOP Class UID for photographic images
        /// </summary>
        public string GetPhotographicSopClassUid()
        {
            return PHOTOGRAPHIC_SOP_CLASS_UID;
        }

        private DicomDataset CreateDicomDataset(ImageMetadata metadata, byte[] jpegData)
        {
            // CRITICAL: Create dataset WITH transfer syntax for proper encoding!
            var dataset = new DicomDataset(DicomTransferSyntax.JPEGProcess1);

            // Set proper character encoding for German umlauts
            dataset.Add(DicomTag.SpecificCharacterSet, "ISO_IR 192"); // UTF-8

            // SOP Common Module
            dataset.Add(DicomTag.SOPClassUID, PHOTOGRAPHIC_SOP_CLASS_UID);
            dataset.Add(DicomTag.SOPInstanceUID, GenerateUID());

            // General Study Module
            dataset.Add(DicomTag.StudyInstanceUID, GenerateUID());
            dataset.Add(DicomTag.StudyDate, metadata.Study.StudyDate.ToString("yyyyMMdd"));
            dataset.Add(DicomTag.StudyTime, metadata.Study.StudyDate.ToString("HHmmss"));
            dataset.Add(DicomTag.StudyID, metadata.Study.StudyId.Value);
            dataset.Add(DicomTag.AccessionNumber, metadata.Study.AccessionNumber ?? "");
            dataset.Add(DicomTag.StudyDescription, metadata.Study.Description ?? "Photographic Image");
            dataset.Add(DicomTag.ReferringPhysicianName, metadata.Study.ReferringPhysician ?? "");

            // Patient Module
            dataset.Add(DicomTag.PatientName, metadata.Patient.Name);
            dataset.Add(DicomTag.PatientID, metadata.Patient.Id.Value);

            if (metadata.Patient.BirthDate.HasValue)
            {
                dataset.Add(DicomTag.PatientBirthDate, metadata.Patient.BirthDate.Value.ToString("yyyyMMdd"));
            }

            // Gender is NOT nullable - it's an enum!
            dataset.Add(DicomTag.PatientSex, GetDicomGender(metadata.Patient.Gender));

            // General Series Module
            dataset.Add(DicomTag.SeriesInstanceUID, GenerateUID());
            dataset.Add(DicomTag.SeriesNumber, "1");
            dataset.Add(DicomTag.SeriesDate, metadata.Study.StudyDate.ToString("yyyyMMdd"));
            dataset.Add(DicomTag.SeriesTime, metadata.Study.StudyDate.ToString("HHmmss"));
            dataset.Add(DicomTag.SeriesDescription, "Photographic Series");
            dataset.Add(DicomTag.Modality, "XC"); // Photographic Image

            // General Equipment Module - Use EXIF data if available
            dataset.Add(DicomTag.Manufacturer, metadata.ExifData.GetValueOrDefault("Make", "Unknown"));
            dataset.Add(DicomTag.ManufacturerModelName, metadata.ExifData.GetValueOrDefault("Model", "Unknown"));
            dataset.Add(DicomTag.DeviceSerialNumber, metadata.ExifData.GetValueOrDefault("SerialNumber", ""));
            dataset.Add(DicomTag.SoftwareVersions, IMPLEMENTATION_VERSION_NAME);

            // SC Equipment Module
            dataset.Add(DicomTag.ConversionType, "WSD"); // Workstation
            dataset.Add(DicomTag.SecondaryCaptureDeviceID, "CamBridge");
            dataset.Add(DicomTag.SecondaryCaptureDeviceManufacturer, "Claude's Improbably Reliable Software Solutions");
            dataset.Add(DicomTag.SecondaryCaptureDeviceManufacturerModelName, "CamBridge JPEG to DICOM Converter");
            dataset.Add(DicomTag.SecondaryCaptureDeviceSoftwareVersions, IMPLEMENTATION_VERSION_NAME);

            // General Image Module
            dataset.Add(DicomTag.InstanceNumber, metadata.InstanceNumber.ToString());
            dataset.Add(DicomTag.PatientOrientation, "");
            dataset.Add(DicomTag.ContentDate, metadata.Study.StudyDate.ToString("yyyyMMdd"));
            dataset.Add(DicomTag.ContentTime, metadata.Study.StudyDate.ToString("HHmmss"));
            dataset.Add(DicomTag.ImageType, "ORIGINAL\\PRIMARY");

            // Image Pixel Module
            AddImagePixelData(dataset, jpegData);

            // Implementation-specific tags
            dataset.Add(DicomTag.ImplementationClassUID, IMPLEMENTATION_CLASS_UID);
            dataset.Add(DicomTag.ImplementationVersionName, IMPLEMENTATION_VERSION_NAME);

            // Add comment with source file name if available
            var fileName = Path.GetFileName(metadata.SourceFilePath);
            var comment = $"Source: {fileName}";
            if (!string.IsNullOrEmpty(metadata.Study.Description))
            {
                comment += $" | {metadata.Study.Description}";
            }
            dataset.Add(DicomTag.ImageComments, comment);

            return dataset;
        }

        private void AddImagePixelData(DicomDataset dataset, byte[] jpegData)
        {
            // Read JPEG to get dimensions
            using (var ms = new MemoryStream(jpegData))
            using (var image = Image.FromStream(ms))
            {
                dataset.Add(DicomTag.Columns, (ushort)image.Width);
                dataset.Add(DicomTag.Rows, (ushort)image.Height);

                // FIXED: Set correct photometric interpretation for JPEG
                // YBR_FULL_422 is the standard for JPEG compressed images
                dataset.Add(DicomTag.PhotometricInterpretation, "YBR_FULL_422");

                // For JPEG, samples per pixel is typically 3 (color)
                dataset.Add(DicomTag.SamplesPerPixel, (ushort)3);
                dataset.Add(DicomTag.BitsAllocated, (ushort)8);
                dataset.Add(DicomTag.BitsStored, (ushort)8);
                dataset.Add(DicomTag.HighBit, (ushort)7);
                dataset.Add(DicomTag.PixelRepresentation, (ushort)0);

                // Planar configuration is 0 for JPEG (interleaved)
                dataset.Add(DicomTag.PlanarConfiguration, (ushort)0);
            }

            // Add encapsulated JPEG data
            var pixelData = DicomPixelData.Create(dataset, true); // true = encapsulated
            var buffer = new MemoryByteBuffer(jpegData);
            pixelData.AddFrame(buffer);
        }

        private void ValidateRequiredTags(DicomDataset dataset, List<string> errors)
        {
            var requiredTags = new[]
            {
                DicomTag.SOPClassUID,
                DicomTag.SOPInstanceUID,
                DicomTag.StudyInstanceUID,
                DicomTag.SeriesInstanceUID,
                DicomTag.PatientID,
                DicomTag.PatientName,
                DicomTag.Columns,
                DicomTag.Rows,
                DicomTag.BitsAllocated,
                DicomTag.BitsStored,
                DicomTag.HighBit,
                DicomTag.PixelRepresentation,
                DicomTag.PhotometricInterpretation,
                DicomTag.SamplesPerPixel
            };

            foreach (var tag in requiredTags)
            {
                if (!dataset.Contains(tag))
                {
                    errors.Add($"Required tag {tag} is missing");
                }
            }
        }

        private void ValidateImageModule(DicomDataset dataset, List<string> warnings)
        {
            if (!dataset.Contains(DicomTag.PixelData))
            {
                warnings.Add("No pixel data found");
            }

            // Check for JPEG compression indicators
            if (dataset.TryGetString(DicomTag.PhotometricInterpretation, out var photometric))
            {
                if (photometric != "YBR_FULL_422" && photometric != "YBR_FULL")
                {
                    warnings.Add($"Photometric Interpretation '{photometric}' may not be optimal for JPEG");
                }
            }
        }

        private void ValidatePatientModule(DicomDataset dataset, List<string> warnings)
        {
            if (!dataset.Contains(DicomTag.PatientBirthDate))
            {
                warnings.Add("Patient birth date is missing");
            }

            if (!dataset.Contains(DicomTag.PatientSex))
            {
                warnings.Add("Patient sex is missing");
            }
        }

        private void ValidateStudyModule(DicomDataset dataset, List<string> warnings)
        {
            if (!dataset.Contains(DicomTag.StudyDescription))
            {
                warnings.Add("Study description is missing");
            }

            if (!dataset.Contains(DicomTag.AccessionNumber))
            {
                warnings.Add("Accession number is missing");
            }
        }

        private string GenerateUID()
        {
            // Generate unique UID with our implementation prefix
            // DICOM UIDs: max 64 chars, only digits (0-9) and dots (.)

            // Our prefix is already 27 chars: "1.2.276.0.7230010.3.0.3.6.4"
            // That leaves us 37 chars for uniqueness

            var timestamp = DateTime.UtcNow;
            var ticks = timestamp.Ticks;

            // Use only last 10 digits of ticks to save space
            var shortTicks = (ticks % 10000000000).ToString();

            // Random component (4 digits)
            var random = new Random().Next(1000, 9999);

            // Process ID for additional uniqueness (last 4 digits)
            var processId = (Environment.ProcessId % 10000).ToString();

            // Format: <prefix>.<short_ticks>.<process_id>.<random>
            // Example: 1.2.276.0.7230010.3.0.3.6.4.1847714048.1234.5678
            var uid = $"{IMPLEMENTATION_CLASS_UID}.{shortTicks}.{processId}.{random}";

            // Safety check
            if (uid.Length > 64)
            {
                _logger.LogWarning("Generated UID too long ({Length} chars), truncating: {UID}",
                    uid.Length, uid);
                uid = uid.Substring(0, 64);
            }

            return uid;
        }

        private string GetDicomGender(Gender gender)
        {
            return gender switch
            {
                Gender.Male => "M",
                Gender.Female => "F",
                Gender.Other => "O",
                _ => ""
            };
        }
    }

    /// <summary>
    /// Result of DICOM conversion operation
    /// </summary>
    public class ConversionResult
    {
        public bool Success { get; init; }
        public string? DicomFilePath { get; init; }
        public string? ErrorMessage { get; init; }
        public string? SopInstanceUid { get; init; }
        public long FileSizeBytes { get; init; }

        public static ConversionResult CreateSuccess(string filePath, string sopInstanceUid, long fileSize)
            => new()
            {
                Success = true,
                DicomFilePath = filePath,
                SopInstanceUid = sopInstanceUid,
                FileSizeBytes = fileSize
            };

        public static ConversionResult CreateFailure(string error)
            => new() { Success = false, ErrorMessage = error };
    }

    /// <summary>
    /// Result of DICOM validation
    /// </summary>
    public class ValidationResult
    {
        public bool IsValid { get; init; }
        public List<string> Errors { get; init; } = new();
        public List<string> Warnings { get; init; } = new();

        public static ValidationResult Valid()
            => new() { IsValid = true };

        public static ValidationResult Invalid(params string[] errors)
            => new() { IsValid = false, Errors = errors.ToList() };
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\DicomTagMapper.cs
================================================================================

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Extensions.Logging;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using FellowOakDicom;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Service responsible for mapping values to DICOM tags according to mapping rules
    /// </summary>
    public class DicomTagMapper : IDicomTagMapper
    {
        private readonly ILogger<DicomTagMapper> _logger;

        public DicomTagMapper(ILogger<DicomTagMapper> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Applies a mapping rule to transform a value
        /// </summary>
        public string? ApplyTransform(string? value, string? transform)
        {
            if (string.IsNullOrEmpty(value) || string.IsNullOrEmpty(transform) || transform == "None")
            {
                return value;
            }

            // Parse transform string to enum
            if (!Enum.TryParse<ValueTransform>(transform, out var transformEnum))
            {
                _logger.LogWarning("Unknown transform: {Transform}", transform);
                return value;
            }

            try
            {
                return transformEnum switch
                {
                    ValueTransform.DateToDicom => ConvertDateToDicom(value),
                    ValueTransform.TimeToDicom => ConvertTimeToDicom(value),
                    ValueTransform.DateTimeToDicom => ConvertDateTimeToDicom(value),
                    ValueTransform.MapGender => MapGenderCode(value),
                    ValueTransform.RemovePrefix => RemovePrefix(value),
                    ValueTransform.ExtractDate => ExtractDate(value),
                    ValueTransform.ExtractTime => ExtractTime(value),
                    ValueTransform.ToUpperCase => value.ToUpperInvariant(),
                    ValueTransform.ToLowerCase => value.ToLowerInvariant(),
                    ValueTransform.Trim => value.Trim(),
                    _ => value
                };
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to apply transform {Transform} to value '{Value}'", transform, value);
                return value;
            }
        }

        private string ConvertDateToDicom(string date)
        {
            // Convert various date formats to DICOM format (YYYYMMDD)
            if (DateTime.TryParse(date, out var dt))
            {
                return dt.ToString("yyyyMMdd");
            }

            // Already in DICOM format?
            if (date.Length == 8 && int.TryParse(date, out _))
            {
                return date;
            }

            _logger.LogWarning("Unable to convert date '{Date}' to DICOM format", date);
            return date;
        }

        private string ConvertTimeToDicom(string time)
        {
            // Convert various time formats to DICOM format (HHMMSS)
            if (DateTime.TryParse(time, out var dt))
            {
                return dt.ToString("HHmmss");
            }

            if (TimeSpan.TryParse(time, out var ts))
            {
                return $"{ts.Hours:D2}{ts.Minutes:D2}{ts.Seconds:D2}";
            }

            _logger.LogWarning("Unable to convert time '{Time}' to DICOM format", time);
            return time;
        }

        private string ConvertDateTimeToDicom(string dateTime)
        {
            if (DateTime.TryParse(dateTime, out var dt))
            {
                return dt.ToString("yyyyMMddHHmmss");
            }

            _logger.LogWarning("Unable to convert datetime '{DateTime}' to DICOM format", dateTime);
            return dateTime;
        }

        /// <summary>
        /// Maps source data to a DICOM dataset using mapping rules
        /// </summary>
        public void MapToDataset(DicomDataset dataset, Dictionary<string, string> sourceData, IEnumerable<MappingRule> mappingRules)
        {
            if (dataset == null) throw new ArgumentNullException(nameof(dataset));
            if (sourceData == null) throw new ArgumentNullException(nameof(sourceData));
            if (mappingRules == null) throw new ArgumentNullException(nameof(mappingRules));

            foreach (var rule in mappingRules)
            {
                try
                {
                    // Get source value
                    if (!sourceData.TryGetValue(rule.SourceField, out var sourceValue))
                    {
                        if (rule.Required)
                        {
                            _logger.LogWarning("Required source field '{Field}' not found in data", rule.SourceField);
                        }

                        // Use default value if available
                        sourceValue = rule.DefaultValue;

                        if (string.IsNullOrEmpty(sourceValue))
                        {
                            continue;
                        }
                    }

                    // Apply transform if specified
                    var transformedValue = ApplyTransform(sourceValue, rule.Transform);

                    if (string.IsNullOrEmpty(transformedValue) && rule.Required)
                    {
                        _logger.LogWarning("Required field '{Field}' resulted in empty value after transform", rule.SourceField);
                    }

                    // Parse DICOM tag
                    if (!TryParseDicomTag(rule.DicomTag, out var group, out var element))
                    {
                        _logger.LogError("Invalid DICOM tag format: {Tag}", rule.DicomTag);
                        continue;
                    }

                    // Add to dataset
                    var tag = new DicomTag(group, element);

                    if (!string.IsNullOrEmpty(transformedValue))
                    {
                        dataset.AddOrUpdate(tag, transformedValue);
                        _logger.LogDebug("Mapped {Source} -> {Tag}: {Value}",
                            rule.SourceField, rule.DicomTag, transformedValue);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error mapping rule {Source} -> {Tag}",
                        rule.SourceField, rule.DicomTag);
                }
            }
        }

        /// <summary>
        /// Parses a DICOM tag string like "(0010,0010)" into group and element
        /// </summary>
        private bool TryParseDicomTag(string tagString, out ushort group, out ushort element)
        {
            group = 0;
            element = 0;

            if (string.IsNullOrEmpty(tagString))
                return false;

            // Remove parentheses and spaces
            var cleaned = tagString.Trim('(', ')', ' ');
            var parts = cleaned.Split(',');

            if (parts.Length != 2)
                return false;

            try
            {
                group = Convert.ToUInt16(parts[0].Trim(), 16);
                element = Convert.ToUInt16(parts[1].Trim(), 16);
                return true;
            }
            catch
            {
                return false;
            }
        }

        private string MapGenderCode(string gender)
        {
            return gender?.ToUpperInvariant() switch
            {
                "M" or "MALE" => "M",
                "F" or "FEMALE" => "F",
                "O" or "OTHER" => "O",
                _ => ""
            };
        }

        private string RemovePrefix(string value)
        {
            // Remove common prefixes like "GCM_TAG"
            if (value.StartsWith("GCM_TAG", StringComparison.OrdinalIgnoreCase))
            {
                return value.Substring(7).Trim();
            }

            return value;
        }

        private string ExtractDate(string dateTime)
        {
            if (DateTime.TryParse(dateTime, out var dt))
            {
                return dt.ToString("yyyyMMdd");
            }

            return dateTime;
        }

        private string ExtractTime(string dateTime)
        {
            if (DateTime.TryParse(dateTime, out var dt))
            {
                return dt.ToString("HHmmss");
            }

            return dateTime;
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\ExifToolReader.cs
================================================================================

// src/CamBridge.Infrastructure/Services/ExifToolReader.cs
// Version: 0.7.28
// Description: EXIF metadata reader with corrected log levels
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core.Entities;
using CamBridge.Core.ValueObjects;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Reads EXIF metadata from JPEG files using ExifTool
    /// Specifically handles Ricoh G900SE II barcode field
    /// </summary>
    public class ExifToolReader
    {
        private readonly ILogger<ExifToolReader> _logger;
        private readonly string _exifToolPath;
        private readonly int _timeoutMs;

        /// <summary>
        /// Creates a new ExifToolReader instance
        /// This constructor matches what ServiceCollectionExtensions expects
        /// </summary>
        /// <param name="logger">Logger for diagnostics</param>
        /// <param name="timeoutMs">Timeout for ExifTool execution in milliseconds</param>
        public ExifToolReader(ILogger<ExifToolReader> logger, int timeoutMs = 15000) // Increased default timeout
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _timeoutMs = timeoutMs;

            // Ensure Windows-1252 encoding is available (for Ricoh cameras)
            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);

            // Try to find ExifTool in various locations
            var possiblePaths = new[]
            {
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Tools", "exiftool.exe"),
                Path.Combine(Directory.GetCurrentDirectory(), "Tools", "exiftool.exe"),
                @"Tools\exiftool.exe",
                @"C:\Tools\exiftool.exe"
            };

            foreach (var path in possiblePaths)
            {
                if (File.Exists(path))
                {
                    _exifToolPath = path;
                    // Changed to DEBUG - tool location is technical detail
                    _logger.LogDebug("Found ExifTool at: {Path}", path);
                    break;
                }
            }

            if (string.IsNullOrEmpty(_exifToolPath))
            {
                // CRITICAL - without ExifTool, service cannot function!
                _logger.LogCritical("ExifTool not found in any expected location - cannot process any files!");
                throw new FileNotFoundException("ExifTool not found in any expected location");
            }
        }

        /// <summary>
        /// Extracts complete metadata from a JPEG file
        /// This method name matches what FileProcessor expects
        /// </summary>
        public async Task<ImageMetadata> ExtractMetadataAsync(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException($"File not found: {filePath}");
            }

            _logger.LogDebug("Extracting metadata from: {FilePath}", filePath);

            try
            {
                // Run ExifTool and get all EXIF data
                var output = await RunExifToolAsync(filePath);
                var exifData = ParseExifToolOutput(output);

                // Log what we found - keep as INFO for business-relevant barcode data
                if (exifData.TryGetValue("Barcode", out var barcode))
                {
                    _logger.LogInformation("Found Ricoh barcode data: '{Barcode}'", barcode);
                }
                if (exifData.TryGetValue("UserComment", out var userComment))
                {
                    _logger.LogDebug("UserComment field: '{UserComment}'", userComment);
                }

                // Look for QRBridge data in the Barcode field (Ricoh-specific)
                string? barcodeData = null;
                if (exifData.TryGetValue("Barcode", out var barcodeValue))
                {
                    barcodeData = barcodeValue;
                    _logger.LogDebug("Found barcode data in Barcode field: '{BarcodeData}'", barcodeData);
                }
                else if (exifData.TryGetValue("UserComment", out var userCommentValue) &&
                         userCommentValue != "GCM_TAG" &&
                         userCommentValue.Contains("|"))
                {
                    // Fallback to UserComment if it contains pipe-delimited data
                    barcodeData = userCommentValue;
                    _logger.LogDebug("Found barcode data in UserComment field: '{BarcodeData}'", barcodeData);
                }
                else
                {
                    _logger.LogWarning("No barcode data found in EXIF");
                }

                // Parse patient and study info from barcode
                PatientInfo patientInfo;
                StudyInfo studyInfo;

                if (!string.IsNullOrEmpty(barcodeData))
                {
                    (patientInfo, studyInfo) = ParseBarcodeData(barcodeData);
                }
                else
                {
                    (patientInfo, studyInfo) = CreateDefaultPatientAndStudy();
                }

                // Extract technical data
                var technicalData = new ImageTechnicalData
                {
                    ImageWidth = GetIntValue(exifData, "ImageWidth", "ExifImageWidth"),
                    ImageHeight = GetIntValue(exifData, "ImageHeight", "ExifImageHeight"),
                    BitsPerSample = GetIntValue(exifData, "BitsPerSample") ?? 8,
                    ColorSpace = exifData.GetValueOrDefault("ColorSpace", "RGB"),
                    Manufacturer = exifData.GetValueOrDefault("Make", "Unknown"),
                    Model = exifData.GetValueOrDefault("Model", "Unknown"),
                    Software = exifData.GetValueOrDefault("Software", "Unknown"),
                    Compression = exifData.GetValueOrDefault("Compression"),
                    Orientation = GetIntValue(exifData, "Orientation")
                };

                // Get capture date/time
                var captureDateTime = GetDateTime(exifData, "DateTimeOriginal", "CreateDate", "DateTime") ?? DateTime.Now;

                // Generate instance UID
                var instanceUid = GenerateUid();

                // Create and return metadata using the proper constructor
                return new ImageMetadata(
                    sourceFilePath: filePath,
                    captureDateTime: captureDateTime,
                    patient: patientInfo,
                    study: studyInfo,
                    technicalData: technicalData,
                    userComment: exifData.GetValueOrDefault("UserComment"),
                    barcodeData: barcodeData,
                    instanceNumber: 1,
                    instanceUid: instanceUid,
                    exifData: new Dictionary<string, string>(exifData) // Create a copy to ensure no issues
                );
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to extract metadata from {FilePath}", filePath);
                throw new InvalidOperationException($"Failed to extract metadata from {filePath}: {ex.Message}", ex);
            }
        }

        private async Task<string> RunExifToolAsync(string filePath)
        {
            var startInfo = new ProcessStartInfo
            {
                FileName = _exifToolPath,
                Arguments = $"-s -a -u \"{filePath}\"", // Simple arguments
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true,
                StandardOutputEncoding = Encoding.GetEncoding(1252) // Windows-1252 for Ricoh
            };

            using var process = new Process { StartInfo = startInfo };
            using var cts = new CancellationTokenSource(_timeoutMs);

            // Use StringBuilder for simple collection
            var outputBuilder = new StringBuilder();
            var errorBuilder = new StringBuilder();

            // FIX: Proper event handlers for both output and error
            process.OutputDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                    outputBuilder.AppendLine(e.Data);
            };

            process.ErrorDataReceived += (sender, e) =>
            {
                if (e.Data != null)
                    errorBuilder.AppendLine(e.Data);
            };

            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            try
            {
                await process.WaitForExitAsync(cts.Token);
            }
            catch (OperationCanceledException)
            {
                try
                {
                    process.Kill();
                }
                catch { }
                throw new TimeoutException($"ExifTool timed out after {_timeoutMs}ms");
            }

            if (process.ExitCode != 0)
            {
                var error = errorBuilder.ToString();
                _logger.LogWarning("ExifTool returned exit code {ExitCode}. Error: {Error}",
                    process.ExitCode, error);
            }

            return outputBuilder.ToString();
        }

        private Dictionary<string, string> ParseExifToolOutput(string output)
        {
            var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            if (string.IsNullOrWhiteSpace(output))
                return result;

            var lines = output.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);

            foreach (var line in lines)
            {
                var colonIndex = line.IndexOf(':');
                if (colonIndex > 0 && colonIndex < line.Length - 1)
                {
                    var key = line.Substring(0, colonIndex).Trim();
                    var value = line.Substring(colonIndex + 1).Trim();

                    if (!string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
                    {
                        // Skip keys that are just encoding artifacts
                        if (key.Length == 1 && (key[0] == '\uFFFD' || key[0] < 32 || key[0] > 126))
                        {
                            _logger.LogDebug("Skipping invalid key: {Key} (char code: {Code})", key, (int)key[0]);
                            continue;
                        }

                        // Handle duplicate keys by making them unique
                        var finalKey = key;
                        var counter = 1;
                        while (result.ContainsKey(finalKey))
                        {
                            finalKey = $"{key}_{counter}";
                            counter++;
                            _logger.LogDebug("Duplicate key found: {Key}, renamed to: {FinalKey}", key, finalKey);
                        }

                        result[finalKey] = value;
                    }
                }
            }

            return result;
        }

        private (PatientInfo, StudyInfo) ParseBarcodeData(string barcodeData)
        {
            if (string.IsNullOrWhiteSpace(barcodeData))
            {
                _logger.LogWarning("Barcode data is empty or null");
                return CreateDefaultPatientAndStudy();
            }

            _logger.LogDebug("Parsing barcode data: '{BarcodeData}'", barcodeData);

            var parts = barcodeData.Split('|');

            // QRBridge format validation
            if (parts.Length < 3)
            {
                _logger.LogWarning("Invalid barcode format. Expected at least 3 fields, got {Count}", parts.Length);
                return CreateDefaultPatientAndStudy();
            }

            // Log each field for debugging
            for (int i = 0; i < parts.Length; i++)
            {
                _logger.LogDebug("Barcode field [{Index}]: '{Value}'", i, parts[i]);
            }

            try
            {
                // Parse patient info
                var examId = parts[0].Trim();
                var patientName = parts[1].Trim();

                // Parse birth date - handle various formats
                DateTime? birthDate = null;
                if (parts.Length > 2 && !string.IsNullOrWhiteSpace(parts[2]))
                {
                    var dateStr = parts[2].Trim();
                    if (DateTime.TryParseExact(dateStr, "yyyy-MM-dd", null, DateTimeStyles.None, out var date1))
                        birthDate = date1;
                    else if (DateTime.TryParseExact(dateStr, "dd.MM.yyyy", null, DateTimeStyles.None, out var date2))
                        birthDate = date2;
                    else if (DateTime.TryParse(dateStr, out var date3))
                        birthDate = date3;
                    else
                        _logger.LogWarning("Could not parse birth date: '{DateStr}'", dateStr);
                }

                // Parse gender
                Gender gender = Gender.Other;
                if (parts.Length > 3 && !string.IsNullOrWhiteSpace(parts[3]))
                {
                    var genderStr = parts[3].Trim().ToUpperInvariant();
                    gender = genderStr switch
                    {
                        "M" => Gender.Male,
                        "F" => Gender.Female,
                        "W" => Gender.Female, // German: Weiblich
                        _ => Gender.Other
                    };
                }

                // Parse study description
                string? studyDescription = null;
                if (parts.Length > 4 && !string.IsNullOrWhiteSpace(parts[4]))
                {
                    studyDescription = parts[4].Trim();
                }

                // Create patient info
                var patientInfo = new PatientInfo(
                    id: new PatientId(examId),
                    name: patientName,
                    birthDate: birthDate,
                    gender: gender
                );

                // Create study info - FIX for 16 char limit!
                var studyIdValue = examId.Length > 14 ? examId.Substring(0, 14) : examId;
                var studyInfo = new StudyInfo(
                    studyId: new StudyId($"S{studyIdValue}"), // Max 16 chars total
                    examId: examId,
                    description: studyDescription ?? "Clinical Photography",
                    modality: "VL", // Visible Light photography
                    studyDate: DateTime.Now
                );

                // Keep as INFO - successfully parsed patient data is business-relevant
                _logger.LogInformation("Successfully parsed barcode: ExamId={ExamId}, Patient={PatientName}, Study={StudyDescription}",
                    examId, patientName, studyDescription);

                return (patientInfo, studyInfo);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error parsing barcode data");
                return CreateDefaultPatientAndStudy();
            }
        }

        private (PatientInfo, StudyInfo) CreateDefaultPatientAndStudy()
        {
            var timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
            var shortTimestamp = DateTime.Now.ToString("MMddHHmm"); // Shorter for StudyId

            var patientInfo = new PatientInfo(
                id: new PatientId($"AUTO_{timestamp}"),
                name: "Unknown Patient",
                birthDate: null,
                gender: Gender.Other
            );

            var studyInfo = new StudyInfo(
                studyId: new StudyId($"S{shortTimestamp}"), // Max 16 chars
                examId: $"AUTO_{timestamp}",
                description: "Unidentified Clinical Photography",
                modality: "VL",
                studyDate: DateTime.Now
            );

            _logger.LogWarning("Created default patient/study info with ID: AUTO_{Timestamp}", timestamp);

            return (patientInfo, studyInfo);
        }

        private int? GetIntValue(Dictionary<string, string> exifData, params string[] keys)
        {
            foreach (var key in keys)
            {
                if (exifData.TryGetValue(key, out var value))
                {
                    // Handle values like "8 8 8" for BitsPerSample
                    var firstValue = value.Split(' ')[0];

                    if (int.TryParse(firstValue, out var result))
                        return result;
                }
            }
            return null;
        }

        private DateTime? GetDateTime(Dictionary<string, string> exifData, params string[] keys)
        {
            foreach (var key in keys)
            {
                if (exifData.TryGetValue(key, out var value))
                {
                    // EXIF datetime format: "yyyy:MM:dd HH:mm:ss"
                    if (DateTime.TryParseExact(value, "yyyy:MM:dd HH:mm:ss",
                        CultureInfo.InvariantCulture, DateTimeStyles.None, out var result))
                        return result;

                    // Try standard parse as fallback
                    if (DateTime.TryParse(value, out result))
                        return result;
                }
            }
            return null;
        }

        private string GenerateUid()
        {
            // Simple UID generation - in production use proper DICOM UID generation
            return $"1.2.826.0.1.3680043.8.498.{DateTime.Now.Ticks}";
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\FileProcessor.cs
================================================================================

// src/CamBridge.Infrastructure/Services/FileProcessor.cs
// Version: 0.7.29
// Description: Pipeline-aware file processor with FIXED DICOM output handling
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.Entities;
using CamBridge.Core.Interfaces;
using CamBridge.Core.ValueObjects;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Orchestrates the complete JPEG to DICOM conversion process for a specific pipeline
    /// FIXED: Now properly handles DICOM files in output with ABSOLUTE paths!
    /// </summary>
    public class FileProcessor
    {
        private readonly ILogger _logger;
        private readonly ExifToolReader _exifToolReader;
        private readonly DicomConverter _dicomConverter;
        private readonly PipelineConfiguration _pipelineConfig;
        private readonly DicomSettings _dicomSettings;
        private readonly IDicomTagMapper? _tagMapper;
        private readonly IMappingConfiguration? _mappingConfiguration;

        public event EventHandler<FileProcessingEventArgs>? ProcessingStarted;
        public event EventHandler<FileProcessingEventArgs>? ProcessingCompleted;
        public event EventHandler<FileProcessingErrorEventArgs>? ProcessingError;

        /// <summary>
        /// Creates a FileProcessor for a specific pipeline
        /// </summary>
        public FileProcessor(
            ILogger logger,
            ExifToolReader exifToolReader,
            DicomConverter dicomConverter,
            PipelineConfiguration pipelineConfig,
            DicomSettings globalDicomSettings,
            IDicomTagMapper? tagMapper = null,
            IMappingConfiguration? mappingConfiguration = null)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _exifToolReader = exifToolReader ?? throw new ArgumentNullException(nameof(exifToolReader));
            _dicomConverter = dicomConverter ?? throw new ArgumentNullException(nameof(dicomConverter));
            _pipelineConfig = pipelineConfig ?? throw new ArgumentNullException(nameof(pipelineConfig));
            _dicomSettings = ApplyDicomOverrides(globalDicomSettings, pipelineConfig.DicomOverrides);
            _tagMapper = tagMapper;
            _mappingConfiguration = mappingConfiguration;

            _logger.LogDebug("Created FileProcessor for pipeline: {PipelineName} (\"{PipelineId}\")",
                pipelineConfig.Name, pipelineConfig.Id);
        }

        /// <summary>
        /// Determines if a file should be processed based on pipeline configuration
        /// </summary>
        public bool ShouldProcessFile(string filePath)
        {
            try
            {
                var fileInfo = new FileInfo(filePath);
                var extension = fileInfo.Extension.ToLowerInvariant();

                // Check file extension
                var filePattern = _pipelineConfig.WatchSettings.FilePattern;
                var patterns = string.IsNullOrEmpty(filePattern)
                    ? new[] { "*.jpg", "*.jpeg" }
                    : filePattern.Split(';', StringSplitOptions.RemoveEmptyEntries);

                var isValidExtension = patterns.Any(pattern =>
                {
                    var patternExt = Path.GetExtension(pattern).ToLowerInvariant();
                    return patternExt == extension || patternExt == ".*";
                });

                if (!isValidExtension)
                {
                    return false;
                }

                // Check file age
                if (_pipelineConfig.ProcessingOptions.MaxFileAge.HasValue)
                {
                    var age = DateTime.UtcNow - fileInfo.CreationTimeUtc;
                    if (age > _pipelineConfig.ProcessingOptions.MaxFileAge.Value)
                    {
                        _logger.LogDebug("File {FileName} is too old ({Age} days)",
                            fileInfo.Name, age.TotalDays);
                        return false;
                    }
                }

                // Check file size
                if (_pipelineConfig.ProcessingOptions.MinimumFileSizeBytes.HasValue &&
                    fileInfo.Length < _pipelineConfig.ProcessingOptions.MinimumFileSizeBytes.Value)
                {
                    _logger.LogDebug("File {FileName} is too small ({Size} bytes)",
                        fileInfo.Name, fileInfo.Length);
                    return false;
                }

                if (_pipelineConfig.ProcessingOptions.MaximumFileSizeBytes.HasValue &&
                    fileInfo.Length > _pipelineConfig.ProcessingOptions.MaximumFileSizeBytes.Value)
                {
                    _logger.LogDebug("File {FileName} is too large ({Size} bytes)",
                        fileInfo.Name, fileInfo.Length);
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error checking file {FilePath}", filePath);
                return false;
            }
        }

        /// <summary>
        /// Processes a single JPEG file through the pipeline
        /// </summary>
        public async Task<FileProcessingResult> ProcessFileAsync(string filePath)
        {
            var stopwatch = Stopwatch.StartNew();
            var result = new FileProcessingResult
            {
                SourceFile = filePath,
                StartTime = DateTime.UtcNow,
                PipelineId = _pipelineConfig.Id
            };

            try
            {
                _logger.LogInformation("Processing file: {FileName}", Path.GetFileName(filePath));
                ProcessingStarted?.Invoke(this, new FileProcessingEventArgs { FilePath = filePath });

                // Validate input file
                ValidateInputFile(filePath);

                // Extract EXIF data
                _logger.LogDebug("Extracting EXIF data from {FilePath}", filePath);
                var exifStopwatch = Stopwatch.StartNew();
                var metadata = await _exifToolReader.ExtractMetadataAsync(filePath);
                exifStopwatch.Stop();
                _logger.LogDebug("EXIF extraction completed in {ElapsedMs}ms", exifStopwatch.ElapsedMilliseconds);

                if (metadata == null)
                {
                    // FIXED: Create default metadata instead of failing!
                    _logger.LogWarning("Failed to extract metadata, creating default DICOM with minimal tags");
                    metadata = CreateDefaultMetadata(filePath);
                }

                // Determine output path based on pipeline configuration
                var outputPath = DetermineOutputPath(metadata, filePath);

                // Ensure output directory exists
                var outputDir = Path.GetDirectoryName(outputPath);
                if (!string.IsNullOrEmpty(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }

                // Convert to DICOM using pipeline-specific settings and mapping
                _logger.LogInformation("Converting JPEG to DICOM: {Source} â†’ {Destination}",
                    Path.GetFullPath(filePath), Path.GetFullPath(outputPath));

                var dicomStopwatch = Stopwatch.StartNew();

                // Create converter with mapper if available
                var converterWithMapping = new DicomConverter(
                    _logger as ILogger<DicomConverter> ?? Microsoft.Extensions.Logging.Abstractions.NullLogger<DicomConverter>.Instance,
                    _tagMapper,
                    _mappingConfiguration);

                var conversionResult = await converterWithMapping.ConvertToDicomAsync(
                    filePath,
                    outputPath,
                    metadata);

                dicomStopwatch.Stop();
                _logger.LogDebug("DICOM conversion completed in {ElapsedMs}ms", dicomStopwatch.ElapsedMilliseconds);

                result.Success = conversionResult.Success;
                result.OutputFile = outputPath;
                result.DicomFile = outputPath; // NEW: Track DICOM file location
                result.EndTime = DateTime.UtcNow;
                result.ProcessingTimeMs = stopwatch.ElapsedMilliseconds;

                if (result.Success)
                {
                    _logger.LogInformation(
                        "Successfully converted {FileName} to DICOM at: {FullPath} ({ElapsedMs}ms)",
                        Path.GetFileName(filePath),
                        Path.GetFullPath(outputPath),
                        result.ProcessingTimeMs);

                    // Performance warning for slow processing
                    if (result.ProcessingTimeMs > 5000)
                    {
                        _logger.LogWarning("Slow processing detected for {FileName}: {ElapsedMs}ms",
                            Path.GetFileName(filePath), result.ProcessingTimeMs);
                    }

                    // FIXED: Handle post-processing for SOURCE file only
                    await HandlePostProcessingAsync(filePath, outputPath, result.Success);

                    ProcessingCompleted?.Invoke(this, new FileProcessingEventArgs
                    {
                        FilePath = filePath,
                        OutputPath = outputPath
                    });
                }
                else
                {
                    throw new InvalidOperationException(
                        $"DICOM conversion failed: {conversionResult.ErrorMessage}");
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.ErrorMessage = ex.Message;
                result.EndTime = DateTime.UtcNow;
                result.ProcessingTimeMs = stopwatch.ElapsedMilliseconds;

                _logger.LogError(ex,
                    "Failed to process {FileName}. Error: {ErrorMessage}",
                    Path.GetFileName(filePath), ex.Message);

                // Critical error detection
                if (ex is UnauthorizedAccessException && filePath.StartsWith(_pipelineConfig.WatchSettings.Path))
                {
                    _logger.LogCritical(ex, "Cannot access watch folder {Path} - pipeline will fail!",
                        _pipelineConfig.WatchSettings.Path);
                }

                // Handle failure post-processing
                await HandlePostProcessingAsync(filePath, null, false);

                ProcessingError?.Invoke(this, new FileProcessingErrorEventArgs
                {
                    FilePath = filePath,
                    Error = ex
                });
            }

            return result;
        }

        private void ValidateInputFile(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException($"Source file not found: {filePath}");
            }

            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            if (extension != ".jpg" && extension != ".jpeg")
            {
                throw new InvalidOperationException($"Invalid file type: {extension}. Expected JPEG file.");
            }
        }

        private string DetermineOutputPath(ImageMetadata metadata, string sourceFile)
        {
            // FIXED: Use ArchiveFolder as DICOM output if no OutputPath configured
            // This matches the current config structure where ArchiveFolder is used for output
            var baseOutputPath = _pipelineConfig.WatchSettings.OutputPath;

            if (string.IsNullOrEmpty(baseOutputPath))
            {
                // Fallback to ArchiveFolder if no OutputPath (current config behavior)
                baseOutputPath = _pipelineConfig.ProcessingOptions.ArchiveFolder;
                _logger.LogWarning("No OutputPath in WatchSettings, using ArchiveFolder as output: {Path}",
                    Path.GetFullPath(baseOutputPath));
            }

            // ALWAYS make path absolute!
            if (!Path.IsPathRooted(baseOutputPath))
            {
                // If relative path, make it relative to service executable location
                var serviceDir = AppDomain.CurrentDomain.BaseDirectory;
                baseOutputPath = Path.Combine(serviceDir, baseOutputPath);
                _logger.LogWarning("OutputPath was relative, converted to absolute: {Path}",
                    Path.GetFullPath(baseOutputPath));
            }

            _logger.LogDebug("Base output path for pipeline {Pipeline}: {Path}",
                _pipelineConfig.Name, Path.GetFullPath(baseOutputPath));

            var organization = _pipelineConfig.ProcessingOptions.OutputOrganization;
            var fileName = Path.GetFileNameWithoutExtension(sourceFile);

            // Build organized path based on configuration
            var outputDir = baseOutputPath;

            switch (organization)
            {
                case OutputOrganization.ByPatient:
                    if (!string.IsNullOrEmpty(metadata.Patient?.PatientName))
                    {
                        var safeName = SanitizeForPath(metadata.Patient.PatientName);
                        outputDir = Path.Combine(baseOutputPath, safeName);
                        _logger.LogDebug("Output organized by patient: {PatientName} -> {SafeName}",
                            metadata.Patient.PatientName, safeName);
                    }
                    else
                    {
                        outputDir = Path.Combine(baseOutputPath, "Unknown Patient");
                        _logger.LogWarning("No patient name found, using 'Unknown Patient' folder");
                    }
                    break;

                case OutputOrganization.ByDate:
                    // ALWAYS use current date for organization
                    var dateFolder = DateTime.Now.ToString("yyyy-MM-dd");
                    outputDir = Path.Combine(baseOutputPath, dateFolder);
                    _logger.LogDebug("Output organized by date: {Date}", dateFolder);
                    break;

                case OutputOrganization.ByPatientAndDate:
                    if (!string.IsNullOrEmpty(metadata.Patient?.PatientName))
                    {
                        var safeName = SanitizeForPath(metadata.Patient.PatientName);
                        // ALWAYS use current date for organization
                        var dateFolder2 = DateTime.Now.ToString("yyyy-MM-dd");
                        outputDir = Path.Combine(baseOutputPath, safeName, dateFolder2);
                        _logger.LogDebug("Output organized by patient/date: {PatientName}/{Date}",
                            safeName, dateFolder2);
                    }
                    else
                    {
                        var dateFolder3 = DateTime.Now.ToString("yyyy-MM-dd");
                        outputDir = Path.Combine(baseOutputPath, "Unknown Patient", dateFolder3);
                        _logger.LogWarning("No patient name found, using 'Unknown Patient/{Date}' folder", dateFolder3);
                    }
                    break;

                case OutputOrganization.None:
                default:
                    // Use base output path as-is
                    break;
            }

            // Add DICOM extension
            var dicomPath = Path.Combine(outputDir, $"{fileName}.dcm");

            // CRITICAL: ALWAYS return ABSOLUTE path!
            var absolutePath = Path.GetFullPath(dicomPath);
            _logger.LogInformation("Determined DICOM output path: {FullPath}", absolutePath);
            return absolutePath;
        }

        private string SanitizeForPath(string input)
        {
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(Path.GetInvalidPathChars())
                .Distinct()
                .ToArray();

            return string.Join("_", input.Split(invalid, StringSplitOptions.RemoveEmptyEntries));
        }

        /// <summary>
        /// FIXED: Now handles source and DICOM files separately!
        /// </summary>
        private async Task HandlePostProcessingAsync(string sourceFilePath, string? dicomFilePath, bool success)
        {
            var action = success
                ? _pipelineConfig.ProcessingOptions.SuccessAction
                : _pipelineConfig.ProcessingOptions.FailureAction;

            try
            {
                switch (action)
                {
                    case PostProcessingAction.Delete:
                        // Delete only the source file
                        if (File.Exists(sourceFilePath))
                        {
                            File.Delete(sourceFilePath);
                            _logger.LogDebug("Deleted source file: {FilePath}", sourceFilePath);
                        }
                        break;

                    case PostProcessingAction.Archive:
                        // FIXED: Create separate archive folder for processed JPEGs
                        // Don't mix them with DICOM output!
                        var jpegArchiveFolder = _pipelineConfig.ProcessingOptions.BackupFolder
                            ?? Path.Combine(_pipelineConfig.ProcessingOptions.ArchiveFolder, "ProcessedJPEGs");

                        var archivePath = Path.Combine(
                            jpegArchiveFolder,
                            Path.GetFileName(sourceFilePath));

                        Directory.CreateDirectory(Path.GetDirectoryName(archivePath)!);

                        if (File.Exists(sourceFilePath))
                        {
                            File.Move(sourceFilePath, archivePath, true);
                            _logger.LogDebug("Archived source JPEG: {FullSourcePath} -> {FullArchivePath}",
                                Path.GetFullPath(sourceFilePath), Path.GetFullPath(archivePath));
                        }

                        // DICOM file stays in output folder - don't move it!
                        if (success && !string.IsNullOrEmpty(dicomFilePath))
                        {
                            _logger.LogInformation("DICOM file created at: {FullDicomPath}",
                                Path.GetFullPath(dicomFilePath));
                        }
                        break;

                    case PostProcessingAction.MoveToError:
                        // Move source file to error folder (typically for failures)
                        if (!success)
                        {
                            await MoveToErrorFolderAsync(sourceFilePath, "Processing failed");

                            // If DICOM was partially created, clean it up
                            if (!string.IsNullOrEmpty(dicomFilePath) && File.Exists(dicomFilePath))
                            {
                                try
                                {
                                    File.Delete(dicomFilePath);
                                    _logger.LogDebug("Cleaned up partial DICOM file: {DicomPath}", dicomFilePath);
                                }
                                catch (Exception ex)
                                {
                                    _logger.LogWarning(ex, "Failed to clean up partial DICOM file: {DicomPath}", dicomFilePath);
                                }
                            }
                        }
                        break;

                    default:
                        // Leave files as-is
                        _logger.LogDebug("No post-processing action for {FilePath}", sourceFilePath);
                        break;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex,
                    "Failed to perform post-processing action {Action} on {FilePath}",
                    action, sourceFilePath);
                // Don't fail the overall processing for post-processing errors
            }
        }

        private async Task MoveToErrorFolderAsync(string filePath, string errorMessage)
        {
            try
            {
                var errorFolder = _pipelineConfig.ProcessingOptions.ErrorFolder;
                Directory.CreateDirectory(errorFolder);

                var errorFileName = $"{Path.GetFileNameWithoutExtension(filePath)}" +
                                   $"_{DateTime.Now:yyyyMMdd_HHmmss}" +
                                   $"{Path.GetExtension(filePath)}";

                var errorPath = Path.Combine(errorFolder, errorFileName);

                // Write error info file
                var errorInfoPath = Path.ChangeExtension(errorPath, ".error.txt");
                await File.WriteAllTextAsync(errorInfoPath,
                    $"Error Time: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\n" +
                    $"Pipeline: {_pipelineConfig.Name}\n" +
                    $"Source File: {filePath}\n" +
                    $"Error: {errorMessage}");

                // Move the file
                if (File.Exists(filePath))
                {
                    File.Move(filePath, errorPath, true);
                    _logger.LogDebug("Moved failed file to error folder: {FullErrorPath}",
                        Path.GetFullPath(errorPath));
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to move file to error folder: {FilePath}", filePath);
            }
        }

        private DicomSettings ApplyDicomOverrides(DicomSettings global, DicomOverrides? overrides)
        {
            if (overrides == null)
                return global;

            // Create a copy of global settings with overrides applied
            var settings = new DicomSettings
            {
                InstitutionName = overrides.InstitutionName ?? global.InstitutionName,
                InstitutionDepartment = overrides.InstitutionDepartment ?? global.InstitutionDepartment,
                StationName = global.StationName,
                SourceApplicationEntityTitle = global.SourceApplicationEntityTitle,
                ImplementationVersionName = global.ImplementationVersionName,
                ImplementationClassUid = global.ImplementationClassUid,
                Modality = global.Modality,
                ValidateAfterCreation = global.ValidateAfterCreation
            };

            _logger.LogDebug("Applied DICOM overrides for pipeline: {PipelineName}", _pipelineConfig.Name);
            return settings;
        }

        /// <summary>
        /// Creates minimal default metadata when extraction fails
        /// DICOM MUST be created regardless of metadata availability!
        /// </summary>
        private ImageMetadata CreateDefaultMetadata(string sourceFile)
        {
            var fileName = Path.GetFileNameWithoutExtension(sourceFile);
            var now = DateTime.Now;

            _logger.LogWarning("Creating default metadata for {FileName} with date {Date}",
                fileName, now.ToString("yyyy-MM-dd"));

            // Create default patient info with constructor
            var patientId = new PatientId($"DEFAULT_{now:yyyyMMddHHmmss}");
            var patient = new PatientInfo(
                id: patientId,
                name: "Unknown Patient",
                birthDate: null,
                gender: Gender.Other
            );

            // Create default study info with constructor
            var studyId = new StudyId(Guid.NewGuid().ToString().Substring(0, 16)); // Max 16 chars
            var study = new StudyInfo(
                studyId: studyId,
                examId: null,
                description: "CamBridge JPEG to DICOM Conversion",
                modality: "XC",  // Photographic Image
                studyDate: now,
                accessionNumber: $"ACC{now:yyyyMMddHHmmss}",
                referringPhysician: null,
                comment: null
            );

            // Create technical data (minimal)
            var technicalData = new ImageTechnicalData
            {
                Manufacturer = "Unknown",
                Model = "Unknown"
            };

            // Create EXIF data dictionary
            var exifData = new Dictionary<string, string>
            {
                ["FileName"] = fileName,
                ["FileDate"] = now.ToString("yyyy-MM-dd HH:mm:ss"),
                ["Source"] = "CamBridge Default"
            };

            // Create metadata with full constructor
            var metadata = new ImageMetadata(
                sourceFilePath: sourceFile,
                captureDateTime: now,  // Note: captureDateTime, not captureDate!
                patient: patient,
                study: study,
                technicalData: technicalData,
                userComment: null,
                barcodeData: null,
                instanceNumber: 1,
                instanceUid: null,  // Will be auto-generated
                exifData: exifData
            );

            return metadata;
        }
    }

    /// <summary>
    /// Event arguments for file processing events
    /// </summary>
    public class FileProcessingEventArgs : EventArgs
    {
        public string FilePath { get; set; } = string.Empty;
        public string? OutputPath { get; set; }
    }

    /// <summary>
    /// Event arguments for file processing errors
    /// </summary>
    public class FileProcessingErrorEventArgs : EventArgs
    {
        public string FilePath { get; set; } = string.Empty;
        public Exception Error { get; set; } = null!;
    }

    /// <summary>
    /// Result of file processing operation
    /// </summary>
    public class FileProcessingResult
    {
        public string SourceFile { get; set; } = string.Empty;
        public string? OutputFile { get; set; }
        public string? DicomFile { get; set; }  // NEW: Track DICOM file separately
        public bool Success { get; set; }
        public string? ErrorMessage { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public long ProcessingTimeMs { get; set; }
        public Guid PipelineId { get; set; }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\MappingConfigurationLoader.cs
================================================================================

// File: src/CamBridge.Infrastructure/Services/MappingConfigurationLoader.cs
// Version: 0.5.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-04
// Status: Development/Local - FREEZE BUG FIXED

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Loads and manages DICOM mapping configurations from JSON files
    /// </summary>
    public class MappingConfigurationLoader : IMappingConfiguration
    {
        private readonly ILogger<MappingConfigurationLoader> _logger;
        private readonly string _configPath;
        private List<MappingRule> _mappingRules;
        private bool _isInitialized = false;

        public MappingConfigurationLoader(ILogger<MappingConfigurationLoader> logger, string configPath = "mappings.json")
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _configPath = configPath;
            _mappingRules = new List<MappingRule>();

            // REMOVED: LoadConfigurationAsync().GetAwaiter().GetResult();
            // This was causing the UI freeze!
            // Configuration will be loaded lazily or explicitly via LoadConfigurationAsync
        }

        /// <inheritdoc />
        public IReadOnlyList<MappingRule> GetMappingRules()
        {
            // Return default rules if not initialized
            if (!_isInitialized)
            {
                LoadDefaultMappings();
                _isInitialized = true;
            }
            return _mappingRules.AsReadOnly();
        }

        /// <inheritdoc />
        public async Task<bool> LoadConfigurationAsync(string? filePath = null)
        {
            var path = filePath ?? _configPath;

            try
            {
                // Make path absolute if relative
                if (!Path.IsPathRooted(path))
                {
                    // Try multiple locations for the config file
                    var possiblePaths = new[]
                    {
                        Path.Combine(AppDomain.CurrentDomain.BaseDirectory, path),
                        Path.Combine(Environment.CurrentDirectory, path),
                        Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)!, path),
                        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "CamBridge", path)
                    };

                    path = possiblePaths.FirstOrDefault(File.Exists) ?? possiblePaths[0];
                }

                if (!File.Exists(path))
                {
                    _logger.LogWarning("Mapping configuration file not found: {Path}. Using default mappings.", path);
                    LoadDefaultMappings();
                    _isInitialized = true;
                    return false;
                }

                var json = await File.ReadAllTextAsync(path);
                var config = JsonSerializer.Deserialize<MappingConfiguration>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });

                if (config?.Rules != null && config.Rules.Count > 0)
                {
                    _mappingRules = config.Rules;
                    _logger.LogInformation("Loaded {Count} mapping rules from {Path}", _mappingRules.Count, path);
                    _isInitialized = true;
                    return true;
                }
                else
                {
                    _logger.LogWarning("No mapping rules found in {Path}. Using default mappings.", path);
                    LoadDefaultMappings();
                    _isInitialized = true;
                    return false;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading mapping configuration from {Path}", path);
                LoadDefaultMappings();
                _isInitialized = true;
                return false;
            }
        }

        /// <inheritdoc />
        public async Task<bool> SaveConfigurationAsync(IEnumerable<MappingRule> rules, string? filePath = null)
        {
            var path = filePath ?? _configPath;

            try
            {
                // Make path absolute if relative
                if (!Path.IsPathRooted(path))
                {
                    path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, path);
                }

                // Ensure directory exists
                var directory = Path.GetDirectoryName(path);
                if (!string.IsNullOrEmpty(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                var config = new MappingConfiguration
                {
                    Version = "1.0",
                    Rules = rules.ToList()
                };

                var json = JsonSerializer.Serialize(config, new JsonSerializerOptions
                {
                    WriteIndented = true,
                    PropertyNameCaseInsensitive = true
                });

                await File.WriteAllTextAsync(path, json);

                _mappingRules = config.Rules;
                _logger.LogInformation("Saved {Count} mapping rules to {Path}", _mappingRules.Count, path);

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error saving mapping configuration to {Path}", path);
                return false;
            }
        }

        /// <inheritdoc />
        public void AddRule(MappingRule rule)
        {
            if (rule == null)
                throw new ArgumentNullException(nameof(rule));

            _mappingRules.Add(rule);
            _logger.LogDebug("Added mapping rule: {Source} -> {Target}", rule.SourceField, rule.DicomTag);
        }

        /// <inheritdoc />
        public void RemoveRule(string sourceField)
        {
            var removed = _mappingRules.RemoveAll(r => r.SourceField == sourceField);
            if (removed > 0)
            {
                _logger.LogDebug("Removed {Count} mapping rule(s) for source field: {SourceField}", removed, sourceField);
            }
        }

        /// <inheritdoc />
        public MappingRule? GetRuleForSource(string sourceField)
        {
            // Ensure we have rules loaded
            if (!_isInitialized)
            {
                LoadDefaultMappings();
                _isInitialized = true;
            }

            return _mappingRules.FirstOrDefault(r =>
                r.SourceField.Equals(sourceField, StringComparison.OrdinalIgnoreCase));
        }

        /// <inheritdoc />
        public IEnumerable<MappingRule> GetRulesForTag(string dicomTag)
        {
            // Ensure we have rules loaded
            if (!_isInitialized)
            {
                LoadDefaultMappings();
                _isInitialized = true;
            }

            return _mappingRules.Where(r =>
                r.DicomTag.Equals(dicomTag, StringComparison.OrdinalIgnoreCase));
        }

        /// <inheritdoc />
        public void ValidateRules()
        {
            foreach (var rule in _mappingRules)
            {
                if (string.IsNullOrWhiteSpace(rule.SourceField))
                    throw new InvalidOperationException($"Invalid rule: SourceField is empty");

                if (string.IsNullOrWhiteSpace(rule.DicomTag))
                    throw new InvalidOperationException($"Invalid rule: DicomTag is empty for source {rule.SourceField}");

                // Additional validation can be added here
            }
        }

        /// <summary>
        /// Loads default mapping rules for Ricoh G900 II
        /// </summary>
        private void LoadDefaultMappings()
        {
            _mappingRules = new List<MappingRule>
            {
                // Patient Information
                new MappingRule
                {
                    SourceField = "name",
                    DicomTag = "(0010,0010)",
                    Description = "Patient's Name",
                    ValueRepresentation = "PN",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "examid",
                    DicomTag = "(0010,0020)",
                    Description = "Patient ID",
                    ValueRepresentation = "LO",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "birthdate",
                    DicomTag = "(0010,0030)",
                    Description = "Patient's Birth Date",
                    ValueRepresentation = "DA",
                    Transform = "DateToDicom",
                    Required = false
                },
                new MappingRule
                {
                    SourceField = "gender",
                    DicomTag = "(0010,0040)",
                    Description = "Patient's Sex",
                    ValueRepresentation = "CS",
                    Transform = "MapGender",
                    Required = false
                },
                
                // Study Information
                new MappingRule
                {
                    SourceField = "examid",
                    DicomTag = "(0020,0010)",
                    Description = "Study ID",
                    ValueRepresentation = "SH",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "comment",
                    DicomTag = "(0008,1030)",
                    Description = "Study Description",
                    ValueRepresentation = "LO",
                    Required = false
                },
                
                // Series Information
                new MappingRule
                {
                    SourceField = "_datetime",
                    DicomTag = "(0008,0021)",
                    Description = "Series Date",
                    ValueRepresentation = "DA",
                    Transform = "ExtractDate",
                    Required = true
                },
                new MappingRule
                {
                    SourceField = "_datetime",
                    DicomTag = "(0008,0031)",
                    Description = "Series Time",
                    ValueRepresentation = "TM",
                    Transform = "ExtractTime",
                    Required = true
                }
            };

            _logger.LogInformation("Loaded {Count} default mapping rules", _mappingRules.Count);
        }

        /// <summary>
        /// Internal configuration class for JSON serialization
        /// </summary>
        private class MappingConfiguration
        {
            public string Version { get; set; } = "1.0";
            public List<MappingRule> Rules { get; set; } = new();
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\NotificationService.cs
================================================================================

// src/CamBridge.Infrastructure/Services/NotificationService.cs
// Version: 0.7.18
// Description: Ultra-minimal notification service - KISS approach without interface!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Linq;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.Logging;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Ultra-minimal notification service - just logs!
    /// KISS: No email implementation, no interface!
    /// v0.7.18: Direct dependency pattern
    /// </summary>
    public class NotificationService // No more interface!
    {
        private readonly ILogger<NotificationService> _logger;

        public NotificationService(ILogger<NotificationService> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Send daily summary - KISS: just log!
        /// </summary>
        public async Task SendDailySummaryAsync(ProcessingSummary summary)
        {
            await Task.CompletedTask;

            _logger.LogInformation(
                "Daily Summary: Processed {Total}, Success {Success}, Failed {Failed}, Uptime {Uptime}",
                summary.TotalProcessed,
                summary.Successful,
                summary.Failed,
                summary.Uptime);

            if (summary.TopErrors != null && summary.TopErrors.Count > 0)
            {
                _logger.LogInformation("Top Errors: {Errors}",
                    string.Join(", ", summary.TopErrors.Select(e => $"{e.Key}: {e.Value}")));
            }
        }

        /// <summary>
        /// Notify critical error - KISS: just log!
        /// </summary>
        public async Task NotifyErrorAsync(string message, Exception? exception = null)
        {
            await Task.CompletedTask;

            if (exception != null)
            {
                _logger.LogError(exception, "Critical Error: {Message}", message);
            }
            else
            {
                _logger.LogError("Critical Error: {Message}", message);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\PipelineManager.cs
================================================================================

// src/CamBridge.Infrastructure/Services/PipelineManager.cs
// Version: 0.7.28
// Description: Orchestrates multiple processing pipelines with isolated logging and corrected log levels
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Manages multiple processing pipelines with independent configurations, queues, watchers, FileProcessors, AND Loggers!
    /// PIPELINE UPDATE: Each pipeline gets its own FileProcessor instance AND Logger!
    /// </summary>
    public class PipelineManager : IDisposable
    {
        private readonly ILogger<PipelineManager> _logger;
        private readonly IServiceProvider _serviceProvider;
        private readonly IOptionsMonitor<CamBridgeSettingsV2> _settingsMonitor;
        private readonly ConcurrentDictionary<string, PipelineContext> _pipelines = new();
        private readonly SemaphoreSlim _pipelineLock = new(1, 1);
        private bool _disposed;

        public PipelineManager(
            ILogger<PipelineManager> logger,
            IServiceProvider serviceProvider,
            IOptionsMonitor<CamBridgeSettingsV2> settingsMonitor)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
            _settingsMonitor = settingsMonitor ?? throw new ArgumentNullException(nameof(settingsMonitor));

            // React to settings changes
            _settingsMonitor.OnChange(async settings =>
            {
                _logger.LogInformation("Settings changed, reconfiguring pipelines");
                await ReconfigurePipelinesAsync(settings);
            });
        }

        /// <summary>
        /// Initializes and starts all configured pipelines
        /// </summary>
        public async Task StartAsync(CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Starting Pipeline Manager");

            var settings = _settingsMonitor.CurrentValue;

            // Initialize pipelines from configuration
            foreach (var pipelineConfig in settings.Pipelines.Where(p => p.Enabled))
            {
                try
                {
                    await CreateAndStartPipelineAsync(pipelineConfig, cancellationToken);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to start pipeline: {PipelineName}", pipelineConfig.Name);
                }
            }

            _logger.LogInformation("Pipeline Manager started with {Count} active pipelines",
                _pipelines.Count(p => p.Value.IsActive));
        }

        /// <summary>
        /// Stops all pipelines gracefully
        /// </summary>
        public async Task StopAsync(CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Stopping Pipeline Manager");

            var stopTasks = _pipelines.Values
                .Where(p => p.IsActive)
                .Select(p => StopPipelineAsync(p, cancellationToken))
                .ToArray();

            await Task.WhenAll(stopTasks);

            _logger.LogInformation("Pipeline Manager stopped");
        }

        /// <summary>
        /// Enables a specific pipeline at runtime
        /// </summary>
        public async Task EnablePipelineAsync(string pipelineId, CancellationToken cancellationToken = default)
        {
            await _pipelineLock.WaitAsync(cancellationToken);
            try
            {
                if (_pipelines.TryGetValue(pipelineId, out var context))
                {
                    if (!context.IsActive)
                    {
                        context.Watcher.EnableRaisingEvents = true;
                        context.IsActive = true;
                        _logger.LogInformation("Pipeline {PipelineName} enabled", context.Configuration.Name);
                    }
                }
                else
                {
                    // Try to find in configuration and create
                    var config = _settingsMonitor.CurrentValue.Pipelines
                        .FirstOrDefault(p => p.Id.ToString() == pipelineId);

                    if (config != null)
                    {
                        config.Enabled = true;
                        await CreateAndStartPipelineAsync(config, cancellationToken);
                    }
                }
            }
            finally
            {
                _pipelineLock.Release();
            }
        }

        /// <summary>
        /// Disables a specific pipeline at runtime
        /// </summary>
        public async Task DisablePipelineAsync(string pipelineId, CancellationToken cancellationToken = default)
        {
            await _pipelineLock.WaitAsync(cancellationToken);
            try
            {
                if (_pipelines.TryGetValue(pipelineId, out var context))
                {
                    await StopPipelineAsync(context, cancellationToken);
                }
            }
            finally
            {
                _pipelineLock.Release();
            }
        }

        /// <summary>
        /// Gets the current status of all pipelines
        /// </summary>
        public List<PipelineStatus> GetPipelineStatuses()
        {
            return _pipelines.Values.Select(p => new PipelineStatus
            {
                Id = p.Configuration.Id,
                Name = p.Configuration.Name,
                IsActive = p.IsActive,
                QueueDepth = p.Queue.QueueLength,
                ProcessedCount = p.ProcessedCount,
                ErrorCount = p.ErrorCount,
                LastProcessed = p.LastProcessed,
                WatchPath = p.Configuration.WatchSettings.Path,
                OutputPath = p.Configuration.WatchSettings.OutputPath ?? ""
            }).ToList();
        }

        /// <summary>
        /// Gets detailed information about a specific pipeline
        /// </summary>
        public PipelineStatus? GetPipelineStatus(string pipelineId)
        {
            if (_pipelines.TryGetValue(pipelineId, out var context))
            {
                return new PipelineStatus
                {
                    Id = context.Configuration.Id,
                    Name = context.Configuration.Name,
                    IsActive = context.IsActive,
                    QueueDepth = context.Queue.QueueLength,
                    ProcessedCount = context.ProcessedCount,
                    ErrorCount = context.ErrorCount,
                    LastProcessed = context.LastProcessed,
                    WatchPath = context.Configuration.WatchSettings.Path,
                    OutputPath = context.Configuration.WatchSettings.OutputPath ?? ""
                };
            }
            return null;
        }

        private async Task CreateAndStartPipelineAsync(PipelineConfiguration config, CancellationToken cancellationToken)
        {
            if (_pipelines.ContainsKey(config.Id.ToString()))
            {
                _logger.LogWarning("Pipeline {PipelineName} ({Id}) already exists", config.Name, config.Id);
                return;
            }

            // Changed to DEBUG level - technical initialization detail
            _logger.LogDebug("Creating pipeline: {PipelineName} ({Id})", config.Name, config.Id);

            try
            {
                // Get services from DI
                var loggerFactory = _serviceProvider.GetRequiredService<ILoggerFactory>();
                var exifReader = _serviceProvider.GetRequiredService<ExifToolReader>();
                var dicomConverter = _serviceProvider.GetRequiredService<DicomConverter>();
                var globalDicomSettings = _settingsMonitor.CurrentValue.GlobalDicomSettings ?? new DicomSettings();

                // CRITICAL: Create pipeline-specific logger with sanitized name
                var sanitizedName = SanitizeForFileName(config.Name);
                var pipelineLogger = loggerFactory.CreateLogger($"Pipeline.{sanitizedName}");

                // Create FileProcessor for THIS pipeline with pipeline-specific logger
                var fileProcessor = new FileProcessor(
                    pipelineLogger,  // Use pipeline-specific logger!
                    exifReader,
                    dicomConverter,
                    config,
                    globalDicomSettings
                );

                // Create processing queue for this pipeline
                var processingOptions = Microsoft.Extensions.Options.Options.Create(config.ProcessingOptions);
                var queue = new ProcessingQueue(
                    loggerFactory.CreateLogger<ProcessingQueue>(),
                    fileProcessor,
                    processingOptions
                );

                // Create file system watcher
                var watcher = CreateFileSystemWatcher(config.WatchSettings);

                // Create pipeline context
                var context = new PipelineContext(
                    config,
                    fileProcessor,
                    queue,
                    watcher,
                    pipelineLogger  // Store pipeline logger in context
                );

                // Wire up file processor events
                fileProcessor.ProcessingCompleted += (sender, args) =>
                {
                    context.ProcessedCount++;
                    context.LastProcessed = DateTime.UtcNow;
                };

                fileProcessor.ProcessingError += (sender, args) =>
                {
                    context.ErrorCount++;
                };

                // Register pipeline
                if (_pipelines.TryAdd(config.Id.ToString(), context))
                {
                    // Wire up watcher events
                    watcher.Created += async (sender, e) =>
                    {
                        if (IsValidImageFile(e.FullPath, config.WatchSettings.FilePattern))
                        {
                            // Changed to DEBUG - file detection is technical detail
                            pipelineLogger.LogDebug("New file detected: {FilePath}", e.FullPath);
                            await queue.EnqueueAsync(e.FullPath, cancellationToken);
                        }
                    };

                    // Start processing queue (fire and forget!)
                    _ = Task.Run(async () =>
                    {
                        pipelineLogger.LogDebug("Starting processing queue for pipeline: {PipelineName}", config.Name);
                        await queue.ProcessQueueAsync(cancellationToken);
                    }, cancellationToken);

                    // Enable watcher
                    watcher.EnableRaisingEvents = true;
                    context.IsActive = true;

                    // Keep as INFO - important business event
                    pipelineLogger.LogInformation("Pipeline {PipelineName} started successfully. Watching: {WatchPath}",
                        config.Name, config.WatchSettings.Path);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to create pipeline: {PipelineName}", config.Name);
                throw;
            }
        }

        private async Task StopPipelineAsync(PipelineContext context, CancellationToken cancellationToken)
        {
            try
            {
                context.PipelineLogger.LogInformation("Stopping pipeline: {PipelineName}", context.Configuration.Name);

                context.IsActive = false;
                context.Watcher.EnableRaisingEvents = false;

                // Give queue time to finish current work
                await Task.Delay(1000, cancellationToken);

                context.PipelineLogger.LogInformation("Pipeline {PipelineName} stopped", context.Configuration.Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error stopping pipeline: {PipelineName}", context.Configuration.Name);
            }
        }

        private async Task ReconfigurePipelinesAsync(CamBridgeSettingsV2 newSettings)
        {
            await _pipelineLock.WaitAsync();
            try
            {
                // Stop pipelines that are no longer in config
                var configuredIds = newSettings.Pipelines.Select(p => p.Id.ToString()).ToHashSet();
                var toRemove = _pipelines.Keys.Where(id => !configuredIds.Contains(id)).ToList();

                foreach (var id in toRemove)
                {
                    if (_pipelines.TryRemove(id, out var context))
                    {
                        await StopPipelineAsync(context, CancellationToken.None);
                        context.Dispose();
                    }
                }

                // Start or update pipelines from config
                foreach (var pipelineConfig in newSettings.Pipelines)
                {
                    if (pipelineConfig.Enabled)
                    {
                        if (!_pipelines.ContainsKey(pipelineConfig.Id.ToString()))
                        {
                            await CreateAndStartPipelineAsync(pipelineConfig, CancellationToken.None);
                        }
                    }
                    else if (_pipelines.TryGetValue(pipelineConfig.Id.ToString(), out var context))
                    {
                        await StopPipelineAsync(context, CancellationToken.None);
                    }
                }
            }
            finally
            {
                _pipelineLock.Release();
            }
        }

        private FileSystemWatcher CreateFileSystemWatcher(PipelineWatchSettings settings)
        {
            // Ensure watch directory exists
            Directory.CreateDirectory(settings.Path);

            var watcher = new FileSystemWatcher(settings.Path)
            {
                NotifyFilter = NotifyFilters.FileName | NotifyFilters.CreationTime,
                IncludeSubdirectories = settings.IncludeSubdirectories
            };

            // Apply file pattern filter(s)
            // Note: FileSystemWatcher only supports single pattern, so we use *.* and filter in event
            watcher.Filter = "*.*";

            return watcher;
        }

        private bool IsValidImageFile(string filePath, string filePattern)
        {
            var fileName = Path.GetFileName(filePath);

            // Default to JPEG patterns if not specified
            if (string.IsNullOrWhiteSpace(filePattern))
                filePattern = "*.jpg;*.jpeg";

            // Split patterns by semicolon and check each
            var patterns = filePattern.Split(';', StringSplitOptions.RemoveEmptyEntries)
                .Select(p => p.Trim());

            foreach (var pattern in patterns)
            {
                // Convert wildcard pattern to regex
                var regexPattern = "^" + Regex.Escape(pattern)
                    .Replace("\\*", ".*")
                    .Replace("\\?", ".") + "$";

                if (Regex.IsMatch(fileName, regexPattern, RegexOptions.IgnoreCase))
                    return true;
            }

            return false;
        }

        private string SanitizeForFileName(string pipelineName)
        {
            // Same logic as in LogViewerViewModel
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(new[] { ' ', '.', ',', '/', '\\', ':', '-' })
                .Distinct()
                .ToArray();

            var sanitized = string.Join("_", pipelineName.Split(invalid, StringSplitOptions.RemoveEmptyEntries));

            if (sanitized.Length > 100)
            {
                sanitized = sanitized.Substring(0, 97) + "...";
            }

            return sanitized;
        }

        public void Dispose()
        {
            if (_disposed) return;

            try
            {
                StopAsync(CancellationToken.None).GetAwaiter().GetResult();

                foreach (var context in _pipelines.Values)
                {
                    context.Dispose();
                }

                _pipelines.Clear();
                _pipelineLock?.Dispose();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during PipelineManager disposal");
            }

            _disposed = true;
        }

        /// <summary>
        /// Internal class to hold pipeline runtime context
        /// </summary>
        private class PipelineContext : IDisposable
        {
            public PipelineConfiguration Configuration { get; }
            public FileProcessor FileProcessor { get; }
            public ProcessingQueue Queue { get; }
            public FileSystemWatcher Watcher { get; }
            public ILogger PipelineLogger { get; }
            public bool IsActive { get; set; }
            public DateTime LastProcessed { get; set; }
            public int ProcessedCount { get; set; }
            public int ErrorCount { get; set; }

            public PipelineContext(
                PipelineConfiguration configuration,
                FileProcessor fileProcessor,
                ProcessingQueue queue,
                FileSystemWatcher watcher,
                ILogger pipelineLogger)
            {
                Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
                FileProcessor = fileProcessor ?? throw new ArgumentNullException(nameof(fileProcessor));
                Queue = queue ?? throw new ArgumentNullException(nameof(queue));
                Watcher = watcher ?? throw new ArgumentNullException(nameof(watcher));
                PipelineLogger = pipelineLogger ?? throw new ArgumentNullException(nameof(pipelineLogger));
                LastProcessed = DateTime.MinValue;
            }

            public void Dispose()
            {
                Watcher?.Dispose();
            }
        }
    }

    /// <summary>
    /// Pipeline status information for API responses
    /// </summary>
    public class PipelineStatus
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public bool IsActive { get; set; }
        public int QueueDepth { get; set; }
        public int ProcessedCount { get; set; }
        public int ErrorCount { get; set; }
        public DateTime LastProcessed { get; set; }
        public string WatchPath { get; set; } = string.Empty;
        public string OutputPath { get; set; } = string.Empty;
    }
}


================================================================================
FILE: src\CamBridge.Infrastructure\Services\ProcessingQueue.cs
================================================================================

// src/CamBridge.Infrastructure/Services/ProcessingQueue.cs
// Version: 0.7.28
// Description: Thread-safe queue with pipeline-specific FileProcessor and EnqueueAsync!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace CamBridge.Infrastructure.Services
{
    /// <summary>
    /// Thread-safe queue for managing file processing with retry logic
    /// PIPELINE UPDATE: Uses pipeline-specific FileProcessor directly!
    /// </summary>
    public class ProcessingQueue
    {
        private readonly ILogger<ProcessingQueue> _logger;
        private readonly FileProcessor _fileProcessor; // Direct dependency!
        private readonly ProcessingOptions _options;
        private readonly ConcurrentQueue<ProcessingItem> _queue = new();
        private readonly ConcurrentDictionary<string, ProcessingItem> _activeItems = new();
        private readonly SemaphoreSlim _processingSlots;
        private readonly object _statsLock = new();
        private readonly Dictionary<string, int> _errorCounts = new();

        private int _totalProcessed;
        private int _totalSuccessful;
        private int _totalFailed;
        private DateTime _startTime = DateTime.UtcNow;

        public int QueueLength => _queue.Count;
        public int ActiveProcessing => _activeItems.Count;
        public int TotalProcessed => _totalProcessed;
        public int TotalSuccessful => _totalSuccessful;
        public int TotalFailed => _totalFailed;
        public TimeSpan UpTime => DateTime.UtcNow - _startTime;

        /// <summary>
        /// Creates a ProcessingQueue with a specific FileProcessor for this pipeline
        /// </summary>
        public ProcessingQueue(
            ILogger<ProcessingQueue> logger,
            FileProcessor fileProcessor,
            IOptions<ProcessingOptions> options)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _fileProcessor = fileProcessor ?? throw new ArgumentNullException(nameof(fileProcessor));
            _options = options?.Value ?? throw new ArgumentNullException(nameof(options));

            _processingSlots = new SemaphoreSlim(
                _options.MaxConcurrentProcessing,
                _options.MaxConcurrentProcessing);
        }

        /// <summary>
        /// Enqueues a file for processing
        /// </summary>
        public bool TryEnqueue(string filePath)
        {
            if (string.IsNullOrWhiteSpace(filePath))
                return false;

            // Check if already in queue or being processed
            if (_activeItems.ContainsKey(filePath))
            {
                _logger.LogDebug("File {FilePath} is already being processed", filePath);
                return false;
            }

            if (_queue.Any(item => item.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase)))
            {
                _logger.LogDebug("File {FilePath} is already in queue", filePath);
                return false;
            }

            // Check if file should be processed using THIS pipeline's FileProcessor
            if (!_fileProcessor.ShouldProcessFile(filePath))
            {
                _logger.LogDebug("File {FilePath} does not meet processing criteria", filePath);
                return false;
            }

            var item = new ProcessingItem(filePath);
            _queue.Enqueue(item);

            _logger.LogInformation("Enqueued {FilePath} for processing (queue length: {QueueLength})",
                filePath, _queue.Count);

            return true;
        }

        /// <summary>
        /// Async wrapper for TryEnqueue to match PipelineManager expectations
        /// </summary>
        public Task<bool> EnqueueAsync(string filePath, CancellationToken cancellationToken = default)
        {
            // Simply wrap the synchronous TryEnqueue method
            var result = TryEnqueue(filePath);
            return Task.FromResult(result);
        }

        /// <summary>
        /// Processes items from the queue
        /// </summary>
        public async Task ProcessQueueAsync(CancellationToken cancellationToken)
        {
            var tasks = new List<Task>();

            while (!cancellationToken.IsCancellationRequested)
            {
                // Clean up completed tasks
                tasks.RemoveAll(t => t.IsCompleted);

                // Try to dequeue and process
                if (_queue.TryDequeue(out var item))
                {
                    // Wait for available processing slot
                    await _processingSlots.WaitAsync(cancellationToken);

                    // Start processing task
                    var task = ProcessItemAsync(item, cancellationToken);
                    tasks.Add(task);
                }
                else
                {
                    // No items in queue, wait a bit
                    await Task.Delay(100, cancellationToken);
                }
            }

            // Wait for all remaining tasks to complete on shutdown
            if (tasks.Count > 0)
            {
                _logger.LogInformation("Waiting for {Count} active processing tasks to complete", tasks.Count);
                await Task.WhenAll(tasks);
            }
        }

        /// <summary>
        /// Gets current queue statistics
        /// </summary>
        public QueueStatistics GetStatistics()
        {
            lock (_statsLock)
            {
                return new QueueStatistics
                {
                    QueueLength = QueueLength,
                    ActiveProcessing = ActiveProcessing,
                    TotalProcessed = TotalProcessed,
                    TotalSuccessful = TotalSuccessful,
                    TotalFailed = TotalFailed,
                    UpTime = UpTime,
                    ProcessingRate = TotalProcessed > 0 ? TotalProcessed / UpTime.TotalMinutes : 0,
                    TopErrors = _errorCounts
                        .OrderByDescending(x => x.Value)
                        .Take(5)
                        .ToDictionary(x => x.Key, x => x.Value)
                };
            }
        }

        /// <summary>
        /// Gets daily summary for notifications
        /// </summary>
        public ProcessingSummary GetDailySummary()
        {
            var stats = GetStatistics();

            return new ProcessingSummary
            {
                Date = DateTime.Today,
                TotalProcessed = stats.TotalProcessed,
                Successful = stats.TotalSuccessful,
                Failed = stats.TotalFailed,
                ProcessingTimeSeconds = stats.UpTime.TotalSeconds,
                TopErrors = stats.TopErrors,
                Uptime = stats.UpTime
            };
        }

        /// <summary>
        /// Gets items currently being processed
        /// </summary>
        public IReadOnlyList<ProcessingItemStatus> GetActiveItems()
        {
            return _activeItems.Values
                .Select(item => new ProcessingItemStatus
                {
                    FilePath = item.FilePath,
                    StartTime = item.StartTime,
                    AttemptCount = item.AttemptCount,
                    Duration = item.StartTime.HasValue
                        ? DateTime.UtcNow - item.StartTime.Value
                        : TimeSpan.Zero
                })
                .ToList()
                .AsReadOnly();
        }

        private async Task ProcessItemAsync(ProcessingItem item, CancellationToken cancellationToken)
        {
            try
            {
                // Mark as active
                _activeItems.TryAdd(item.FilePath, item);
                item.StartTime = DateTime.UtcNow;
                item.AttemptCount++;

                _logger.LogInformation("Starting processing of {FilePath} (attempt {Attempt})",
                    item.FilePath, item.AttemptCount);

                // Process the file with THIS pipeline's FileProcessor!
                var result = await _fileProcessor.ProcessFileAsync(item.FilePath);

                // Update statistics
                lock (_statsLock)
                {
                    _totalProcessed++;
                    if (result.Success)
                    {
                        _totalSuccessful++;
                    }
                    else
                    {
                        _totalFailed++;
                        TrackError(result.ErrorMessage ?? "Unknown error");
                    }
                }

                if (!result.Success && ShouldRetry(item))
                {
                    // Schedule retry
                    await ScheduleRetryAsync(item, cancellationToken);
                }
                else if (!result.Success)
                {
                    // KISS: File already moved to error folder by FileProcessor!
                    _logger.LogError("Failed to process {FilePath} after {Attempts} attempts: {Error}",
                        item.FilePath, item.AttemptCount, result.ErrorMessage);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error processing {FilePath}", item.FilePath);

                lock (_statsLock)
                {
                    _totalProcessed++;
                    _totalFailed++;
                    TrackError(ex.Message);
                }

                if (ShouldRetry(item))
                {
                    await ScheduleRetryAsync(item, cancellationToken);
                }
                else
                {
                    // Log final failure - file should already be in error folder
                    _logger.LogError("Failed to process {FilePath} after {Attempts} attempts",
                        item.FilePath, item.AttemptCount);
                }
            }
            finally
            {
                // Remove from active items
                _activeItems.TryRemove(item.FilePath, out _);

                // Release processing slot
                _processingSlots.Release();
            }
        }

        private bool ShouldRetry(ProcessingItem item)
        {
            return _options.RetryOnFailure &&
                   item.AttemptCount < _options.MaxRetryAttempts;
        }

        private async Task ScheduleRetryAsync(ProcessingItem item, CancellationToken cancellationToken)
        {
            var delay = TimeSpan.FromSeconds(_options.RetryDelaySeconds * item.AttemptCount);

            _logger.LogInformation("Scheduling retry for {FilePath} in {Delay} seconds",
                item.FilePath, delay.TotalSeconds);

            // Wait before re-enqueueing
            await Task.Delay(delay, cancellationToken);

            if (!cancellationToken.IsCancellationRequested)
            {
                item.StartTime = null; // Reset start time
                _queue.Enqueue(item);
            }
        }

        private void TrackError(string error)
        {
            var category = CategorizeError(error);
            _errorCounts.TryGetValue(category, out var count);
            _errorCounts[category] = count + 1;
        }

        private string CategorizeError(string error)
        {
            if (error.Contains("EXIF", StringComparison.OrdinalIgnoreCase))
                return "EXIF extraction failed";
            if (error.Contains("DICOM", StringComparison.OrdinalIgnoreCase))
                return "DICOM conversion failed";
            if (error.Contains("Patient", StringComparison.OrdinalIgnoreCase))
                return "Patient data missing";
            if (error.Contains("File", StringComparison.OrdinalIgnoreCase))
                return "File access error";
            if (error.Contains("Memory", StringComparison.OrdinalIgnoreCase))
                return "Memory error";
            return "Other error";
        }

        /// <summary>
        /// Processing item with retry tracking
        /// </summary>
        private class ProcessingItem
        {
            public string FilePath { get; }
            public int AttemptCount { get; set; }
            public DateTime? StartTime { get; set; }
            public DateTime EnqueuedTime { get; }

            public ProcessingItem(string filePath)
            {
                FilePath = filePath;
                EnqueuedTime = DateTime.UtcNow;
            }
        }
    }

    // Statistics classes remain the same...
    public class QueueStatistics
    {
        public int QueueLength { get; init; }
        public int ActiveProcessing { get; init; }
        public int TotalProcessed { get; init; }
        public int TotalSuccessful { get; init; }
        public int TotalFailed { get; init; }
        public TimeSpan UpTime { get; init; }
        public double ProcessingRate { get; init; }
        public Dictionary<string, int> TopErrors { get; init; } = new();

        public double SuccessRate => TotalProcessed > 0
            ? (double)TotalSuccessful / TotalProcessed * 100
            : 0;
    }

    public class ProcessingItemStatus
    {
        public string FilePath { get; init; } = string.Empty;
        public DateTime? StartTime { get; init; }
        public int AttemptCount { get; init; }
        public TimeSpan Duration { get; init; }
    }
}

