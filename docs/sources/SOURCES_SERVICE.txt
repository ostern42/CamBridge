################################################################################
# CamBridge Sources - SERVICE
# Generated: 2025-06-23 20:28:25
# Root Path: src\CamBridge.Service
# Description: Windows service, API endpoints, worker
################################################################################

## PROJECT SUMMARY
Total Files: 13
Total Lines: 1714
Total Size: 65,37 KB

Files by Type:
  .cs: 8 files
  .csproj: 1 files
  .json: 4 files

## DIRECTORY STRUCTURE
src\CamBridge.Service/
+-- Controllers/ (1 files)
+-- Properties/ (1 files)

## FILE CONTENTS

================================================================================
FILE: appsettings.json
--------------------------------------------------------------------------------
Size: 6,88 KB | Lines: 206 | Modified: 2025-06-13 01:16:28
================================================================================

{
  "CamBridge": {
    "Version": "2.0",
    "Service": {
      "ServiceName": "CamBridgeService",
      "DisplayName": "CamBridge JPEG to DICOM Converter",
      "Description": "Monitors folders for JPEG files from Ricoh cameras and converts them to DICOM format",
      "ApiPort": 5111,
      "EnableHealthChecks": true,
      "HealthCheckInterval": "00:01:00",
      "StartupDelaySeconds": 5,
      "FileProcessingDelayMs": 500
    },
    "Pipelines": [
      {
        "Id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "Name": "Radiology Pipeline",
        "Description": "Standard radiology workflow for chest X-rays",
        "Enabled": true,
        "WatchSettings": {
          "Path": "C:\\CamBridge\\Watch\\Radiology",
          "FilePattern": "*.jpg;*.jpeg",
          "IncludeSubdirectories": false,
          "MinimumFileAgeSeconds": 2
        },
        "ProcessingOptions": {
          "SuccessAction": "Archive",
          "FailureAction": "MoveToError",
          "DeleteSourceAfterSuccess": false,
          "ProcessExistingOnStartup": true,
          "MaxRetryAttempts": 3,
          "RetryDelaySeconds": 30,
          "ErrorFolder": "C:\\CamBridge\\Errors\\Radiology",
          "ArchiveFolder": "C:\\CamBridge\\Output\\Radiology",
          "BackupFolder": "C:\\CamBridge\\Archive\\Radiology",
          "CreateBackup": true,
          "MaxConcurrentProcessing": 5,
          "OutputOrganization": "ByPatientAndDate",
          "OutputFilePattern": "{PatientId}_{StudyDate}_{Counter:0000}.dcm"
        },
        "MappingSetId": "00000000-0000-0000-0000-000000000001"
      },
      {
        "Id": "f9e8d7c6-b5a4-3210-fedc-ba0987654321",
        "Name": "Emergency Pipeline",
        "Description": "High-priority emergency imaging workflow",
        "Enabled": true,
        "WatchSettings": {
          "Path": "C:\\CamBridge\\Watch\\Emergency",
          "FilePattern": "*.jpg",
          "IncludeSubdirectories": false,
          "MinimumFileAgeSeconds": 1
        },
        "ProcessingOptions": {
          "SuccessAction": "Archive",
          "FailureAction": "MoveToError",
          "DeleteSourceAfterSuccess": false,
          "ProcessExistingOnStartup": true,
          "MaxRetryAttempts": 5,
          "RetryDelaySeconds": 10,
          "ErrorFolder": "C:\\CamBridge\\Errors\\Emergency",
          "ArchiveFolder": "C:\\CamBridge\\Output\\Emergency",
          "BackupFolder": "C:\\CamBridge\\Archive\\Emergency",
          "CreateBackup": false,
          "MaxConcurrentProcessing": 10,
          "OutputOrganization": "None",
          "OutputFilePattern": "EMRG_{PatientId}_{Counter:0000}.dcm"
        },
        "MappingSetId": "00000000-0000-0000-0000-000000000001"
      }
    ],
    "MappingSets": [
      {
        "Id": "00000000-0000-0000-0000-000000000001",
        "Name": "Ricoh Default",
        "Description": "Standard mapping for Ricoh G900 II cameras with QRBridge",
        "IsSystemDefault": true,
        "Rules": [
          {
            "Name": "PatientName",
            "Description": "Patient's full name",
            "SourceType": "QRBridge",
            "SourceField": "name",
            "DicomTag": "(0010,0010)",
            "Transform": "None",
            "Required": true,
            "ValueRepresentation": "PN"
          },
          {
            "Name": "PatientID",
            "Description": "Patient identifier",
            "SourceType": "QRBridge",
            "SourceField": "examid",
            "DicomTag": "(0010,0020)",
            "Transform": "None",
            "Required": true,
            "ValueRepresentation": "LO"
          },
          {
            "Name": "PatientBirthDate",
            "Description": "Patient's date of birth",
            "SourceType": "QRBridge",
            "SourceField": "birthdate",
            "DicomTag": "(0010,0030)",
            "Transform": "DateToDicom",
            "Required": false,
            "ValueRepresentation": "DA"
          },
          {
            "Name": "PatientSex",
            "Description": "Patient's sex",
            "SourceType": "QRBridge",
            "SourceField": "gender",
            "DicomTag": "(0010,0040)",
            "Transform": "MapGender",
            "Required": false,
            "DefaultValue": "O",
            "ValueRepresentation": "CS"
          },
          {
            "Name": "StudyDescription",
            "Description": "Description of the study",
            "SourceType": "QRBridge",
            "SourceField": "comment",
            "DicomTag": "(0008,1030)",
            "Transform": "None",
            "Required": false,
            "ValueRepresentation": "LO"
          },
          {
            "Name": "StudyDate",
            "Description": "Date the study was performed",
            "SourceType": "EXIF",
            "SourceField": "DateTimeOriginal",
            "DicomTag": "(0008,0020)",
            "Transform": "ExtractDate",
            "Required": true,
            "ValueRepresentation": "DA"
          },
          {
            "Name": "StudyTime",
            "Description": "Time the study was performed",
            "SourceType": "EXIF",
            "SourceField": "DateTimeOriginal",
            "DicomTag": "(0008,0030)",
            "Transform": "ExtractTime",
            "Required": true,
            "ValueRepresentation": "TM"
          }
        ]
      }
    ],
    "GlobalDicomSettings": {
      "ImplementationClassUid": "1.2.276.0.7230010.3.0.3.6.4",
      "ImplementationVersionName": "CAMBRIDGE_0710",
      "SourceApplicationEntityTitle": "CAMBRIDGE",
      "Modality": "OT",
      "InstitutionName": "CamBridge Medical Imaging",
      "InstitutionDepartment": "",
      "StationName": "",
      "ValidateAfterCreation": true
    },
    "DefaultProcessingOptions": {
      "SuccessAction": "Archive",
      "FailureAction": "MoveToError",
      "ArchiveFolder": "C:\\CamBridge\\Output",
      "ErrorFolder": "C:\\CamBridge\\Errors",
      "BackupFolder": "C:\\CamBridge\\Archive",
      "CreateBackup": true,
      "MaxConcurrentProcessing": 5,
      "RetryOnFailure": true,
      "MaxRetryAttempts": 3,
      "RetryDelaySeconds": 30,
      "OutputOrganization": "ByPatientAndDate",
      "ProcessExistingOnStartup": true,
      "OutputFilePattern": "{PatientId}_{StudyDate}_{Counter:0000}.dcm"
    },
    "Logging": {
      "LogLevel": "Information",
      "LogFolder": "C:\\ProgramData\\CamBridge\\Logs",
      "EnableFileLogging": true,
      "EnableEventLog": true,
      "MaxLogFileSizeMB": 10,
      "MaxLogFiles": 10
    },
    "Notifications": {
      "Enabled": true,
      "DeadLetterThreshold": 100,
      "LogNotifications": true,
      "EventLog": {
        "Enabled": true,
        "LogName": "Application",
        "SourceName": "CamBridge"
      }
    },
    "ExifToolPath": "Tools\\exiftool.exe"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information",
      "CamBridge": "Information"
    }
  }
}

================================================================================
FILE: CamBridge.Service.csproj
--------------------------------------------------------------------------------
Size: 2,05 KB | Lines: 55 | Modified: 2025-06-22 01:49:10
================================================================================

<Project Sdk="Microsoft.NET.Sdk.Web">

	<PropertyGroup>
		<TargetFramework>net8.0-windows</TargetFramework>
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<OutputType>Exe</OutputType>
		<RuntimeIdentifier>win-x64</RuntimeIdentifier>

		<!-- Windows Service Support -->
		<PublishSingleFile>false</PublishSingleFile>
		<SelfContained>false</SelfContained>
		<PublishReadyToRun>true</PublishReadyToRun>

		<!-- Assembly Info -->
		<AssemblyName>CamBridge.Service</AssemblyName>
		<RootNamespace>CamBridge.Service</RootNamespace>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" Version="8.0.0" />
		<PackageReference Include="Serilog.AspNetCore" Version="8.0.1" />
		<PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
		<PackageReference Include="Serilog.Sinks.EventLog" Version="4.0.0" />
		<PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
		<PackageReference Include="Serilog.Sinks.Map" Version="1.0.2" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\CamBridge.Core\CamBridge.Core.csproj" />
		<ProjectReference Include="..\CamBridge.Infrastructure\CamBridge.Infrastructure.csproj" />
	</ItemGroup>

	<ItemGroup>
		<Content Update="appsettings.json">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
		</Content>
		<Content Update="appsettings.Development.json">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
		</Content>
		<Content Update="mappings.json">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
		</Content>
	</ItemGroup>

	<!-- Copy ExifTool to output -->
	<Target Name="CopyExifTool" AfterTargets="Build">
		<ItemGroup>
			<ExifToolFiles Include="..\..\Tools\exiftool.exe" />
			<ExifToolFiles Include="..\..\Tools\exiftool_files\**\*.*" />
		</ItemGroup>
		<Copy SourceFiles="@(ExifToolFiles)" DestinationFiles="@(ExifToolFiles->'$(OutputPath)Tools\%(RecursiveDir)%(Filename)%(Extension)')" SkipUnchangedFiles="true" />
	</Target>

</Project>

================================================================================
FILE: CamBridgeHealthCheck.cs
--------------------------------------------------------------------------------
Size: 4,20 KB | Lines: 100 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Service/CamBridgeHealthCheck.cs
// Version: 0.7.28
// Description: Health check implementation using PipelineManager and direct NotificationService
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Logging;

namespace CamBridge.Service
{
    /// <summary>
    /// Health check for CamBridge service
    /// KISS UPDATE: Now uses PipelineManager to aggregate health from all pipelines
    /// v0.7.28: Direct NotificationService dependency
    /// </summary>
    public class CamBridgeHealthCheck : IHealthCheck
    {
        private readonly ILogger<CamBridgeHealthCheck> _logger;
        private readonly PipelineManager _pipelineManager;
        private readonly NotificationService _notificationService; // Direct dependency!

        public CamBridgeHealthCheck(
            ILogger<CamBridgeHealthCheck> logger,
            PipelineManager pipelineManager,
            NotificationService notificationService) // Changed from INotificationService
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _pipelineManager = pipelineManager ?? throw new ArgumentNullException(nameof(pipelineManager));
            _notificationService = notificationService ?? throw new ArgumentNullException(nameof(notificationService));
        }

        public Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
        {
            try
            {
                // Get status from all pipelines
                var pipelineStatuses = _pipelineManager.GetPipelineStatuses();

                if (!pipelineStatuses.Any())
                {
                    return Task.FromResult(HealthCheckResult.Unhealthy("No pipelines configured"));
                }

                // Aggregate statistics from all pipelines
                var totalQueued = pipelineStatuses.Sum(p => p.QueueDepth);
                var totalProcessed = pipelineStatuses.Sum(p => p.ProcessedCount);
                var totalErrors = pipelineStatuses.Sum(p => p.ErrorCount);
                var activePipelines = pipelineStatuses.Count(p => p.IsActive);

                var data = new Dictionary<string, object>
                {
                    ["TotalPipelines"] = pipelineStatuses.Count,
                    ["ActivePipelines"] = activePipelines,
                    ["QueueLength"] = totalQueued,
                    ["TotalProcessed"] = totalProcessed,
                    ["TotalErrors"] = totalErrors,
                    ["ServiceUptime"] = DateTime.UtcNow - Program.ServiceStartTime
                };

                // Determine health based on queue size and failure rate
                if (totalQueued > 1000)
                {
                    return Task.FromResult(HealthCheckResult.Degraded(
                        $"Large queue backlog: {totalQueued} items",
                        data: data));
                }

                if (totalProcessed > 0 && totalErrors > totalProcessed * 0.5)
                {
                    return Task.FromResult(HealthCheckResult.Unhealthy(
                        $"High failure rate: {totalErrors}/{totalProcessed}",
                        data: data));
                }

                if (activePipelines == 0)
                {
                    return Task.FromResult(HealthCheckResult.Unhealthy(
                        "No active pipelines",
                        data: data));
                }

                return Task.FromResult(HealthCheckResult.Healthy(
                    $"Service healthy - {activePipelines}/{pipelineStatuses.Count} pipelines active",
                    data: data));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Health check failed");
                return Task.FromResult(HealthCheckResult.Unhealthy("Health check error", ex));
            }
        }
    }
}


================================================================================
FILE: ConfigValidator.cs
--------------------------------------------------------------------------------
Size: 7,89 KB | Lines: 180 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Service/ConfigValidator.cs
// Version: 0.7.28
// Description: Validates configuration and warns about invalid values
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;
using CamBridge.Core;
using Serilog;

namespace CamBridge.Service
{
    /// <summary>
    /// Validates configuration JSON and warns about invalid enum values
    /// </summary>
    public static class ConfigValidator
    {
        /// <summary>
        /// Validates the settings object (new method for v0.7.28)
        /// </summary>
        public static void ValidateSettings(CamBridgeSettingsV2 settings)
        {
            // Basic validation that was expected by Program.cs
            if (settings == null)
                throw new ArgumentNullException(nameof(settings));

            if (string.IsNullOrEmpty(settings.Version))
                throw new InvalidOperationException("Settings version is required");

            if (settings.Version != "2.0")
                throw new InvalidOperationException($"Unsupported settings version: {settings.Version}. Expected: 2.0");

            // Validate pipelines
            if (settings.Pipelines == null || settings.Pipelines.Count == 0)
                throw new InvalidOperationException("At least one pipeline must be configured");

            foreach (var pipeline in settings.Pipelines)
            {
                if (string.IsNullOrEmpty(pipeline.Name))
                    throw new InvalidOperationException($"Pipeline {pipeline.Id} must have a name");

                if (pipeline.WatchSettings == null)
                    throw new InvalidOperationException($"Pipeline {pipeline.Name} must have watch settings");

                if (string.IsNullOrEmpty(pipeline.WatchSettings.Path))
                    throw new InvalidOperationException($"Pipeline {pipeline.Name} must have a watch path");
            }
        }

        /// <summary>
        /// Validates the configuration file and warns about any issues
        /// </summary>
        public static void ValidateAndWarn(string configPath, Serilog.ILogger logger)
        {
            try
            {
                if (!File.Exists(configPath))
                    return;

                var configJson = File.ReadAllText(configPath);
                var warnings = new List<string>();

                // Check for invalid OutputOrganization values
                var validOutputOrgValues = new[] { "None", "ByPatient", "ByDate", "ByPatientAndDate" };

                // Find all OutputOrganization values in the JSON
                var outputOrgMatches = Regex.Matches(configJson, @"""OutputOrganization""\s*:\s*""([^""]+)""");
                foreach (Match match in outputOrgMatches)
                {
                    var value = match.Groups[1].Value;
                    if (!validOutputOrgValues.Contains(value, StringComparer.OrdinalIgnoreCase))
                    {
                        warnings.Add($"Invalid OutputOrganization value '{value}' found. Valid values are: {string.Join(", ", validOutputOrgValues)}");
                    }
                }

                // Check for invalid PostProcessingAction values
                var validActionValues = new[] { "Leave", "Archive", "Delete", "MoveToError" };

                var actionPatterns = new[]
                {
                    @"""SuccessAction""\s*:\s*""([^""]+)""",
                    @"""FailureAction""\s*:\s*""([^""]+)"""
                };

                foreach (var pattern in actionPatterns)
                {
                    var matches = Regex.Matches(configJson, pattern);
                    foreach (Match match in matches)
                    {
                        var value = match.Groups[1].Value;
                        if (!validActionValues.Contains(value, StringComparer.OrdinalIgnoreCase))
                        {
                            warnings.Add($"Invalid PostProcessingAction value '{value}' found. Valid values are: {string.Join(", ", validActionValues)}");
                        }
                    }
                }

                // Try to parse and count pipelines
                try
                {
                    using var doc = JsonDocument.Parse(configJson);
                    if (doc.RootElement.TryGetProperty("CamBridge", out var camBridge))
                    {
                        if (camBridge.TryGetProperty("Pipelines", out var pipelines))
                        {
                            var totalPipelines = pipelines.GetArrayLength();
                            var validPipelines = 0;

                            foreach (var pipeline in pipelines.EnumerateArray())
                            {
                                var hasValidConfig = true;
                                string? pipelineName = null;

                                if (pipeline.TryGetProperty("Name", out var nameElement))
                                {
                                    pipelineName = nameElement.GetString();
                                }

                                if (pipeline.TryGetProperty("ProcessingOptions", out var options))
                                {
                                    if (options.TryGetProperty("OutputOrganization", out var outputOrg))
                                    {
                                        var value = outputOrg.GetString();
                                        if (!string.IsNullOrEmpty(value) &&
                                            !validOutputOrgValues.Contains(value, StringComparer.OrdinalIgnoreCase))
                                        {
                                            hasValidConfig = false;
                                        }
                                    }
                                }

                                if (hasValidConfig)
                                    validPipelines++;
                                else if (!string.IsNullOrEmpty(pipelineName))
                                    warnings.Add($"Pipeline '{pipelineName}' may not load due to invalid configuration");
                            }

                            if (validPipelines < totalPipelines)
                            {
                                warnings.Add($"Only {validPipelines} of {totalPipelines} pipelines will be loaded due to configuration errors");
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    logger.Warning("Could not parse config for detailed validation: {Message}", ex.Message);
                }

                // Output all warnings
                if (warnings.Any())
                {
                    logger.Warning("âš ï¸ CONFIGURATION WARNINGS âš ï¸");
                    logger.Warning("============================");
                    foreach (var warning in warnings)
                    {
                        logger.Warning("âš ï¸ {Warning}", warning);
                    }
                    logger.Warning("============================");
                    logger.Warning("Service will continue but some pipelines may not load correctly!");
                    logger.Warning("Use the Config Tool to fix these issues.");
                }
                else
                {
                    logger.Information("âœ… Configuration validation passed - no issues found");
                }
            }
            catch (Exception ex)
            {
                logger.Warning("Could not validate configuration: {Message}", ex.Message);
            }
        }
    }
}


================================================================================
FILE: Controllers/StatusController.cs
--------------------------------------------------------------------------------
Size: 11,30 KB | Lines: 278 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Service\Controllers\StatusController.cs
// Version: 0.7.28
// Description: Service status API controller with static methods for minimal API
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using CamBridge.Core;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System.Reflection;
using CamBridge.Core.Infrastructure;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace CamBridge.Service.Controllers
{
    /// <summary>
    /// Service status controller with static methods for minimal API endpoints
    /// </summary>
    public static class StatusController
    {
        private static DateTime _startTime = DateTime.UtcNow;

        /// <summary>
        /// Get service status
        /// </summary>
        public static async Task GetStatus(HttpContext context)
        {
            var pipelineManager = context.RequestServices.GetRequiredService<PipelineManager>();
            var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();

            try
            {
                var pipelineStatuses = pipelineManager.GetPipelineStatuses();

                var status = new
                {
                    service = new
                    {
                        name = ServiceInfo.ServiceName,
                        displayName = ServiceInfo.DisplayName,
                        version = ServiceInfo.Version,
                        status = "Online",
                        timestamp = DateTime.UtcNow,
                        startTime = _startTime,
                        uptime = GetUptime(),
                        processId = Environment.ProcessId
                    },
                    environment = new
                    {
                        machineName = Environment.MachineName,
                        osVersion = Environment.OSVersion.ToString(),
                        processorCount = Environment.ProcessorCount,
                        workingSet = Environment.WorkingSet / (1024 * 1024),
                        dotNetVersion = Environment.Version.ToString()
                    },
                    pipelines = pipelineStatuses.Select(p => new
                    {
                        id = p.Id,
                        name = p.Name,
                        isActive = p.IsActive,
                        queueDepth = p.QueueDepth,
                        processedCount = p.ProcessedCount,
                        errorCount = p.ErrorCount,
                        lastProcessed = p.LastProcessed,
                        watchPath = p.WatchPath,
                        outputPath = p.OutputPath
                    }).ToList(),
                    statistics = new
                    {
                        totalPipelines = pipelineStatuses.Count,
                        activePipelines = pipelineStatuses.Count(p => p.IsActive),
                        totalProcessed = pipelineStatuses.Sum(p => p.ProcessedCount),
                        totalErrors = pipelineStatuses.Sum(p => p.ErrorCount),
                        totalQueued = pipelineStatuses.Sum(p => p.QueueDepth)
                    },
                    configuration = new
                    {
                        path = ConfigurationPaths.GetPrimaryConfigPath(),
                        logsDirectory = ConfigurationPaths.GetLogsDirectory()
                    }
                };

                context.Response.ContentType = "application/json";
                await context.Response.WriteAsJsonAsync(status);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Error getting service status");
                context.Response.StatusCode = 500;
                await context.Response.WriteAsJsonAsync(new { error = "Failed to retrieve service status" });
            }
        }

        /// <summary>
        /// Get just the version string
        /// </summary>
        public static async Task GetVersion(HttpContext context)
        {
            context.Response.ContentType = "text/plain";
            await context.Response.WriteAsync(ServiceInfo.Version);
        }

        /// <summary>
        /// Get health status (minimal endpoint for monitoring)
        /// </summary>
        public static async Task GetHealth(HttpContext context)
        {
            var pipelineManager = context.RequestServices.GetRequiredService<PipelineManager>();

            var pipelineStatuses = pipelineManager.GetPipelineStatuses();

            var health = new
            {
                status = "Healthy",
                version = ServiceInfo.Version,
                timestamp = DateTime.UtcNow,
                activePipelines = pipelineStatuses.Count(p => p.IsActive),
                totalPipelines = pipelineStatuses.Count
            };

            context.Response.ContentType = "application/json";
            await context.Response.WriteAsJsonAsync(health);
        }

        /// <summary>
        /// Get pipeline configurations
        /// </summary>
        public static async Task GetPipelines(HttpContext context)
        {
            var settings = context.RequestServices.GetRequiredService<IOptionsSnapshot<CamBridgeSettingsV2>>();
            var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();

            try
            {
                var pipelines = settings.Value.Pipelines.Select(p => new
                {
                    id = p.Id,
                    name = p.Name,
                    description = p.Description,
                    enabled = p.Enabled,
                    watchPath = p.WatchSettings.Path,
                    watchPattern = p.WatchSettings.FilePattern,
                    includeSubdirectories = p.WatchSettings.IncludeSubdirectories,
                    outputPath = p.WatchSettings.OutputPath,
                    processingOptions = new
                    {
                        outputOrganization = p.ProcessingOptions.OutputOrganization.ToString(),
                        successAction = p.ProcessingOptions.SuccessAction.ToString(),
                        failureAction = p.ProcessingOptions.FailureAction.ToString(),
                        maxConcurrentProcessing = p.ProcessingOptions.MaxConcurrentProcessing,
                        errorFolder = p.ProcessingOptions.ErrorFolder
                    }
                }).ToList();

                context.Response.ContentType = "application/json";
                await context.Response.WriteAsJsonAsync(new
                {
                    count = pipelines.Count,
                    pipelines = pipelines
                });
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Error getting pipeline configurations");
                context.Response.StatusCode = 500;
                await context.Response.WriteAsJsonAsync(new { error = "Failed to retrieve pipeline configurations" });
            }
        }

        /// <summary>
        /// Get detailed status for a specific pipeline
        /// </summary>
        public static async Task GetPipelineDetails(HttpContext context)
        {
            var pipelineManager = context.RequestServices.GetRequiredService<PipelineManager>();
            var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();

            var id = context.Request.RouteValues["id"]?.ToString();
            if (string.IsNullOrEmpty(id))
            {
                context.Response.StatusCode = 400;
                await context.Response.WriteAsJsonAsync(new { error = "Pipeline ID is required" });
                return;
            }

            try
            {
                var status = pipelineManager.GetPipelineStatus(id);
                if (status == null)
                {
                    context.Response.StatusCode = 404;
                    await context.Response.WriteAsJsonAsync(new { error = $"Pipeline '{id}' not found" });
                    return;
                }

                context.Response.ContentType = "application/json";
                await context.Response.WriteAsJsonAsync(status);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Error getting pipeline status for {PipelineId}", id);
                context.Response.StatusCode = 500;
                await context.Response.WriteAsJsonAsync(new { error = "Failed to retrieve pipeline status" });
            }
        }

        /// <summary>
        /// Get statistics (currently returns basic info, expand as needed)
        /// </summary>
        public static async Task GetStatistics(HttpContext context)
        {
            var pipelineManager = context.RequestServices.GetRequiredService<PipelineManager>();
            var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();

            try
            {
                var pipelineStatuses = pipelineManager.GetPipelineStatuses();

                var statistics = new
                {
                    timestamp = DateTime.UtcNow,
                    pipelines = pipelineStatuses.Select(p => new
                    {
                        id = p.Id,
                        name = p.Name,
                        processedCount = p.ProcessedCount,
                        errorCount = p.ErrorCount,
                        successCount = p.ProcessedCount - p.ErrorCount,
                        queueDepth = p.QueueDepth,
                        isActive = p.IsActive,
                        lastProcessed = p.LastProcessed
                    }).ToList(),
                    summary = new
                    {
                        totalPipelines = pipelineStatuses.Count,
                        activePipelines = pipelineStatuses.Count(p => p.IsActive),
                        totalProcessed = pipelineStatuses.Sum(p => p.ProcessedCount),
                        totalErrors = pipelineStatuses.Sum(p => p.ErrorCount),
                        totalQueued = pipelineStatuses.Sum(p => p.QueueDepth)
                    }
                };

                context.Response.ContentType = "application/json";
                await context.Response.WriteAsJsonAsync(statistics);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Error getting statistics");
                context.Response.StatusCode = 500;
                await context.Response.WriteAsJsonAsync(new { error = "Failed to retrieve statistics" });
            }
        }

        private static string GetUptime()
        {
            var uptime = DateTime.UtcNow - _startTime;

            if (uptime.TotalDays >= 1)
            {
                return $"{(int)uptime.TotalDays}d {uptime.Hours}h {uptime.Minutes}m";
            }
            else if (uptime.TotalHours >= 1)
            {
                return $"{(int)uptime.TotalHours}h {uptime.Minutes}m";
            }
            else
            {
                return $"{(int)uptime.TotalMinutes}m";
            }
        }
    }
}


================================================================================
FILE: mappings.json
--------------------------------------------------------------------------------
Size: 2,36 KB | Lines: 96 | Modified: 2025-06-01 22:37:18
================================================================================

{
  "version": "1.0",
  "description": "CamBridge EXIF to DICOM mapping configuration for Ricoh G900 II with QRBridge",
  "mappings": [
    {
      "name": "PatientName",
      "sourceType": "QRBridge",
      "sourceField": "name",
      "targetTag": "(0010,0010)",
      "transform": "None",
      "required": true
    },
    {
      "name": "PatientID",
      "sourceType": "QRBridge",
      "sourceField": "patientid",
      "targetTag": "(0010,0020)",
      "transform": "None",
      "required": true
    },
    {
      "name": "PatientBirthDate",
      "sourceType": "QRBridge",
      "sourceField": "birthdate",
      "targetTag": "(0010,0030)",
      "transform": "DateToDicom",
      "required": false
    },
    {
      "name": "PatientSex",
      "sourceType": "QRBridge",
      "sourceField": "gender",
      "targetTag": "(0010,0040)",
      "transform": "GenderToDicom",
      "required": false,
      "defaultValue": "O"
    },
    {
      "name": "StudyDescription",
      "sourceType": "QRBridge",
      "sourceField": "comment",
      "targetTag": "(0008,1030)",
      "transform": "None",
      "required": false
    },
    {
      "name": "StudyID",
      "sourceType": "QRBridge",
      "sourceField": "examid",
      "targetTag": "(0020,0010)",
      "transform": "TruncateTo16",
      "required": false
    },
    {
      "name": "Manufacturer",
      "sourceType": "EXIF",
      "sourceField": "Make",
      "targetTag": "(0008,0070)",
      "transform": "None",
      "required": false
    },
    {
      "name": "ManufacturerModelName",
      "sourceType": "EXIF",
      "sourceField": "Model",
      "targetTag": "(0008,1090)",
      "transform": "None",
      "required": false
    },
    {
      "name": "SoftwareVersions",
      "sourceType": "EXIF",
      "sourceField": "Software",
      "targetTag": "(0018,1020)",
      "transform": "None",
      "required": false
    },
    {
      "name": "AcquisitionDateTime",
      "sourceType": "EXIF",
      "sourceField": "DateTimeOriginal",
      "targetTag": "(0008,002A)",
      "transform": "DateToDicom",
      "required": false
    },
    {
      "name": "PatientComments",
      "sourceType": "QRBridge",
      "sourceField": "comment",
      "targetTag": "(0010,4000)",
      "transform": "None",
      "required": false
    }
  ]
}


================================================================================
FILE: obj/Release/net8.0-windows/win-x64/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
--------------------------------------------------------------------------------
Size: 198 bytes | Lines: 5 | Modified: 2025-06-23 19:50:05
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: obj/Release/net8.0-windows/win-x64/CamBridge.Service.AssemblyInfo.cs
--------------------------------------------------------------------------------
Size: 1,58 KB | Lines: 29 | Modified: 2025-06-23 19:50:05
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.0+a2bed238060f0dad03d59d67aabd71062e685301")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Service")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows7.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows7.0")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: obj/Release/net8.0-windows/win-x64/rpswa.dswa.cache.json
--------------------------------------------------------------------------------
Size: 374 bytes | Lines: 1 | Modified: 2025-06-23 19:50:05
================================================================================

{"GlobalPropertiesHash":"7ReMT80xGIvUo2PfSVIosuTDhfLp0HbPGqmxT94Yu9s=","FingerprintPatternsHash":"gq3WsqcKBUGTSNle7RKKyXRIwh7M8ccEqOqYvIzoM04=","PropertyOverridesHash":"8ZRc1sGeVrPBx4lD717BgRaQekyh78QKV9SKsdt638U=","InputHashes":["HtMhclNXvGuiF0p83OI9xfUD\u002BwrdoiNT6XVrtNRhcfw=","qNQaR8ki02Vmsl1QA2pq0Vuh9mChEPXPz5/LrFYvk8E="],"CachedAssets":{},"CachedCopyCandidates":{}}

================================================================================
FILE: Program.cs
--------------------------------------------------------------------------------
Size: 13,56 KB | Lines: 361 | Modified: 2025-06-23 13:54:02
================================================================================

// src/CamBridge.Service/Program.cs
// Version: 0.7.28
// Description: Windows service entry point with corrected log levels
// Copyright: Ã‚Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.Infrastructure;
using CamBridge.Infrastructure;
using CamBridge.Infrastructure.Services;
using CamBridge.Service;
using CamBridge.Service.Controllers;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Serilog;
using Serilog.Events;
using Serilog.Filters;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

// Register encoding provider for Windows-1252 support (needed for Ricoh EXIF data)
System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);

// Set service start time
Program.ServiceStartTime = DateTime.UtcNow;

// Windows Event Log for Debugging
EventLog? serviceEventLog = null;
try
{
    // Try to create event source if not exists
    if (!EventLog.SourceExists(ServiceInfo.ServiceName))
    {
        EventLog.CreateEventSource(ServiceInfo.ServiceName, "Application");
    }

    serviceEventLog = new EventLog("Application");
    serviceEventLog.Source = ServiceInfo.ServiceName;
    serviceEventLog.WriteEntry($"{ServiceInfo.GetFullVersionString()} starting...", EventLogEntryType.Information, 1000);
}
catch (Exception ex)
{
    // Ignore if we can't write to event log (permissions)
    Console.WriteLine($"Could not initialize Event Log: {ex.Message}");
}

// Better service detection
var isService = false;
try
{
    // More reliable check using command line args first
    if (args.Contains("--console") || args.Contains("-c"))
    {
        isService = false;
        serviceEventLog?.WriteEntry("Running in console mode (explicit parameter)", EventLogEntryType.Information, 1001);
    }
    else if (args.Contains("--service"))
    {
        isService = true;
        serviceEventLog?.WriteEntry("Running as Windows Service (explicit parameter)", EventLogEntryType.Information, 1002);
    }
    else
    {
        // Fallback to environment check
        isService = !Environment.UserInteractive;
        serviceEventLog?.WriteEntry($"Running as: {(isService ? "Service" : "Console")} (auto-detected)", EventLogEntryType.Information, 1003);
    }
}
catch (Exception ex)
{
    serviceEventLog?.WriteEntry($"Error detecting service mode: {ex.Message}", EventLogEntryType.Error, 1004);
}

// Configure Serilog with TRUE multi-pipeline support
try
{
    var baseLogPath = ConfigurationPaths.GetLogsDirectory();

    // Ensure logs directory exists
    Directory.CreateDirectory(baseLogPath);

    // Load config to get pipeline names
    var configPath = ConfigurationPaths.GetPrimaryConfigPath();
    var configuration = new ConfigurationBuilder()
        .AddJsonFile(configPath, optional: true)
        .Build();

    var settings = new CamBridgeSettingsV2();
    configuration.GetSection("CamBridge").Bind(settings);

    var logConfig = new LoggerConfiguration()
        .MinimumLevel.Debug()
        .MinimumLevel.Override("Microsoft", LogEventLevel.Warning)
        .MinimumLevel.Override("System", LogEventLevel.Warning)
        .Enrich.FromLogContext()

        // Global service log - everything EXCEPT pipeline logs
        .WriteTo.Logger(lc => lc
            .Filter.ByExcluding(evt =>
                evt.Properties.ContainsKey("SourceContext") &&
                evt.Properties["SourceContext"].ToString().Contains("Pipeline."))
            .WriteTo.File(
                path: Path.Combine(baseLogPath, "service_.log"),
                rollingInterval: RollingInterval.Day,
                retainedFileCountLimit: 30,
                outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}",
                shared: true))

        // Event Log for service events
        .WriteTo.EventLog(ServiceInfo.ServiceName, "Application", manageEventSource: false)

        // Console output when not running as service
        .WriteTo.Conditional(
            _ => !isService,
            wt => wt.Console(outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}"));

    // Create a separate log file for each pipeline
    if (settings?.Pipelines != null)
    {
        foreach (var pipeline in settings.Pipelines)
        {
            var sanitizedName = SanitizeForFileName(pipeline.Name);
            var pipelineContext = $"Pipeline.{sanitizedName}";

            logConfig.WriteTo.Logger(lc => lc
                .Filter.ByIncludingOnly(evt =>
                    evt.Properties.ContainsKey("SourceContext") &&
                    evt.Properties["SourceContext"].ToString().Contains(pipelineContext))
                .WriteTo.File(
                    path: Path.Combine(baseLogPath, $"pipeline_{sanitizedName}_.log"),
                    rollingInterval: RollingInterval.Day,
                    retainedFileCountLimit: 30,
                    outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}",
                    shared: true));

            // Changed to DEBUG level
            Log.Debug("Configured logging for pipeline: {Pipeline} -> {LogFile}",
                pipeline.Name, $"pipeline_{sanitizedName}_{{Date}}.log");
        }
    }

    Log.Logger = logConfig.CreateLogger();

    // Changed to DEBUG level
    Log.Debug("Serilog configured with TRUE multi-pipeline support at {LogPath}", baseLogPath);
    serviceEventLog?.WriteEntry($"Logging initialized with separate pipeline logs at: {baseLogPath}", EventLogEntryType.Information, 1005);
}
catch (Exception ex)
{
    serviceEventLog?.WriteEntry($"Failed to configure Serilog: {ex.Message}", EventLogEntryType.Error, 1006);
    throw;
}

try
{
    Log.Information("=== CamBridge Service Starting ===");
    Log.Information("Version: {Version}", ServiceInfo.GetFullVersionString());
    Log.Information("Running as: {Mode}", isService ? "Windows Service" : "Console Application");

    var builder = Host.CreateDefaultBuilder(args);

    // Use proper configuration for service vs console
    if (isService)
    {
        builder.UseWindowsService(options =>
        {
            options.ServiceName = ServiceInfo.ServiceName;
        });
    }

    builder
        .UseSerilog() // Use Serilog as the logging provider
        .ConfigureAppConfiguration((context, config) =>
        {
            // Clear default sources to have full control
            config.Sources.Clear();

            // Use centralized configuration path
            var configPath = ConfigurationPaths.GetPrimaryConfigPath();
            Log.Debug("Loading configuration from: {ConfigPath}", configPath); // Changed to DEBUG

            // Initialize config if needed
            if (!File.Exists(configPath))
            {
                ConfigurationPaths.InitializePrimaryConfig();
                Log.Warning("Configuration file not found. Created default at: {ConfigPath}", configPath);
            }

            // Load configuration from our single source
            config.AddJsonFile(configPath, optional: false, reloadOnChange: true);

            // Add environment variables for override capability
            config.AddEnvironmentVariables("CAMBRIDGE_");

            // Add command line args last (highest priority)
            if (args != null)
            {
                config.AddCommandLine(args);
            }
        })
        .ConfigureServices((context, services) =>
        {
            var configuration = context.Configuration;

            // Configure settings with validation
            services.Configure<CamBridgeSettingsV2>(options =>
            {
                var cambridgeSection = configuration.GetSection("CamBridge");
                if (!cambridgeSection.Exists())
                {
                    throw new InvalidOperationException(
                        "Configuration is missing required 'CamBridge' section. " +
                        "Expected format: { \"CamBridge\": { \"Version\": \"2.0\", ... } }");
                }

                cambridgeSection.Bind(options);

                // Validate configuration structure
                ConfigValidator.ValidateSettings(options);

                // Validate configuration file for enum values
                var configPath = ConfigurationPaths.GetPrimaryConfigPath();
                ConfigValidator.ValidateAndWarn(configPath, Log.Logger);
            });

            // Register notification settings separately
            services.Configure<NotificationSettings>(configuration.GetSection("CamBridge:NotificationSettings"));

            // Register core services
            services.AddSingleton<DicomConverter>();
            services.AddSingleton<NotificationService>();
            // Register ExifToolReader with path from configuration
            services.AddSingleton<ExifToolReader>(sp =>
            {
                var settings = sp.GetRequiredService<IOptionsMonitor<CamBridgeSettingsV2>>().CurrentValue;
                return new ExifToolReader(
                    sp.GetRequiredService<ILogger<ExifToolReader>>(),
                    settings.ExifToolPath ?? "Tools\\exiftool.exe"
                );
            });

            // PipelineManager as singleton - manages all pipelines
            services.AddSingleton<PipelineManager>();

            // Background services
            services.AddHostedService<Worker>();
            //services.AddHostedService<DailySummaryService>(); // Activated!

            // Add health checks
            services.AddHealthChecks()
                .AddCheck<CamBridgeHealthCheck>("cambridge");

            // Add IHttpClientFactory for better HTTP client management
            services.AddHttpClient();
        })
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel()
                .UseUrls("http://localhost:5111") // CRITICAL: Port 5111!
                .Configure(app =>
                {
                    app.UseRouting();
                    app.UseHealthChecks("/health");

                    app.UseEndpoints(endpoints =>
                    {
                        // Service info endpoint
                        endpoints.MapGet("/", async context =>
                        {
                            context.Response.ContentType = "application/json";
                            var info = new
                            {
                                service = ServiceInfo.ServiceName,
                                version = ServiceInfo.Version,
                                status = "running",
                                timestamp = DateTime.UtcNow
                            };
                            await context.Response.WriteAsJsonAsync(info);
                        });

                        // API endpoints
                        endpoints.MapGet("/api/status", StatusController.GetStatus);
                        endpoints.MapGet("/api/status/version", StatusController.GetVersion);
                        endpoints.MapGet("/api/status/health", StatusController.GetHealth);
                        endpoints.MapGet("/api/pipelines", StatusController.GetPipelines);
                        endpoints.MapGet("/api/pipelines/{id}", StatusController.GetPipelineDetails);
                        endpoints.MapGet("/api/statistics", StatusController.GetStatistics);
                    });
                });
        });

    var host = builder.Build();

    // Test configuration loading (non-production diagnostic)
    using (var scope = host.Services.CreateScope())
    {
        var settings = scope.ServiceProvider.GetService<IOptionsSnapshot<CamBridgeSettingsV2>>();
        if (settings?.Value != null)
        {
            // Changed to DEBUG level
            Log.Debug("Configuration loaded successfully:");
            Log.Debug("  Version: {Version}", settings.Value.Version);
            Log.Debug("  Pipelines: {Count}", settings.Value.Pipelines.Count);
            Log.Debug("  Service Port: {Port}", settings.Value.Service?.ApiPort ?? 5111);
        }
        else
        {
            Log.Warning("Failed to load configuration!");
        }
    }

    await host.RunAsync();
}
catch (Exception ex)
{
    var message = $"Fatal error: {ex.Message}";
    Log.Fatal(ex, "Application terminated unexpectedly");
    serviceEventLog?.WriteEntry(message, EventLogEntryType.Error, 9999);
    return 1;
}
finally
{
    Log.Information("=== CamBridge Service Stopped ===");
    Log.CloseAndFlush();
}

return 0;

// Helper method to sanitize pipeline names for file names
static string SanitizeForFileName(string pipelineName)
{
    var invalid = Path.GetInvalidFileNameChars()
        .Concat(new[] { ' ', '.', ',', '/', '\\', ':', '-' })
        .Distinct()
        .ToArray();

    var sanitized = string.Join("_", pipelineName.Split(invalid, StringSplitOptions.RemoveEmptyEntries));

    if (sanitized.Length > 100)
    {
        sanitized = sanitized.Substring(0, 97) + "...";
    }

    return sanitized;
}

// Static class to hold service start time
public partial class Program
{
    public static DateTime ServiceStartTime { get; set; }
}


================================================================================
FILE: Properties/launchSettings.json
--------------------------------------------------------------------------------
Size: 285 bytes | Lines: 13 | Modified: 2025-05-30 18:26:36
================================================================================

{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "profiles": {
    "CamBridge.Service": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "environmentVariables": {
        "DOTNET_ENVIRONMENT": "Development"
      }
    }
  }
}


================================================================================
FILE: ServiceInfo.cs
--------------------------------------------------------------------------------
Size: 4,62 KB | Lines: 134 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Service/ServiceInfo.cs
// Version: 0.7.15
// Description: Central service version and metadata information
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System.Diagnostics;
using System.Reflection;

namespace CamBridge.Service
{
    /// <summary>
    /// Central location for all service version and metadata information
    /// Version is now dynamically read from assembly attributes!
    /// </summary>
    public static class ServiceInfo
    {
        /// <summary>
        /// Current version of the service - dynamically read from assembly
        /// This now automatically uses Version.props values!
        /// </summary>
        public static string Version
        {
            get
            {
                try
                {
                    var assembly = Assembly.GetExecutingAssembly();
                    var fileVersionInfo = FileVersionInfo.GetVersionInfo(assembly.Location);

                    // Try FileVersion first (from Version.props FileVersion)
                    if (!string.IsNullOrEmpty(fileVersionInfo.FileVersion))
                    {
                        // Remove trailing .0 if present (e.g., 0.7.15.0 -> 0.7.15)
                        var version = fileVersionInfo.FileVersion;
                        if (version.EndsWith(".0"))
                            version = version.Substring(0, version.LastIndexOf(".0"));
                        return version;
                    }

                    // Fallback to ProductVersion
                    if (!string.IsNullOrEmpty(fileVersionInfo.ProductVersion))
                    {
                        // Handle versions with commit hash (e.g., "0.7.15+abc123")
                        var productVersion = fileVersionInfo.ProductVersion;
                        var plusIndex = productVersion.IndexOf('+');
                        if (plusIndex > 0)
                            return productVersion.Substring(0, plusIndex);
                        return productVersion;
                    }

                    // Last fallback to assembly version
                    var assemblyVersion = assembly.GetName().Version;
                    if (assemblyVersion != null)
                        return $"{assemblyVersion.Major}.{assemblyVersion.Minor}.{assemblyVersion.Build}";

                    return "0.7.15"; // Emergency fallback
                }
                catch
                {
                    return "0.7.15"; // Emergency fallback
                }
            }
        }

        /// <summary>
        /// Service name as registered in Windows
        /// </summary>
        public const string ServiceName = "CamBridgeService";

        /// <summary>
        /// Display name shown in Services Manager
        /// </summary>
        public const string DisplayName = "CamBridge Medical Image Converter";

        /// <summary>
        /// Service description
        /// </summary>
        public const string Description = "Converts JPEG images from Ricoh cameras to DICOM format for medical imaging systems";

        /// <summary>
        /// Copyright notice
        /// </summary>
        public const string Copyright = "Â© 2025 Claude's Improbably Reliable Software Solutions";

        /// <summary>
        /// Company name from version information
        /// </summary>
        public static string Company
        {
            get
            {
                try
                {
                    var assembly = Assembly.GetExecutingAssembly();
                    var fileVersionInfo = FileVersionInfo.GetVersionInfo(assembly.Location);
                    return fileVersionInfo.CompanyName ?? "Claude's Improbably Reliable Software Solutions";
                }
                catch
                {
                    return "Claude's Improbably Reliable Software Solutions";
                }
            }
        }

        /// <summary>
        /// API Port for HTTP endpoints
        /// </summary>
        public const int ApiPort = 5111;

        /// <summary>
        /// Gets the full version string with product name
        /// </summary>
        public static string GetFullVersionString()
        {
            return $"{DisplayName} v{Version}";
        }

        /// <summary>
        /// Gets build configuration (Debug/Release)
        /// </summary>
        public static string BuildConfiguration
        {
            get
            {
#if DEBUG
                return "Debug";
#else
                return "Release";
#endif
            }
        }
    }
}


================================================================================
FILE: Worker.cs
--------------------------------------------------------------------------------
Size: 10,10 KB | Lines: 256 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Service/Worker.cs
// Version: 0.7.28
// Description: Main worker service with fixed shutdown handling
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace CamBridge.Service
{
    /// <summary>
    /// Main worker service that manages the pipeline infrastructure
    /// </summary>
    public class Worker : BackgroundService
    {
        private readonly ILogger<Worker> _logger;
        private readonly PipelineManager _pipelineManager;
        private readonly IOptionsMonitor<CamBridgeSettingsV2> _settingsMonitor;
        private readonly IHostApplicationLifetime _lifetime;
        private Timer? _statusTimer;

        public Worker(
            ILogger<Worker> logger,
            PipelineManager pipelineManager,
            IOptionsMonitor<CamBridgeSettingsV2> settingsMonitor,
            IHostApplicationLifetime lifetime)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _pipelineManager = pipelineManager ?? throw new ArgumentNullException(nameof(pipelineManager));
            _settingsMonitor = settingsMonitor ?? throw new ArgumentNullException(nameof(settingsMonitor));
            _lifetime = lifetime ?? throw new ArgumentNullException(nameof(lifetime));
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            try
            {
                _logger.LogInformation("{ServiceName} starting",
                    ServiceInfo.GetFullVersionString());

                var settings = _settingsMonitor.CurrentValue;

                // Startup delay if configured
                if (settings.Service.StartupDelaySeconds > 0)
                {
                    _logger.LogInformation("Waiting {Delay} seconds before starting...",
                        settings.Service.StartupDelaySeconds);
                    await Task.Delay(TimeSpan.FromSeconds(settings.Service.StartupDelaySeconds), stoppingToken);
                }

                // Start all configured pipelines
                await _pipelineManager.StartAsync(stoppingToken);

                // Get initial status
                var statuses = _pipelineManager.GetPipelineStatuses();
                _logger.LogInformation("CamBridge Service started with {PipelineCount} pipelines",
                    statuses.Count);

                // Log active pipelines - keeping as INFO because it's important startup info
                foreach (var status in statuses.Where(s => s.IsActive))
                {
                    _logger.LogInformation("Pipeline '{PipelineName}' active - watching {WatchPath}",
                        status.Name, status.WatchPath);
                }

                // Setup status reporting timer
                _statusTimer = new Timer(
                    ReportStatus,
                    null,
                    TimeSpan.FromSeconds(30), // Initial delay
                    TimeSpan.FromSeconds(30)  // Report every 30 seconds
                );

                // Keep service running
                while (!stoppingToken.IsCancellationRequested)
                {
                    await Task.Delay(1000, stoppingToken);
                    CheckPipelineHealth();
                }
            }
            catch (OperationCanceledException)
            {
                // This is NORMAL during shutdown - don't log as error!
                _logger.LogInformation("Service shutdown requested");
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Fatal error in CamBridge Service");
                throw;
            }
            finally
            {
                _logger.LogInformation("CamBridge Service shutting down");

                // Stop status timer
                _statusTimer?.Dispose();

                // Stop all pipelines
                try
                {
                    await _pipelineManager.StopAsync();
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error stopping pipeline manager");
                }

                // Final statistics
                ReportFinalStatistics();

                _logger.LogInformation("CamBridge Service stopped");
            }
        }

        private void ReportStatus(object? state)
        {
            try
            {
                var statuses = _pipelineManager.GetPipelineStatuses();

                // Summary statistics
                var totalQueued = statuses.Sum(s => s.QueueDepth);
                var totalProcessed = statuses.Sum(s => s.ProcessedCount);
                var totalErrors = statuses.Sum(s => s.ErrorCount);
                var totalActive = statuses.Count(s => s.IsActive);

                // Only log if there's activity - keeping as INFO because it's important operational status
                if (totalProcessed > 0 || totalQueued > 0 || totalErrors > 0)
                {
                    _logger.LogInformation(
                        "Service Status - Pipelines: {PipelineCount} ({ActiveCount} active), " +
                        "Queue: {QueueLength}, Total: {TotalProcessed} (Errors: {Errors})",
                        statuses.Count,
                        totalActive,
                        totalQueued,
                        totalProcessed,
                        totalErrors);

                    // Report per-pipeline status if multiple pipelines and there's activity
                    if (statuses.Count > 1)
                    {
                        foreach (var pipeline in statuses.Where(s => s.IsActive))
                        {
                            if (pipeline.ProcessedCount > 0 || pipeline.QueueDepth > 0 || pipeline.ErrorCount > 0)
                            {
                                _logger.LogInformation(
                                    "  Pipeline '{Name}': Queue: {Queue}, Processed: {Processed}, Errors: {Errors}",
                                    pipeline.Name,
                                    pipeline.QueueDepth,
                                    pipeline.ProcessedCount,
                                    pipeline.ErrorCount);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error reporting status");
            }
        }

        private void CheckPipelineHealth()
        {
            try
            {
                var statuses = _pipelineManager.GetPipelineStatuses();

                foreach (var pipeline in statuses)
                {
                    // Check for high failure rates
                    if (pipeline.ProcessedCount > 100)
                    {
                        var failureRate = (double)pipeline.ErrorCount / pipeline.ProcessedCount;
                        if (failureRate > 0.5) // 50% failure rate
                        {
                            _logger.LogWarning(
                                "Pipeline '{PipelineName}' has high failure rate: {FailureRate:P}",
                                pipeline.Name, failureRate);
                        }
                    }

                    // Check for large queue backlogs
                    if (pipeline.QueueDepth > 1000)
                    {
                        _logger.LogWarning(
                            "Pipeline '{PipelineName}' has large queue backlog: {QueueLength} files",
                            pipeline.Name, pipeline.QueueDepth);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking pipeline health");
            }
        }

        private void ReportFinalStatistics()
        {
            try
            {
                var statuses = _pipelineManager.GetPipelineStatuses();

                _logger.LogInformation("=== Final Pipeline Statistics ===");

                foreach (var pipeline in statuses)
                {
                    if (pipeline.ProcessedCount > 0)
                    {
                        var successRate = pipeline.ProcessedCount > 0
                            ? (double)(pipeline.ProcessedCount - pipeline.ErrorCount) / pipeline.ProcessedCount * 100
                            : 0;

                        _logger.LogInformation(
                            "Pipeline '{Name}': Total: {Total}, Success: {Success} ({SuccessRate:F1}%), Failed: {Failed}",
                            pipeline.Name,
                            pipeline.ProcessedCount,
                            pipeline.ProcessedCount - pipeline.ErrorCount,
                            successRate,
                            pipeline.ErrorCount);
                    }
                }

                var totalProcessed = statuses.Sum(s => s.ProcessedCount);
                var totalErrors = statuses.Sum(s => s.ErrorCount);
                var totalSuccessful = totalProcessed - totalErrors;

                if (totalProcessed > 0)
                {
                    _logger.LogInformation(
                        "Overall: Total: {Total}, Success: {Success}, Failed: {Failed}",
                        totalProcessed, totalSuccessful, totalErrors);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error reporting final statistics");
            }
        }

        public override async Task StopAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation("CamBridge Service stop requested");
            await base.StopAsync(cancellationToken);
        }
    }
}

