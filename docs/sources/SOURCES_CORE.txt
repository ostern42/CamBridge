# CamBridge Sources - CORE
# Generated: 2025-07-01 14:22:48
# Version: 0.7.11
# Purpose: Complete source code for project knowledge
# Token-efficient access to all implementations


================================================================================
FILE: src\CamBridge.Core\CamBridgeSettingsV2.cs
================================================================================

// src\CamBridge.Core\CamBridgeSettingsV2.cs
// Version: 0.8.6
// Description: Version 2 settings with pipeline architecture and hierarchical logging support
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;
using CamBridge.Core.Enums; // FIXED: Use LogVerbosity from Enums namespace

namespace CamBridge.Core
{
    /// <summary>
    /// Version 2 configuration with pipeline-based architecture
    /// CLEAN: No more legacy workarounds!
    /// </summary>
    public class CamBridgeSettingsV2
    {
        /// <summary>
        /// Settings version for future compatibility
        /// </summary>
        public string Version { get; set; } = "2.0";

        /// <summary>
        /// List of configured pipelines
        /// </summary>
        public List<PipelineConfiguration> Pipelines { get; set; } = new();

        /// <summary>
        /// Reusable mapping sets
        /// </summary>
        public List<MappingSet> MappingSets { get; set; } = new();

        /// <summary>
        /// Global DICOM settings (can be overridden per pipeline)
        /// </summary>
        public DicomSettings GlobalDicomSettings { get; set; } = new();

        /// <summary>
        /// Global defaults for new pipelines
        /// </summary>
        public ProcessingOptions DefaultProcessingOptions { get; set; } = new();

        /// <summary>
        /// Logging configuration (remains global)
        /// </summary>
        public LoggingSettings Logging { get; set; } = new();

        /// <summary>
        /// Service configuration (remains global)
        /// </summary>
        public ServiceSettings Service { get; set; } = new();

        /// <summary>
        /// Notification settings (remains global)
        /// </summary>
        public NotificationSettings Notifications { get; set; } = new();

        /// <summary>
        /// ExifTool executable path (global setting)
        /// </summary>
        public string ExifToolPath { get; set; } = "Tools\\exiftool.exe";

        /// <summary>
        /// Validate the configuration
        /// </summary>
        [JsonIgnore]
        public bool IsValid
        {
            get
            {
                // At least one pipeline must be configured
                if (Pipelines.Count == 0)
                    return false;

                // All enabled pipelines must be valid
                if (Pipelines.Any(p => p.Enabled && !p.IsValid))
                    return false;

                // All pipelines must have valid mapping sets
                var mappingSetIds = MappingSets.Select(m => m.Id).ToHashSet();
                if (Pipelines.Any(p => p.MappingSetId.HasValue && !mappingSetIds.Contains(p.MappingSetId.Value)))
                    return false;

                return true;
            }
        }
    }

    /// <summary>
    /// DICOM-specific settings
    /// </summary>
    public class DicomSettings
    {
        /// <summary>
        /// Implementation Class UID for this application
        /// </summary>
        public string ImplementationClassUid { get; set; } = "1.2.276.0.7230010.3.0.3.6.4";

        /// <summary>
        /// Implementation Version Name
        /// </summary>
        public string ImplementationVersionName { get; set; } = "CAMBRIDGE_001";

        /// <summary>
        /// Source Application Entity Title
        /// </summary>
        public string SourceApplicationEntityTitle { get; set; } = "CAMBRIDGE";

        /// <summary>
        /// Institution Name
        /// </summary>
        public string? InstitutionName { get; set; }

        /// <summary>
        /// Institution Department
        /// </summary>
        public string? InstitutionDepartment { get; set; }

        /// <summary>
        /// Station Name
        /// </summary>
        public string? StationName { get; set; }

        /// <summary>
        /// Modality for created images
        /// </summary>
        public string Modality { get; set; } = "OT"; // Other

        /// <summary>
        /// Validate DICOM files after creation
        /// </summary>
        public bool ValidateAfterCreation { get; set; } = true;
    }

    /// <summary>
    /// Logging configuration
    /// </summary>
    public class LoggingSettings
    {
        /// <summary>
        /// Minimum log level (Trace, Debug, Information, Warning, Error, Critical)
        /// </summary>
        public string LogLevel { get; set; } = "Information";

        /// <summary>
        /// Log folder path
        /// </summary>
        public string LogFolder { get; set; } = @"C:\CamBridge\Logs";

        /// <summary>
        /// Enable file logging
        /// </summary>
        public bool EnableFileLogging { get; set; } = true;

        /// <summary>
        /// Enable Windows Event Log
        /// </summary>
        public bool EnableEventLog { get; set; } = true;

        /// <summary>
        /// Maximum log file size in MB
        /// </summary>
        public int MaxLogFileSizeMB { get; set; } = 10;

        /// <summary>
        /// Maximum number of log files to retain
        /// </summary>
        public int MaxLogFiles { get; set; } = 10;
    }

    /// <summary>
    /// Windows Service specific settings with enhanced logging control
    /// </summary>
    public class ServiceSettings
    {
        /// <summary>
        /// Service name (for sc.exe)
        /// </summary>
        public string ServiceName { get; set; } = "CamBridgeService";

        /// <summary>
        /// Service display name
        /// </summary>
        public string DisplayName { get; set; } = "CamBridge JPEG to DICOM Converter";

        /// <summary>
        /// Service description
        /// </summary>
        public string Description { get; set; } = "Monitors folders for JPEG files from Ricoh cameras and converts them to DICOM format";

        /// <summary>
        /// Startup delay in seconds
        /// </summary>
        public int StartupDelaySeconds { get; set; } = 5;

        /// <summary>
        /// File processing delay in milliseconds
        /// </summary>
        public int FileProcessingDelayMs { get; set; } = 500;

        /// <summary>
        /// API port for web interface
        /// </summary>
        public int ApiPort { get; set; } = 5111;

        /// <summary>
        /// Global log verbosity level for all pipelines
        /// Controls how much detail is logged during processing
        /// </summary>
        public LogVerbosity LogVerbosity { get; set; } = LogVerbosity.Detailed;
    }

    /// <summary>
    /// Configuration for the notification system
    /// Part of SystemSettings - Compatible with legacy NotificationService
    /// </summary>
    public class NotificationSettings
    {
        /// <summary>
        /// Enable or disable the notification system
        /// </summary>
        public bool Enabled { get; set; } = true;

        // === LEGACY PROPERTIES FOR COMPATIBILITY ===

        /// <summary>
        /// Enable Windows Event Log notifications
        /// </summary>
        public bool EnableEventLog { get; set; } = true;

        /// <summary>
        /// Enable email notifications
        /// </summary>
        public bool EnableEmail { get; set; } = false;

        /// <summary>
        /// Minimum log level for email notifications (0=Trace, 1=Debug, 2=Info, 3=Warning, 4=Error, 5=Critical)
        /// </summary>
        public int MinimumEmailLevel { get; set; } = 4; // Error level

        /// <summary>
        /// Dead letter queue threshold for notifications
        /// </summary>
        public int DeadLetterThreshold { get; set; } = 100;

        /// <summary>
        /// Send daily summary emails
        /// </summary>
        public bool SendDailySummary { get; set; } = true;

        /// <summary>
        /// Hour to send daily summary (0-23)
        /// </summary>
        public int DailySummaryHour { get; set; } = 8;

        // === NEW STRUCTURED PROPERTIES ===

        /// <summary>
        /// Email notification settings
        /// </summary>
        public EmailSettings Email { get; set; } = new();

        /// <summary>
        /// Windows Event Log settings
        /// </summary>
        public EventLogSettings EventLog { get; set; } = new();

        /// <summary>
        /// Webhook notification settings
        /// </summary>
        public WebhookSettings Webhook { get; set; } = new();

        /// <summary>
        /// Notification rules and filters
        /// </summary>
        public NotificationRules Rules { get; set; } = new();
    }

    public class EmailSettings
    {
        public bool Enabled { get; set; } = false;

        // Legacy properties for compatibility
        public string SmtpHost { get; set; } = string.Empty;
        public string From { get; set; } = string.Empty;
        public string To { get; set; } = string.Empty;

        // New structured properties
        public string SmtpServer { get; set; } = string.Empty;
        public int SmtpPort { get; set; } = 587;
        public bool UseSsl { get; set; } = true;
        public string Username { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty; // Should be encrypted in production
        public string FromAddress { get; set; } = string.Empty;
        public string FromDisplayName { get; set; } = "CamBridge Service";
        public List<string> ToAddresses { get; set; } = new();
        public List<string> CcAddresses { get; set; } = new();
        public string SubjectPrefix { get; set; } = "[CamBridge]";
        public int TimeoutSeconds { get; set; } = 30;

        /// <summary>
        /// Legacy compatibility - returns first address from ToAddresses
        /// </summary>
        public string GetPrimaryToAddress() => ToAddresses?.FirstOrDefault() ?? To;

        /// <summary>
        /// Legacy compatibility - sets both To and ToAddresses
        /// </summary>
        public void SetToAddress(string address)
        {
            To = address;
            if (!string.IsNullOrEmpty(address) && !ToAddresses.Contains(address))
            {
                ToAddresses.Add(address);
            }
        }
    }

    public class EventLogSettings
    {
        public bool Enabled { get; set; } = true;
        public string LogName { get; set; } = "Application";
        public string SourceName { get; set; } = "CamBridge";
        public bool CreateSourceIfMissing { get; set; } = true;
    }

    public class WebhookSettings
    {
        public bool Enabled { get; set; } = false;
        public string Url { get; set; } = string.Empty;
        public string Method { get; set; } = "POST";
        public Dictionary<string, string> Headers { get; set; } = new();
        public string ContentType { get; set; } = "application/json";
        public int TimeoutSeconds { get; set; } = 30;
        public int RetryCount { get; set; } = 3;
        public int RetryDelaySeconds { get; set; } = 5;
    }

    public class NotificationRules
    {
        /// <summary>
        /// Minimum time between notifications of the same type (anti-spam)
        /// </summary>
        public int MinimumIntervalMinutes { get; set; } = 5;

        /// <summary>
        /// Events that trigger notifications
        /// </summary>
        public NotificationTriggers Triggers { get; set; } = new();

        /// <summary>
        /// Daily summary settings
        /// </summary>
        public DailySummarySettings DailySummary { get; set; } = new();

        /// <summary>
        /// Batch notification settings
        /// </summary>
        public BatchNotificationSettings Batching { get; set; } = new();
    }

    public class NotificationTriggers
    {
        public bool OnServiceStart { get; set; } = true;
        public bool OnServiceStop { get; set; } = true;
        public bool OnError { get; set; } = true;
        public bool OnWarning { get; set; } = false;
        public bool OnSuccess { get; set; } = false;
        public bool OnPipelineComplete { get; set; } = true;
        public bool OnFolderWatchError { get; set; } = true;
        public bool OnConfigurationChange { get; set; } = true;
        public bool OnHealthCheckFailure { get; set; } = true;

        /// <summary>
        /// Error count threshold before notification
        /// </summary>
        public int ErrorThreshold { get; set; } = 5;

        /// <summary>
        /// Time window for error threshold (minutes)
        /// </summary>
        public int ErrorThresholdWindowMinutes { get; set; } = 60;
    }

    public class DailySummarySettings
    {
        public bool Enabled { get; set; } = true;
        public TimeSpan SendTime { get; set; } = new TimeSpan(8, 0, 0); // 8:00 AM
        public bool IncludeStatistics { get; set; } = true;
        public bool IncludeErrors { get; set; } = true;
        public bool IncludeWarnings { get; set; } = false;
        public bool OnlyIfActivity { get; set; } = true;
    }

    public class BatchNotificationSettings
    {
        public bool Enabled { get; set; } = false;
        public int BatchSize { get; set; } = 10;
        public int BatchWindowMinutes { get; set; } = 15;
        public bool GroupBySeverity { get; set; } = true;
    }

    public enum NotificationSeverity
    {
        Information,
        Success,
        Warning,
        Error,
        Critical
    }

    public enum NotificationLevel
    {
        None = 0,
        Critical = 1,
        Error = 2,
        Warning = 3,
        Information = 4,
        Debug = 5,
        All = 6
    }

    public static class NotificationLevelExtensions
    {
        public static int ToInt(this NotificationLevel level)
        {
            return (int)level;
        }

        public static NotificationLevel ToNotificationLevel(this int value)
        {
            if (Enum.IsDefined(typeof(NotificationLevel), value))
                return (NotificationLevel)value;
            return NotificationLevel.Error; // Default
        }
    }

    public enum NotificationEventType
    {
        ServiceStarted,
        ServiceStopped,
        ServiceError,
        ProcessingStarted,
        ProcessingCompleted,
        ProcessingFailed,
        ConfigurationChanged,
        HealthCheckPassed,
        HealthCheckFailed,
        FolderWatchStarted,
        FolderWatchStopped,
        FolderWatchError,
        DailySummary,
        Custom
    }
}


================================================================================
FILE: src\CamBridge.Core\ConfigurationPaths.cs
================================================================================

/**************************************************************************
*  ConfigurationPaths.cs                                                  *
*  PATH: src\CamBridge.Core\Infrastructure\ConfigurationPaths.cs         *
*  VERSION: 0.7.13 | SIZE: ~12KB | MODIFIED: 2025-06-14                  *
*                                                                         *
*  DESCRIPTION: Centralized configuration path management with V2 FIX     *
*  Copyright (c) 2025 Claude's Improbably Reliable Software Solutions     *
**************************************************************************/

using System;
using System.IO;
using System.Text.Json;

namespace CamBridge.Core.Infrastructure
{
    /// <summary>
    /// Centralized configuration path management for CamBridge
    /// Single source of truth for all configuration locations
    /// </summary>
    public static class ConfigurationPaths
    {
        /// <summary>
        /// Gets the base directory for all CamBridge data in ProgramData
        /// </summary>
        public static string ProgramDataBase => Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
            "CamBridge");

        /// <summary>
        /// Gets the path to the primary configuration file
        /// </summary>
        public static string GetPrimaryConfigPath()
        {
            return Path.Combine(ProgramDataBase, "appsettings.json");
        }

        /// <summary>
        /// Gets the directory for pipeline configurations
        /// </summary>
        public static string GetPipelineConfigDirectory()
        {
            return Path.Combine(ProgramDataBase, "Pipelines");
        }

        /// <summary>
        /// Gets the directory for mapping rules
        /// </summary>
        public static string GetMappingRulesDirectory()
        {
            return Path.Combine(ProgramDataBase, "Mappings");
        }

        /// <summary>
        /// Gets the directory for error files
        /// </summary>
        public static string GetErrorDirectory()
        {
            return Path.Combine(@"C:\CamBridge", "Errors");
        }

        /// <summary>
        /// Gets the directory for processing temporary files
        /// </summary>
        public static string GetProcessingDirectory()
        {
            return Path.Combine(ProgramDataBase, "Processing");
        }

        /// <summary>
        /// Gets the directory for completed files
        /// </summary>
        public static string GetCompletedDirectory()
        {
            return Path.Combine(ProgramDataBase, "Completed");
        }

        /// <summary>
        /// Gets the directory for logs
        /// </summary>
        public static string GetLogsDirectory()
        {
            return Path.Combine(ProgramDataBase, "Logs");
        }

        /// <summary>
        /// Gets the user preferences file path
        /// </summary>
        public static string GetUserPreferencesPath()
        {
            var appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            return Path.Combine(appData, "CamBridge", "preferences.json");
        }

        /// <summary>
        /// Ensures all required directories exist
        /// </summary>
        public static void EnsureDirectoriesExist()
        {
            Directory.CreateDirectory(ProgramDataBase);
            Directory.CreateDirectory(GetPipelineConfigDirectory());
            Directory.CreateDirectory(GetMappingRulesDirectory());
            Directory.CreateDirectory(GetErrorDirectory());
            Directory.CreateDirectory(GetProcessingDirectory());
            Directory.CreateDirectory(GetCompletedDirectory());
            Directory.CreateDirectory(GetLogsDirectory());
        }

        /// <summary>
        /// Checks if primary config exists
        /// </summary>
        public static bool PrimaryConfigExists()
        {
            return File.Exists(GetPrimaryConfigPath());
        }

        /// <summary>
        /// Initializes the primary configuration file if it doesn't exist
        /// FIXED v0.7.13: Now creates COMPLETE V2 format with VALID enum values!
        /// </summary>
        public static bool InitializePrimaryConfig()
        {
            try
            {
                var configPath = GetPrimaryConfigPath();
                if (!File.Exists(configPath))
                {
                    EnsureDirectoriesExist();

                    // Create COMPLETE default V2 configuration with CamBridge wrapper
                    var defaultConfig = new
                    {
                        // CRITICAL: Must have CamBridge wrapper for V2 format!
                        CamBridge = new
                        {
                            Version = "2.0",
                            Service = new
                            {
                                ServiceName = "CamBridgeService",
                                DisplayName = "CamBridge Image Processing Service",
                                Description = "Monitors folders for JPEG images and converts them to DICOM format",
                                ListenPort = 5111,  // CRITICAL: Must be ListenPort, not ApiPort!
                                EnableApi = true,
                                EnableHealthChecks = true,
                                MaxConcurrentPipelines = 4,
                                StartupDelaySeconds = 5,
                                ShutdownTimeoutSeconds = 30,
                                HealthCheckIntervalSeconds = 30
                            },
                            Core = new
                            {
                                ExifToolPath = "Tools\\exiftool.exe",
                                MaxGlobalConcurrency = 4,
                                DefaultCulture = "de-DE",
                                InstanceName = "CamBridge",
                                EnableDiagnostics = false,
                                TempFolder = @"C:\CamBridge\Temp",
                                CleanupTempOnStartup = true
                            },
                            Logging = new
                            {
                                LogLevel = new
                                {
                                    Default = "Information",
                                    Microsoft = "Warning",
                                    System = "Warning",
                                    CamBridge = "Information"
                                },
                                Console = new
                                {
                                    Enabled = true,
                                    IncludeScopes = false
                                },
                                File = new
                                {
                                    Enabled = true,
                                    Path = "logs/cambridge_{Date}.log",
                                    RetainedFileCountLimit = 30,
                                    FileSizeLimitBytes = 10485760,
                                    RollOnFileSizeLimit = true
                                }
                            },
                            DicomDefaults = new
                            {
                                InstitutionName = "CamBridge Medical Center",
                                InstitutionDepartment = "Radiology",
                                StationName = "CAMB001",
                                Manufacturer = "Claude's Improbably Reliable Software Solutions",
                                ManufacturerModelName = "CamBridge",
                                ImplementationClassUID = "1.2.276.0.7230010.3.0.3.6.4",
                                ImplementationVersionName = "CAMBRIDGE_001"
                            },
                            // CRITICAL: Must have at least one pipeline with VALID OutputOrganization!
                            Pipelines = new[]
                            {
                                new
                                {
                                    Id = Guid.NewGuid().ToString(),
                                    Name = "Default Pipeline",
                                    Description = "Default processing pipeline",
                                    Enabled = true,
                                    Priority = 0,
                                    WatchSettings = new
                                    {
                                        Path = @"C:\CamBridge\Watch",
                                        FilePattern = "*.jpg;*.jpeg",
                                        IncludeSubdirectories = false,
                                        OutputPath = @"C:\CamBridge\Output",
                                        MinimumFileAgeSeconds = 5
                                    },
                                    ProcessingOptions = new
                                    {
                                        SuccessAction = "Archive",
                                        FailureAction = "MoveToError",
                                        ArchiveFolder = @"C:\CamBridge\Archive",
                                        ErrorFolder = @"C:\CamBridge\Errors",
                                        BackupFolder = @"C:\CamBridge\Backup",
                                        CreateBackup = false,
                                        MaxConcurrentProcessing = 2,
                                        RetryOnFailure = true,
                                        MaxRetryAttempts = 3,
                                        // FIX: MUST use valid enum value as string!
                                        // Valid values: None, ByPatient, ByDate, ByPatientAndDate
                                        OutputOrganization = "ByPatientAndDate",  // NOT "PatientName"!
                                        ProcessExistingOnStartup = true,
                                        RetryDelaySeconds = 5,
                                        OutputFilePattern = "{PatientID}_{StudyDate}_{InstanceNumber}"
                                    },
                                    DicomOverrides = new
                                    {
                                        InstitutionName = (string?)null,
                                        InstitutionDepartment = (string?)null,
                                        StationName = (string?)null
                                    },
                                    MappingSetId = "default",
                                    CreatedAt = DateTime.UtcNow.ToString("O"),
                                    UpdatedAt = DateTime.UtcNow.ToString("O")
                                }
                            },
                            // Default mapping set matching the expected structure
                            MappingSets = new[]
                            {
                                new
                                {
                                    Id = "default",
                                    Name = "Default Mappings",
                                    Description = "Standard QRBridge to DICOM mappings",
                                    IsSystemDefault = true,
                                    Rules = new[]
                                    {
                                        new
                                        {
                                            name = "PatientID",
                                            description = "Patient ID from QRBridge",
                                            sourceType = "QRBridge",
                                            sourceField = "patientid",
                                            targetTag = "(0010,0020)",  // Use targetTag, not dicomTag
                                            dicomTag = "(0010,0020)",    // Keep both for compatibility
                                            transform = "None",
                                            required = true,
                                            defaultValue = (string?)null,
                                            valueRepresentation = "LO"
                                        },
                                        new
                                        {
                                            name = "PatientName",
                                            description = "Patient's Name from QRBridge",
                                            sourceType = "QRBridge",
                                            sourceField = "name",
                                            targetTag = "(0010,0010)",
                                            dicomTag = "(0010,0010)",
                                            transform = "None",
                                            required = true,
                                            defaultValue = (string?)null,
                                            valueRepresentation = "PN"
                                        },
                                        new
                                        {
                                            name = "StudyID",
                                            description = "Study ID from exam ID",
                                            sourceType = "QRBridge",
                                            sourceField = "examid",
                                            targetTag = "(0020,0010)",
                                            dicomTag = "(0020,0010)",
                                            transform = "None",
                                            required = false,
                                            defaultValue = (string?)null,
                                            valueRepresentation = "SH"
                                        },
                                        new
                                        {
                                            name = "PatientBirthDate",
                                            description = "Patient's Birth Date",
                                            sourceType = "QRBridge",
                                            sourceField = "birthdate",
                                            targetTag = "(0010,0030)",
                                            dicomTag = "(0010,0030)",
                                            transform = "DateFormat",
                                            required = false,
                                            defaultValue = (string?)null,
                                            valueRepresentation = "DA"
                                        },
                                        new
                                        {
                                            name = "PatientSex",
                                            description = "Patient's Sex",
                                            sourceType = "QRBridge",
                                            sourceField = "gender",
                                            targetTag = "(0010,0040)",
                                            dicomTag = "(0010,0040)",
                                            transform = "None",
                                            required = false,
                                            defaultValue = (string?)null,
                                            valueRepresentation = "CS"
                                        }
                                    },
                                    CreatedAt = DateTime.UtcNow.ToString("O"),
                                    UpdatedAt = DateTime.UtcNow.ToString("O")
                                }
                            },
                            Notifications = new
                            {
                                Enabled = false,
                                SmtpServer = "smtp.example.com",
                                SmtpPort = 587,
                                UseSsl = true,
                                RequiresAuthentication = true,
                                SenderEmail = "cambridge@example.com",
                                SenderName = "CamBridge Service",
                                RecipientEmails = new[] { "admin@example.com" },
                                NotificationLevel = 2,  // Error level
                                DailySummary = new
                                {
                                    Enabled = false,
                                    SendTime = "08:00:00",
                                    IncludeStatistics = true,
                                    IncludeErrors = true
                                }
                            },
                            // V2 format should NOT have these at root level
                            // They belong in Pipelines[].ProcessingOptions
                            DefaultOutputFolder = @"C:\CamBridge\Output",
                            ExifToolPath = "Tools\\exiftool.exe"
                        }
                    };

                    var json = JsonSerializer.Serialize(defaultConfig, new JsonSerializerOptions
                    {
                        WriteIndented = true,
                        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
                    });

                    File.WriteAllText(configPath, json);
                    System.Diagnostics.Debug.WriteLine($"Created COMPLETE V2 config at: {configPath}");
                    return true;
                }
                return false;
            }
            catch (Exception ex)
            {
                // Log error but don't throw - let the application continue
                System.Diagnostics.Debug.WriteLine($"Error initializing config: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Gets diagnostic information about configuration paths
        /// </summary>
        public static string GetDiagnosticInfo()
        {
            return $@"Configuration Paths:
- ProgramData Base: {ProgramDataBase}
- Primary Config: {GetPrimaryConfigPath()}
- Config Exists: {PrimaryConfigExists()}
- Pipelines Dir: {GetPipelineConfigDirectory()}
- Mappings Dir: {GetMappingRulesDirectory()}
- Error Dir: {GetErrorDirectory()}
- Logs Dir: {GetLogsDirectory()}";
        }

        /// <summary>
        /// Copies local config to primary location if needed
        /// </summary>
        public static bool CopyLocalConfigIfNeeded(string localPath)
        {
            try
            {
                if (!File.Exists(localPath)) return false;

                var primaryPath = GetPrimaryConfigPath();
                if (!File.Exists(primaryPath))
                {
                    EnsureDirectoriesExist();
                    File.Copy(localPath, primaryPath, true);
                    System.Diagnostics.Debug.WriteLine($"Copied local config to: {primaryPath}");
                    return true;
                }
                return false;
            }
            catch
            {
                return false;
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\CustomMappingConfiguration.cs
================================================================================

namespace CamBridge.Core
{
    /// <summary>
    /// Custom mapping configuration (stub for compatibility)
    /// </summary>
    public class CustomMappingConfiguration
    {
        // This is a stub class for compatibility
        // Can be removed or extended later
    }
}


================================================================================
FILE: src\CamBridge.Core\DeadLetterStatistics.cs
================================================================================

using System;
using System.Collections.Generic;

namespace CamBridge.Core
{
    /// <summary>
    /// Statistics about the dead letter queue
    /// </summary>
    public class DeadLetterStatistics
    {
        public int TotalItems { get; set; }
        public int ItemsLastHour { get; set; }
        public int ItemsLast24Hours { get; set; }
        public DateTime OldestItem { get; set; }
        public Dictionary<string, int> TopErrors { get; set; } = new();
    }
}


================================================================================
FILE: src\CamBridge.Core\MappingRule.cs
================================================================================

// src\CamBridge.Core\MappingRule.cs
// Version: 0.6.2
// Description: DICOM mapping rule configuration

using System;
using System.Text.Json.Serialization;

namespace CamBridge.Core
{
    /// <summary>
    /// Defines a mapping rule from source data to DICOM tag
    /// </summary>
    public class MappingRule
    {
        /// <summary>
        /// Unique name for this mapping rule
        /// </summary>
        [JsonPropertyName("name")]
        public string? Name { get; set; }

        /// <summary>
        /// Human-readable description of what this rule maps
        /// </summary>
        [JsonPropertyName("description")]
        public string? Description { get; set; }

        /// <summary>
        /// Source type: QRBridge, EXIF, Static, etc.
        /// </summary>
        [JsonPropertyName("sourceType")]
        public string SourceType { get; set; } = "QRBridge";

        /// <summary>
        /// Field name in source data
        /// </summary>
        [JsonPropertyName("sourceField")]
        public string SourceField { get; set; } = string.Empty;

        /// <summary>
        /// Target DICOM tag in format (XXXX,XXXX)
        /// </summary>
        [JsonPropertyName("targetTag")]
        public string DicomTag { get; set; } = string.Empty;

        /// <summary>
        /// Alternative property name for compatibility
        /// </summary>
        [JsonPropertyName("dicomTag")]
        public string? TargetTag
        {
            get => DicomTag;
            set => DicomTag = value ?? string.Empty;
        }

        /// <summary>
        /// Value transformation to apply
        /// </summary>
        [JsonPropertyName("transform")]
        public string Transform { get; set; } = "None";

        /// <summary>
        /// Whether this field is required
        /// </summary>
        [JsonPropertyName("required")]
        public bool Required { get; set; }

        /// <summary>
        /// Default value if source is empty
        /// </summary>
        [JsonPropertyName("defaultValue")]
        public string? DefaultValue { get; set; }

        /// <summary>
        /// DICOM Value Representation (e.g., PN, DA, TM, etc.)
        /// </summary>
        [JsonPropertyName("valueRepresentation")]
        public string? ValueRepresentation { get; set; }

        /// <summary>
        /// Transform parameters (JSON serialized)
        /// </summary>
        [JsonPropertyName("transformParameters")]
        public string? TransformParameters { get; set; }

        /// <summary>
        /// Transform as enum (computed property)
        /// </summary>
        [JsonIgnore]
        public ValueTransform TransformEnum
        {
            get
            {
                if (Enum.TryParse<ValueTransform>(Transform, out var result))
                    return result;
                return ValueTransform.None;
            }
            set => Transform = value.ToString();
        }

        /// <summary>
        /// Apply the configured transformation
        /// </summary>
        public string? ApplyTransform(string? input)
        {
            if (string.IsNullOrEmpty(input))
                return DefaultValue;

            // Fix legacy transform names
            var normalizedTransform = Transform switch
            {
                "GenderToDicom" => "MapGender",
                "TruncateTo16" => "None", // Not implemented in current version
                _ => Transform
            };

            if (!Enum.TryParse<ValueTransform>(normalizedTransform, out var transform))
                transform = ValueTransform.None;

            return transform switch
            {
                ValueTransform.None => input,
                ValueTransform.DateToDicom => ConvertDateToDicom(input),
                ValueTransform.TimeToDicom => ConvertTimeToDicom(input),
                ValueTransform.DateTimeToDicom => ConvertDateTimeToDicom(input),
                ValueTransform.MapGender => MapGenderValue(input),
                ValueTransform.RemovePrefix => RemovePrefixTransform(input),
                ValueTransform.ExtractDate => ExtractDateFromDateTime(input),
                ValueTransform.ExtractTime => ExtractTimeFromDateTime(input),
                ValueTransform.ToUpperCase => input.ToUpperInvariant(),
                ValueTransform.ToLowerCase => input.ToLowerInvariant(),
                ValueTransform.Trim => input.Trim(),
                _ => input
            };
        }

        #region Transform Methods

        private string ConvertDateToDicom(string input)
        {
            if (DateTime.TryParse(input, out var date))
            {
                return date.ToString("yyyyMMdd");
            }
            return input;
        }

        private string ConvertTimeToDicom(string input)
        {
            if (DateTime.TryParse(input, out var time))
            {
                return time.ToString("HHmmss");
            }
            return input;
        }

        private string ConvertDateTimeToDicom(string input)
        {
            if (DateTime.TryParse(input, out var dateTime))
            {
                return dateTime.ToString("yyyyMMddHHmmss");
            }
            return input;
        }

        private string MapGenderValue(string input)
        {
            return input?.ToUpperInvariant() switch
            {
                "M" or "MALE" => "M",
                "F" or "FEMALE" => "F",
                "O" or "OTHER" => "O",
                _ => DefaultValue ?? "O"
            };
        }

        private string RemovePrefixTransform(string input)
        {
            if (input.StartsWith("IMG_", StringComparison.OrdinalIgnoreCase))
            {
                return input.Substring(4);
            }
            return input;
        }

        private string ExtractDateFromDateTime(string input)
        {
            if (DateTime.TryParse(input, out var dateTime))
            {
                return dateTime.ToString("yyyyMMdd");
            }
            return input;
        }

        private string ExtractTimeFromDateTime(string input)
        {
            if (DateTime.TryParse(input, out var dateTime))
            {
                return dateTime.ToString("HHmmss");
            }
            return input;
        }

        #endregion
    }
}


================================================================================
FILE: src\CamBridge.Core\PipelineConfiguration.cs
================================================================================

// src\CamBridge.Core\PipelineConfiguration.cs
// Version: 0.8.0
// Description: Pipeline configuration model with PACS support
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;

namespace CamBridge.Core
{
    /// <summary>
    /// Represents a complete processing pipeline from input to output
    /// </summary>
    public class PipelineConfiguration : INotifyPropertyChanged
    {
        private Guid _id = Guid.NewGuid();
        private string _name = "New Pipeline";
        private string? _description;
        private bool _enabled = true;
        private PipelineWatchSettings _watchSettings = new();
        private ProcessingOptions _processingOptions = new();
        private DicomOverrides? _dicomOverrides;
        private Guid? _mappingSetId;
        private PacsConfiguration? _pacsConfiguration;

        /// <summary>
        /// Unique identifier for this pipeline
        /// </summary>
        public Guid Id
        {
            get => _id;
            set { _id = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Display name for this pipeline
        /// </summary>
        public string Name
        {
            get => _name;
            set { _name = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Optional description
        /// </summary>
        public string? Description
        {
            get => _description;
            set { _description = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Whether this pipeline is active
        /// </summary>
        public bool Enabled
        {
            get => _enabled;
            set { _enabled = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Watch folder configuration for this pipeline
        /// </summary>
        public PipelineWatchSettings WatchSettings
        {
            get => _watchSettings;
            set { _watchSettings = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Processing options specific to this pipeline
        /// </summary>
        public ProcessingOptions ProcessingOptions
        {
            get => _processingOptions;
            set { _processingOptions = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// DICOM overrides for this pipeline (optional)
        /// </summary>
        public DicomOverrides? DicomOverrides
        {
            get => _dicomOverrides;
            set { _dicomOverrides = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// ID of the mapping set to use
        /// </summary>
        public Guid? MappingSetId
        {
            get => _mappingSetId;
            set { _mappingSetId = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// PACS upload configuration for this pipeline (optional)
        /// </summary>
        public PacsConfiguration? PacsConfiguration
        {
            get => _pacsConfiguration;
            set { _pacsConfiguration = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Pipeline-specific metadata
        /// </summary>
        public Dictionary<string, string> Metadata { get; set; } = new();

        /// <summary>
        /// Creation timestamp
        /// </summary>
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Last modification timestamp
        /// </summary>
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Calculated property for UI display
        /// </summary>
        [JsonIgnore]
        public string ProcessedToday => "0 files"; // TODO: Implement actual counting

        [JsonIgnore]
        public bool IsValid => WatchSettings?.IsValid ?? false;

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Watch folder settings for a pipeline
    /// </summary>
    public class PipelineWatchSettings : INotifyPropertyChanged
    {
        private string _path = string.Empty;
        private string _filePattern = "*.jpg;*.jpeg";
        private bool _includeSubdirectories = false;
        private string? _outputPath;
        private int _minimumFileAgeSeconds = 2;

        /// <summary>
        /// Folder path to watch
        /// </summary>
        public string Path
        {
            get => _path;
            set { _path = value; OnPropertyChanged(); OnPropertyChanged(nameof(IsValid)); }
        }

        /// <summary>
        /// File pattern to match (e.g., "*.jpg;*.jpeg")
        /// </summary>
        public string FilePattern
        {
            get => _filePattern;
            set { _filePattern = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Include subdirectories in watch
        /// </summary>
        public bool IncludeSubdirectories
        {
            get => _includeSubdirectories;
            set { _includeSubdirectories = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Custom output path (overrides processing options)
        /// </summary>
        public string? OutputPath
        {
            get => _outputPath;
            set { _outputPath = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Minimum file age before processing (to ensure write completion)
        /// </summary>
        public int MinimumFileAgeSeconds
        {
            get => _minimumFileAgeSeconds;
            set { _minimumFileAgeSeconds = value; OnPropertyChanged(); }
        }

        [JsonIgnore]
        public bool IsValid => !string.IsNullOrWhiteSpace(Path) &&
                              System.IO.Directory.Exists(Path);

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// DICOM settings that can be overridden per pipeline
    /// </summary>
    public class DicomOverrides : INotifyPropertyChanged
    {
        private string? _institutionName;
        private string? _institutionDepartment;
        private string? _stationName;

        /// <summary>
        /// Override institution name for this pipeline
        /// </summary>
        public string? InstitutionName
        {
            get => _institutionName;
            set { _institutionName = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Override institution department for this pipeline
        /// </summary>
        public string? InstitutionDepartment
        {
            get => _institutionDepartment;
            set { _institutionDepartment = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Override station name for this pipeline
        /// </summary>
        public string? StationName
        {
            get => _stationName;
            set { _stationName = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Additional DICOM tags to set/override
        /// </summary>
        public Dictionary<string, string> AdditionalTags { get; set; } = new();

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Represents a reusable mapping configuration set
    /// </summary>
    public class MappingSet : INotifyPropertyChanged
    {
        private Guid _id = Guid.NewGuid();
        private string _name = "New Mapping Set";
        private string? _description;
        private bool _isSystemDefault = false;

        /// <summary>
        /// Unique identifier
        /// </summary>
        public Guid Id
        {
            get => _id;
            set { _id = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Display name
        /// </summary>
        public string Name
        {
            get => _name;
            set { _name = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Optional description
        /// </summary>
        public string? Description
        {
            get => _description;
            set { _description = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// The actual mapping rules
        /// </summary>
        public List<MappingRule> Rules { get; set; } = new();

        /// <summary>
        /// Whether this is a system default (read-only)
        /// </summary>
        public bool IsSystemDefault
        {
            get => _isSystemDefault;
            set { _isSystemDefault = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Creation timestamp
        /// </summary>
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Last modification timestamp
        /// </summary>
        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Tags for categorization
        /// </summary>
        public List<string> Tags { get; set; } = new();

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// PACS (Picture Archiving and Communication System) configuration for automatic upload
    /// </summary>
    public class PacsConfiguration : INotifyPropertyChanged
    {
        private bool _enabled = false;
        private string _host = string.Empty;
        private int _port = 104;
        private string _calledAeTitle = string.Empty;
        private string _callingAeTitle = "CAMBRIDGE";
        private int _timeoutSeconds = 30;
        private int _maxConcurrentUploads = 1;
        private bool _retryOnFailure = true;
        private int _maxRetryAttempts = 3;
        private int _retryDelaySeconds = 5;

        /// <summary>
        /// Enable automatic PACS upload after DICOM creation
        /// </summary>
        public bool Enabled
        {
            get => _enabled;
            set { _enabled = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// PACS server hostname or IP address
        /// </summary>
        public string Host
        {
            get => _host;
            set { _host = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// PACS server port (default: 104)
        /// </summary>
        public int Port
        {
            get => _port;
            set { _port = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Called AE Title (PACS server's AE Title)
        /// </summary>
        public string CalledAeTitle
        {
            get => _calledAeTitle;
            set { _calledAeTitle = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Calling AE Title (our AE Title)
        /// </summary>
        public string CallingAeTitle
        {
            get => _callingAeTitle;
            set { _callingAeTitle = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Connection timeout in seconds
        /// </summary>
        public int TimeoutSeconds
        {
            get => _timeoutSeconds;
            set { _timeoutSeconds = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum concurrent uploads per pipeline
        /// </summary>
        public int MaxConcurrentUploads
        {
            get => _maxConcurrentUploads;
            set { _maxConcurrentUploads = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Enable retry on upload failure
        /// </summary>
        public bool RetryOnFailure
        {
            get => _retryOnFailure;
            set { _retryOnFailure = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum retry attempts
        /// </summary>
        public int MaxRetryAttempts
        {
            get => _maxRetryAttempts;
            set { _maxRetryAttempts = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Delay between retry attempts in seconds
        /// </summary>
        public int RetryDelaySeconds
        {
            get => _retryDelaySeconds;
            set { _retryDelaySeconds = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Validate configuration
        /// </summary>
        public bool IsValid() =>
            !string.IsNullOrWhiteSpace(Host) &&
            Port > 0 &&
            Port < 65536 &&
            !string.IsNullOrWhiteSpace(CalledAeTitle) &&
            !string.IsNullOrWhiteSpace(CallingAeTitle) &&
            CalledAeTitle.Length <= 16 &&
            CallingAeTitle.Length <= 16;

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\ProcessingOptions.cs
================================================================================

// src\CamBridge.Core\ProcessingOptions.cs
// Version: 0.8.10
// Description: Processing options with INotifyPropertyChanged support - DeadLetterFolder removed!

using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;

namespace CamBridge.Core
{
    /// <summary>
    /// Options for processing JPEG files
    /// </summary>
    public class ProcessingOptions : INotifyPropertyChanged
    {
        private PostProcessingAction _successAction = PostProcessingAction.Archive;
        private PostProcessingAction _failureAction = PostProcessingAction.MoveToError;
        private string _archiveFolder = @"C:\CamBridge\Archive";
        private string _errorFolder = @"C:\CamBridge\Errors";
        private string _backupFolder = @"C:\CamBridge\Backup";
        private bool _createBackup = true;
        private int _maxConcurrentProcessing = 2;
        private bool _retryOnFailure = true;
        private int _maxRetryAttempts = 3;
        private OutputOrganization _outputOrganization = OutputOrganization.ByPatientAndDate;
        private bool _processExistingOnStartup = true;
        private TimeSpan? _maxFileAge;
        private long? _minimumFileSizeBytes;
        private long? _maximumFileSizeBytes;
        private string? _outputFilePattern;
        private int _retryDelaySeconds = 5;

        /// <summary>
        /// Action to take on successful processing
        /// </summary>
        public PostProcessingAction SuccessAction
        {
            get => _successAction;
            set { _successAction = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Action to take on failed processing
        /// </summary>
        public PostProcessingAction FailureAction
        {
            get => _failureAction;
            set { _failureAction = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Archive folder for successfully processed files
        /// </summary>
        public string ArchiveFolder
        {
            get => _archiveFolder;
            set { _archiveFolder = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Error folder for failed files
        /// </summary>
        public string ErrorFolder
        {
            get => _errorFolder;
            set { _errorFolder = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Backup folder for original files
        /// </summary>
        public string BackupFolder
        {
            get => _backupFolder;
            set { _backupFolder = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Whether to create backup before processing
        /// </summary>
        public bool CreateBackup
        {
            get => _createBackup;
            set { _createBackup = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum concurrent file processing
        /// </summary>
        public int MaxConcurrentProcessing
        {
            get => _maxConcurrentProcessing;
            set { _maxConcurrentProcessing = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Whether to retry on failure
        /// </summary>
        public bool RetryOnFailure
        {
            get => _retryOnFailure;
            set { _retryOnFailure = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum retry attempts
        /// </summary>
        public int MaxRetryAttempts
        {
            get => _maxRetryAttempts;
            set { _maxRetryAttempts = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Output folder organization strategy
        /// </summary>
        public OutputOrganization OutputOrganization
        {
            get => _outputOrganization;
            set { _outputOrganization = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Whether to process existing files on startup
        /// </summary>
        public bool ProcessExistingOnStartup
        {
            get => _processExistingOnStartup;
            set { _processExistingOnStartup = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum age of files to process
        /// </summary>
        public TimeSpan? MaxFileAge
        {
            get => _maxFileAge;
            set { _maxFileAge = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Minimum file size in bytes
        /// </summary>
        public long? MinimumFileSizeBytes
        {
            get => _minimumFileSizeBytes;
            set { _minimumFileSizeBytes = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Maximum file size in bytes
        /// </summary>
        public long? MaximumFileSizeBytes
        {
            get => _maximumFileSizeBytes;
            set { _maximumFileSizeBytes = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Pattern for output file naming
        /// </summary>
        public string? OutputFilePattern
        {
            get => _outputFilePattern;
            set { _outputFilePattern = value; OnPropertyChanged(); }
        }

        /// <summary>
        /// Delay between retry attempts in seconds
        /// </summary>
        public int RetryDelaySeconds
        {
            get => _retryDelaySeconds;
            set { _retryDelaySeconds = value; OnPropertyChanged(); }
        }

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    /// <summary>
    /// Actions to take after processing
    /// </summary>
    public enum PostProcessingAction
    {
        /// <summary>
        /// Leave the file in place
        /// </summary>
        Leave,

        /// <summary>
        /// Move to archive folder
        /// </summary>
        Archive,

        /// <summary>
        /// Delete the file
        /// </summary>
        Delete,

        /// <summary>
        /// Move to error folder
        /// </summary>
        MoveToError
    }

    /// <summary>
    /// File action types
    /// </summary>
    public enum FileActionType
    {
        Delete,
        Move,
        Keep
    }

    /// <summary>
    /// Output organization types
    /// </summary>
    public enum OutputOrganizationType
    {
        Flat,           // All files in one folder
        YearMonth,      // Year/Month subfolders
        PatientStudy,   // Patient/Study subfolders
        DatePatient     // Date/Patient subfolders
    }


    /// <summary>
    /// Output folder organization strategies
    /// </summary>
    public enum OutputOrganization
    {
        /// <summary>
        /// No organization
        /// </summary>
        None,

        /// <summary>
        /// Organize by patient name
        /// </summary>
        ByPatient,

        /// <summary>
        /// Organize by date
        /// </summary>
        ByDate,

        /// <summary>
        /// Organize by patient and date
        /// </summary>
        ByPatientAndDate


    }
}


================================================================================
FILE: src\CamBridge.Core\ProcessingSummary.cs
================================================================================

using System;
using System.Collections.Generic;

namespace CamBridge.Core
{
    /// <summary>
    /// Summary of daily processing activities
    /// </summary>
    public class ProcessingSummary
    {
        public DateTime Date { get; set; }
        public int TotalProcessed { get; set; }
        public int Successful { get; set; }
        public int Failed { get; set; }
        public double ProcessingTimeSeconds { get; set; }
        public Dictionary<string, int> TopErrors { get; set; } = new();
        public int DeadLetterCount { get; set; }
        public TimeSpan Uptime { get; set; }

        // Berechnete Properties
        public double SuccessRate => TotalProcessed > 0
            ? (double)Successful / TotalProcessed * 100
            : 0;

        public double AverageProcessingTime => TotalProcessed > 0
            ? ProcessingTimeSeconds / TotalProcessed
            : 0;
    }
}


================================================================================
FILE: src\CamBridge.Core\SystemSettings.cs
================================================================================

// src\CamBridge.Core\SystemSettings.cs
// Version: 0.7.3
// Description: System-wide settings (Service + Config Tool)
// Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;

namespace CamBridge.Core
{
    /// <summary>
    /// System-wide settings shared by Service and Config Tool
    /// Stored in: %ProgramData%\CamBridge\appsettings.json
    /// </summary>
    public class SystemSettings
    {
        public ServiceConfiguration Service { get; set; } = new();
        public CoreConfiguration Core { get; set; } = new();
        public LoggingConfiguration Logging { get; set; } = new();
        public DicomDefaultSettings DicomDefaults { get; set; } = new();
        public NotificationSettings Notifications { get; set; } = new();
    }

    /// <summary>
    /// Core system configuration
    /// </summary>
    public class CoreConfiguration
    {
        public string ExifToolPath { get; set; } = "Tools\\exiftool.exe";
        public int MaxGlobalConcurrency { get; set; } = 4;
        public string DefaultCulture { get; set; } = "de-DE";
        public string InstanceName { get; set; } = "CamBridge";
        public bool EnableDiagnostics { get; set; } = false;
        public string TempFolder { get; set; } = @"C:\CamBridge\Temp";
        public bool CleanupTempOnStartup { get; set; } = true;
    }

    /// <summary>
    /// Service-specific configuration (new structure)
    /// </summary>
    public class ServiceConfiguration
    {
        public string ServiceUrl { get; set; } = "http://localhost:5111";
        public bool EnableHealthChecks { get; set; } = true;
        public int HealthCheckIntervalSeconds { get; set; } = 30;
        public string ServiceDisplayName { get; set; } = "CamBridge Service";
        public string ServiceDescription { get; set; } = "JPEG to DICOM medical imaging converter";
        public int StartupDelaySeconds { get; set; } = 5;
        public int ShutdownTimeoutSeconds { get; set; } = 30;
        public bool EnableApi { get; set; } = true;
        public bool EnableSwagger { get; set; } = true;
    }

    /// <summary>
    /// Logging configuration (new structure)
    /// </summary>
    public class LoggingConfiguration
    {
        public string LogLevel { get; set; } = "Information";
        public string LogPath { get; set; } = @"C:\CamBridge\Logs";
        public int MaxLogFileSizeMB { get; set; } = 50;
        public int MaxLogFileCount { get; set; } = 10;
        public bool EnableConsoleLogging { get; set; } = true;
        public bool EnableFileLogging { get; set; } = true;
        public bool EnableEventLog { get; set; } = false;
        public string LogFileNamePattern { get; set; } = "cambridge_{Date}.log";
        public Dictionary<string, string> LogLevelOverrides { get; set; } = new()
        {
            { "Microsoft", "Warning" },
            { "System", "Warning" },
            { "Microsoft.Hosting.Lifetime", "Information" }
        };
    }

    /// <summary>
    /// DICOM default values for all conversions
    /// </summary>
    public class DicomDefaultSettings
    {
        public string ImplementationClassUID { get; set; } = "1.2.276.0.7230010.3.0.3.6.4";
        public string ImplementationVersionName { get; set; } = "CAMBRIDGE_001";
        public string DefaultModality { get; set; } = "OT";
        public string DefaultManufacturer { get; set; } = "Ricoh";
        public string DefaultManufacturerModelName { get; set; } = "G900 II";
        public string SourceApplicationEntityTitle { get; set; } = "CAMBRIDGE";
        public string DefaultInstitutionName { get; set; } = string.Empty;
        public string DefaultInstitutionAddress { get; set; } = string.Empty;

        // Character set configuration
        public string SpecificCharacterSet { get; set; } = "ISO_IR 100"; // Latin-1
        public bool UseUtf8 { get; set; } = false; // Future: UTF-8 support
    }
}


================================================================================
FILE: src\CamBridge.Core\UserPreferences.cs
================================================================================

// src\CamBridge.Core\UserPreferences.cs
// Version: 0.7.3
// Description: Per-user UI preferences
// Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;

namespace CamBridge.Core
{
    /// <summary>
    /// User-specific UI preferences
    /// Stored in: %AppData%\CamBridge\preferences.json
    /// </summary>
    public class UserPreferences
    {
        // UI Theme and Appearance
        public string Theme { get; set; } = "Dark";
        public string Language { get; set; } = "de-DE";
        public string AccentColor { get; set; } = "Blue";
        public double UiScale { get; set; } = 1.0;

        // Window Management
        public string WindowState { get; set; } = "Maximized";
        public WindowPosition? LastWindowPosition { get; set; }
        public bool AlwaysOnTop { get; set; } = false;

        // Navigation and Workflow
        public string DefaultView { get; set; } = "Dashboard";
        public bool ShowAdvancedOptions { get; set; } = false;
        public bool ShowStatusBar { get; set; } = true;
        public bool ShowNavigationPane { get; set; } = true;

        // Recent Items
        public List<Guid> RecentPipelines { get; set; } = new();
        public List<string> RecentFolders { get; set; } = new();
        public int MaxRecentItems { get; set; } = 10;

        // Favorites and Shortcuts
        public Dictionary<string, object> FavoriteSettings { get; set; } = new();
        public List<string> PinnedViews { get; set; } = new() { "Dashboard", "ServiceControl" };

        // Editor Preferences
        public bool EnableSyntaxHighlighting { get; set; } = true;
        public bool EnableAutoComplete { get; set; } = true;
        public int EditorFontSize { get; set; } = 12;
        public string EditorFontFamily { get; set; } = "Consolas";

        // Notification Preferences
        public bool EnableDesktopNotifications { get; set; } = true;
        public bool PlaySoundOnError { get; set; } = true;
        public bool PlaySoundOnSuccess { get; set; } = false;

        // Last session state
        public DateTime LastSessionTime { get; set; } = DateTime.UtcNow;
        public string LastSelectedPipelineId { get; set; } = string.Empty;
        public Dictionary<string, bool> CollapsedSections { get; set; } = new();
    }

    /// <summary>
    /// Window position and size
    /// </summary>
    public class WindowPosition
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Width { get; set; } = 1200;
        public int Height { get; set; } = 800;

        /// <summary>
        /// Monitor identifier for multi-monitor setups
        /// </summary>
        public string MonitorId { get; set; } = string.Empty;

        /// <summary>
        /// Validates if position is reasonable (not off-screen)
        /// </summary>
        public bool IsValid()
        {
            return X >= -Width / 2 &&
                   Y >= -Height / 2 &&
                   Width >= 800 &&
                   Height >= 600;
        }
    }

    /// <summary>
    /// Available UI themes
    /// </summary>
    public static class UiThemes
    {
        public const string Light = "Light";
        public const string Dark = "Dark";
        public const string HighContrast = "HighContrast";
        public const string System = "System"; // Follow Windows theme
    }

    /// <summary>
    /// Available UI languages
    /// </summary>
    public static class UiLanguages
    {
        public const string German = "de-DE";
        public const string English = "en-US";
        public const string French = "fr-FR";
        public const string Spanish = "es-ES";
    }
}


================================================================================
FILE: src\CamBridge.Core\ValueTransform.cs
================================================================================

namespace CamBridge.Core
{
    /// <summary>
    /// Enum for value transform types used in mapping rules
    /// </summary>
    public enum ValueTransform
    {
        /// <summary>
        /// No transformation applied
        /// </summary>
        None,

        /// <summary>
        /// Convert date to DICOM format (YYYYMMDD)
        /// </summary>
        DateToDicom,

        /// <summary>
        /// Convert time to DICOM format (HHMMSS)
        /// </summary>
        TimeToDicom,

        /// <summary>
        /// Convert datetime to DICOM format
        /// </summary>
        DateTimeToDicom,

        /// <summary>
        /// Map gender codes (M/F/O to Male/Female/Other)
        /// </summary>
        MapGender,

        /// <summary>
        /// Remove prefix from value
        /// </summary>
        RemovePrefix,

        /// <summary>
        /// Extract date part from datetime
        /// </summary>
        ExtractDate,

        /// <summary>
        /// Extract time part from datetime
        /// </summary>
        ExtractTime,

        /// <summary>
        /// Convert to uppercase
        /// </summary>
        ToUpperCase,

        /// <summary>
        /// Convert to lowercase
        /// </summary>
        ToLowerCase,

        /// <summary>
        /// Trim whitespace
        /// </summary>
        Trim
    }
}


================================================================================
FILE: src\CamBridge.Core\Entities\ImageMetadata.cs
================================================================================

using System;
using System.Collections.Generic;

namespace CamBridge.Core.Entities
{
    /// <summary>
    /// Complete metadata extracted from a medical image file
    /// </summary>
    public class ImageMetadata
    {
        public string SourceFilePath { get; }
        public DateTime CaptureDateTime { get; }
        public PatientInfo Patient { get; }
        public StudyInfo Study { get; }
        public ImageTechnicalData TechnicalData { get; }
        public string? UserComment { get; }
        public string? BarcodeData { get; }
        public int InstanceNumber { get; }
        public string InstanceUid { get; }
        public Dictionary<string, string> ExifData { get; }

        public ImageMetadata(
            string sourceFilePath,
            DateTime captureDateTime,
            PatientInfo patient,
            StudyInfo study,
            ImageTechnicalData technicalData,
            string? userComment = null,
            string? barcodeData = null,
            int instanceNumber = 1,
            string? instanceUid = null,
            Dictionary<string, string>? exifData = null)
        {
            SourceFilePath = sourceFilePath ?? throw new ArgumentNullException(nameof(sourceFilePath));
            CaptureDateTime = captureDateTime;
            Patient = patient ?? throw new ArgumentNullException(nameof(patient));
            Study = study ?? throw new ArgumentNullException(nameof(study));
            TechnicalData = technicalData ?? throw new ArgumentNullException(nameof(technicalData));
            UserComment = userComment;
            BarcodeData = barcodeData;
            InstanceNumber = instanceNumber;
            InstanceUid = instanceUid ?? GenerateUid();
            ExifData = exifData ?? new Dictionary<string, string>();
        }

        private static string GenerateUid()
        {
            // Generate a DICOM compliant UID
            var timestamp = DateTime.UtcNow.ToString("yyyyMMddHHmmss");
            var random = new Random().Next(1000, 9999);
            return $"1.2.276.0.7230010.3.1.4.{timestamp}.{random}";
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\Entities\ImageTechnicalData.cs
================================================================================

using System;
using System.Collections.Generic;

namespace CamBridge.Core.Entities
{
    /// <summary>
    /// Technical metadata extracted from image EXIF data
    /// </summary>
    public class ImageTechnicalData
    {
        public string? Manufacturer { get; init; }
        public string? Model { get; init; }
        public string? Software { get; init; }
        public int? ImageWidth { get; init; }
        public int? ImageHeight { get; init; }
        public string? ColorSpace { get; init; }
        public int? BitsPerSample { get; init; }
        public string? Compression { get; init; }
        public int? Orientation { get; init; }

        /// <summary>
        /// Creates ImageTechnicalData from raw EXIF dictionary
        /// </summary>
        public static ImageTechnicalData FromExifDictionary(Dictionary<string, string> exifData)
        {
            return new ImageTechnicalData
            {
                Manufacturer = GetValue(exifData, "Make", "Manufacturer"),
                Model = GetValue(exifData, "Model", "CameraModel"),
                Software = GetValue(exifData, "Software"),
                ImageWidth = GetIntValue(exifData, "ImageWidth", "PixelXDimension"),
                ImageHeight = GetIntValue(exifData, "ImageHeight", "PixelYDimension"),
                ColorSpace = GetValue(exifData, "ColorSpace"),
                BitsPerSample = GetIntValue(exifData, "BitsPerSample"),
                Compression = GetValue(exifData, "Compression"),
                Orientation = GetIntValue(exifData, "Orientation")
            };
        }

        private static string? GetValue(Dictionary<string, string> data, params string[] keys)
        {
            foreach (var key in keys)
            {
                if (data.TryGetValue(key, out var value) && !string.IsNullOrWhiteSpace(value))
                    return value;
            }
            return null;
        }

        private static int? GetIntValue(Dictionary<string, string> data, params string[] keys)
        {
            var value = GetValue(data, keys);
            if (value != null && int.TryParse(value, out var result))
                return result;
            return null;
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\Entities\PatientInfo.cs
================================================================================

using System;
using System.Collections.Generic;
using CamBridge.Core.ValueObjects;

namespace CamBridge.Core.Entities
{
    /// <summary>
    /// Patient information extracted from image metadata
    /// </summary>
    public class PatientInfo
    {
        public PatientId Id { get; }
        public string Name { get; }
        public string PatientName => Name; // Alias for compatibility
        public string PatientId => Id.Value; // Alias for compatibility
        public string? StudyId { get; set; }
        public DateTime? BirthDate { get; }
        public Gender Gender { get; }

        public PatientInfo(PatientId id, string name, DateTime? birthDate, Gender gender)
        {
            Id = id ?? throw new ArgumentNullException(nameof(id));
            Name = name ?? throw new ArgumentNullException(nameof(name));
            BirthDate = birthDate;
            Gender = gender;
        }

        /// <summary>
        /// Creates PatientInfo from EXIF/QRBridge data
        /// </summary>
        public static PatientInfo FromExifData(Dictionary<string, string> exifData)
        {
            // Extract patient ID - try multiple possible field names
            var patientIdValue = exifData.GetValueOrDefault("patientid") ??
                                exifData.GetValueOrDefault("id") ??
                                exifData.GetValueOrDefault("examid") ??
                                $"AUTO_{DateTime.UtcNow:yyyyMMddHHmmss}";

            var patientId = new PatientId(patientIdValue);

            // Extract name
            var name = exifData.GetValueOrDefault("name") ??
                      exifData.GetValueOrDefault("patientname") ??
                      "Unknown";

            // Extract birth date
            DateTime? birthDate = null;
            var birthDateStr = exifData.GetValueOrDefault("birthdate") ??
                              exifData.GetValueOrDefault("dateofbirth");

            if (!string.IsNullOrWhiteSpace(birthDateStr))
            {
                // Try various date formats
                var formats = new[] {
                    "yyyy-MM-dd",
                    "yyyyMMdd",
                    "dd.MM.yyyy",
                    "dd/MM/yyyy",
                    "MM/dd/yyyy"
                };

                foreach (var format in formats)
                {
                    if (DateTime.TryParseExact(birthDateStr, format, null,
                        System.Globalization.DateTimeStyles.None, out var date))
                    {
                        birthDate = date;
                        break;
                    }
                }
            }

            // Extract gender
            var genderStr = exifData.GetValueOrDefault("gender") ??
                           exifData.GetValueOrDefault("sex") ??
                           "O";

            var gender = ParseGender(genderStr);

            return new PatientInfo(patientId, name, birthDate, gender);
        }

        private static Gender ParseGender(string? genderStr)
        {
            if (string.IsNullOrWhiteSpace(genderStr))
                return Gender.Other;

            return genderStr.ToUpperInvariant() switch
            {
                "M" or "MALE" or "MANN" or "MÃ„NNLICH" => Gender.Male,
                "F" or "FEMALE" or "FRAU" or "WEIBLICH" => Gender.Female,
                _ => Gender.Other
            };
        }
    }

    public enum Gender
    {
        Male,
        Female,
        Other
    }
}


================================================================================
FILE: src\CamBridge.Core\Entities\ProcessingResult.cs
================================================================================

using System;

namespace CamBridge.Core.Entities
{
    /// <summary>
    /// Result of processing a single image file
    /// </summary>
    public class ProcessingResult
    {
        public string FilePath { get; private set; }
        public string FileName => System.IO.Path.GetFileName(FilePath);
        public bool Success { get; private set; }
        public string? OutputFile { get; private set; }
        public string? ErrorMessage { get; private set; }
        public DateTime ProcessedAt { get; private set; }
        public TimeSpan? ProcessingTime { get; private set; }
        public PatientInfo? PatientInfo { get; set; }

        private ProcessingResult(string filePath, bool success, string? outputFile, string? errorMessage, TimeSpan? processingTime)
        {
            FilePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
            Success = success;
            OutputFile = outputFile;
            ErrorMessage = errorMessage;
            ProcessedAt = DateTime.UtcNow;
            ProcessingTime = processingTime;
        }

        public static ProcessingResult CreateSuccess(string filePath, string outputFile, TimeSpan processingTime)
        {
            return new ProcessingResult(filePath, true, outputFile, null, processingTime);
        }

        public static ProcessingResult CreateFailure(string filePath, string errorMessage, TimeSpan? processingTime = null)
        {
            return new ProcessingResult(filePath, false, null, errorMessage, processingTime);
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\Entities\QRCodeRequest.cs
================================================================================

// src/CamBridge.Core/Entities/QRCodeRequest.cs
// Version: 0.5.33
// Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core.ValueObjects;

namespace CamBridge.Core.Entities;

/// <summary>
/// Request object for QR code generation containing patient and study information
/// </summary>
public record QRCodeRequest(
    PatientInfo Patient,
    StudyInfo Study,
    string? Comment = null,
    int TimeoutSeconds = 10
)
{
    /// <summary>
    /// Formats the QR code data in the expected format for Ricoh cameras
    /// Format: ExamId|Name|BirthDate|Gender|Comment
    /// </summary>
    public string FormatForQRCode()
    {
        // Format exactly as legacy QRBridge expects
        var parts = new[]
        {
            Study.ExamId ?? string.Empty,
            Patient.Name ?? string.Empty,
            Patient.BirthDate?.ToString("yyyy-MM-dd") ?? string.Empty,
            Patient.Gender.ToString()[0].ToString(), // M/F/O
            Comment ?? string.Empty
        };

        return string.Join("|", parts);
    }

    /// <summary>
    /// Creates an empty request for initialization
    /// </summary>
    public static QRCodeRequest Empty => new(
        new PatientInfo(
            new PatientId("QR-EMPTY"),  // id - POSITIONAL, not named!
            "Unknown",                   // name
            null,                        // birthDate
            Gender.Other                 // gender
        ),
        new StudyInfo(
            StudyId.Generate(),          // studyId
            "UNKNOWN",                   // examId
            null,                        // description
            "OT"                         // modality
        ),
        null,
        10                              // default timeout seconds
    );
}


================================================================================
FILE: src\CamBridge.Core\Entities\StudyInfo.cs
================================================================================

using System;
using CamBridge.Core.ValueObjects;

namespace CamBridge.Core.Entities
{
    /// <summary>
    /// Information about a medical imaging study
    /// </summary>
    public class StudyInfo
    {
        public StudyId StudyId { get; }
        public string? ExamId { get; }
        public string? Description { get; }
        public string? Modality { get; }
        public DateTime StudyDate { get; }
        public string? AccessionNumber { get; }
        public string? ReferringPhysician { get; }
        public string? Comment { get; }

        public StudyInfo(
            StudyId studyId,
            string? examId = null,
            string? description = null,
            string? modality = null,
            DateTime? studyDate = null,
            string? accessionNumber = null,
            string? referringPhysician = null,
            string? comment = null)
        {
            StudyId = studyId ?? throw new ArgumentNullException(nameof(studyId));
            ExamId = examId;
            Description = description;
            Modality = modality ?? "OT"; // Other modality as default
            StudyDate = studyDate ?? DateTime.Now;
            AccessionNumber = accessionNumber;
            ReferringPhysician = referringPhysician;
            Comment = comment;
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\Enums\LogVerbosity.cs
================================================================================

// src/CamBridge.Core/Enums/LogVerbosity.cs
// Version: 0.8.6
// Created: Session 96 - Making Logs Great Again!
// Purpose: Define global log verbosity levels for the service

namespace CamBridge.Core.Enums
{
    /// <summary>
    /// Defines the verbosity levels for service logging.
    /// Controls how much detail is written to log files.
    /// </summary>
    public enum LogVerbosity
    {
        /// <summary>
        /// Minimal logging - Only start/end events (~150 KB/day)
        /// Logs: File detected, processing complete/failed
        /// </summary>
        Minimal = 0,

        /// <summary>
        /// Normal logging - Key events and compact info (~750 KB/day)
        /// Logs: Minimal + EXIF data summary, mapping rules applied
        /// </summary>
        Normal = 1,

        /// <summary>
        /// Detailed logging - All stages with timing (~1.75 MB/day)
        /// Logs: Normal + all processing stages, timing information
        /// DEFAULT setting for troubleshooting
        /// </summary>
        Detailed = 2,

        /// <summary>
        /// Debug logging - Everything including raw data (~3.5 MB/day)
        /// Logs: Detailed + raw EXIF JSON, DICOM tags, full error stacks
        /// Use only for deep debugging
        /// </summary>
        Debug = 3
    }
}


================================================================================
FILE: src\CamBridge.Core\Enums\ProcessingStage.cs
================================================================================

// src/CamBridge.Core/Enums/ProcessingStage.cs
// Version: 0.8.9
// Created: Session 97 - Fixing hierarchical logging
// Updated: Session 105 - Added pipeline lifecycle stages
// Purpose: Define processing stages for correlation tracking
namespace CamBridge.Core.Enums
{
    /// <summary>
    /// Processing stages for hierarchical logging and correlation tracking
    /// </summary>
    public enum ProcessingStage
    {
        // Service-level stages (new in v0.8.7)
        /// <summary>
        /// Service is starting up
        /// </summary>
        ServiceStartup,

        /// <summary>
        /// Loading service configuration
        /// </summary>
        ConfigurationLoading,

        /// <summary>
        /// Initializing processing pipelines
        /// </summary>
        PipelineInitialization,

        /// <summary>
        /// Service is shutting down
        /// </summary>
        ServiceShutdown,

        // NEW in Session 105:
        /// <summary>
        /// Pipeline is being stopped
        /// </summary>
        PipelineShutdown,

        /// <summary>
        /// Pipeline recovery attempt after error
        /// </summary>
        PipelineRecovery,

        /// <summary>
        /// File watcher encountered an error
        /// </summary>
        WatcherError,

        /// <summary>
        /// Health check operation
        /// </summary>
        HealthCheck,

        // File processing stages
        /// <summary>
        /// File received from FTP Server (future feature)
        /// </summary>
        FtpReceived,

        /// <summary>
        /// File detected in watch folder
        /// </summary>
        FileDetected,

        /// <summary>
        /// Extracting metadata from JPEG using ExifTool
        /// </summary>
        ExifExtraction,

        /// <summary>
        /// Applying mapping rules to transform data
        /// </summary>
        TagMapping,

        /// <summary>
        /// Creating DICOM file from JPEG + metadata
        /// </summary>
        DicomConversion,

        /// <summary>
        /// Archive/Delete operations after conversion
        /// </summary>
        PostProcessing,

        /// <summary>
        /// Uploading to PACS server
        /// </summary>
        PacsUpload,

        /// <summary>
        /// Processing completed successfully
        /// </summary>
        Complete,

        /// <summary>
        /// Error occurred during processing
        /// </summary>
        Error
    }
}


================================================================================
FILE: src\CamBridge.Core\Interfaces\IDicomTagMapper.cs
================================================================================

using System.Collections.Generic;
using FellowOakDicom;
using CamBridge.Core;

namespace CamBridge.Core.Interfaces
{
    /// <summary>
    /// Interface for DICOM tag mapping services
    /// </summary>
    public interface IDicomTagMapper
    {
        /// <summary>
        /// Applies a mapping rule to transform a value
        /// </summary>
        /// <param name="value">The value to transform</param>
        /// <param name="transform">The transform to apply</param>
        /// <returns>The transformed value</returns>
        string? ApplyTransform(string? value, string? transform);

        /// <summary>
        /// Maps source data to a DICOM dataset using mapping rules
        /// </summary>
        /// <param name="dataset">The DICOM dataset to populate</param>
        /// <param name="sourceData">The source data dictionary</param>
        /// <param name="mappingRules">The mapping rules to apply</param>
        void MapToDataset(DicomDataset dataset, Dictionary<string, string> sourceData, IEnumerable<MappingRule> mappingRules);
    }
}


================================================================================
FILE: src\CamBridge.Core\Interfaces\IMappingConfiguration.cs
================================================================================

// File: src/CamBridge.Core/Interfaces/IMappingConfiguration.cs
// Version: 0.8.10
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-30
// Status: Added correlation ID overload

using System.Collections.Generic;
using System.Threading.Tasks;

namespace CamBridge.Core.Interfaces
{
    /// <summary>
    /// Interface for managing DICOM mapping configurations
    /// </summary>
    public interface IMappingConfiguration
    {
        /// <summary>
        /// Gets all configured mapping rules
        /// </summary>
        IReadOnlyList<MappingRule> GetMappingRules();

        /// <summary>
        /// Loads mapping configuration from a file
        /// </summary>
        /// <param name="filePath">Path to the configuration file (optional)</param>
        /// <returns>True if loaded successfully, false otherwise</returns>
        Task<bool> LoadConfigurationAsync(string? filePath = null);

        /// <summary>
        /// Loads mapping configuration from a file with correlation ID for logging
        /// </summary>
        /// <param name="filePath">Path to the configuration file (optional)</param>
        /// <param name="correlationId">Correlation ID for log tracking</param>
        /// <returns>True if loaded successfully, false otherwise</returns>
        Task<bool> LoadConfigurationAsync(string? filePath, string? correlationId);

        /// <summary>
        /// Saves mapping configuration to a file
        /// </summary>
        /// <param name="rules">The mapping rules to save</param>
        /// <param name="filePath">Path to save the configuration (optional)</param>
        /// <returns>True if saved successfully, false otherwise</returns>
        Task<bool> SaveConfigurationAsync(IEnumerable<MappingRule> rules, string? filePath = null);

        /// <summary>
        /// Adds a new mapping rule
        /// </summary>
        void AddRule(MappingRule rule);

        /// <summary>
        /// Removes mapping rules for a specific source field
        /// </summary>
        void RemoveRule(string sourceField);

        /// <summary>
        /// Gets the mapping rule for a specific source field
        /// </summary>
        MappingRule? GetRuleForSource(string sourceField);

        /// <summary>
        /// Gets all mapping rules that target a specific DICOM tag
        /// </summary>
        IEnumerable<MappingRule> GetRulesForTag(string dicomTag);

        /// <summary>
        /// Validates all mapping rules
        /// </summary>
        void ValidateRules();
    }
}


================================================================================
FILE: src\CamBridge.Core\Logging\LogContext.cs
================================================================================

// src/CamBridge.Core/Logging/LogContext.cs
// Version: 0.8.8
// Description: Context for hierarchical logging with correlation IDs and timing
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using CamBridge.Core.Enums;

namespace CamBridge.Core.Logging
{
    /// <summary>
    /// Provides context for hierarchical logging with correlation IDs
    /// </summary>
    public class LogContext
    {
        private readonly ILogger _logger;
        private readonly Stack<StageContext> _stageStack = new();

        public string CorrelationId { get; }
        public string PipelineName { get; }
        public ProcessingStage CurrentStage { get; private set; }
        public DateTime StartTime { get; }
        public LogVerbosity Verbosity { get; }

        public LogContext(
            ILogger logger,
            string correlationId,
            string pipelineName,
            LogVerbosity verbosity = LogVerbosity.Detailed)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            CorrelationId = correlationId ?? throw new ArgumentNullException(nameof(correlationId));
            PipelineName = pipelineName ?? throw new ArgumentNullException(nameof(pipelineName));
            Verbosity = verbosity;
            StartTime = DateTime.UtcNow;
            CurrentStage = ProcessingStage.FileDetected;
        }

        /// <summary>
        /// Begins a new processing stage and returns a disposable that logs completion
        /// </summary>
        public IDisposable BeginStage(ProcessingStage stage, string? message = null)
        {
            CurrentStage = stage;
            var stageContext = new StageContext(this, stage, message);
            _stageStack.Push(stageContext);
            return stageContext;
        }

        /// <summary>
        /// Check if should log at this verbosity level
        /// </summary>
        public bool ShouldLog(LogVerbosity requiredLevel)
        {
            return Verbosity >= requiredLevel;
        }

        /// <summary>
        /// Log with correlation context - FIXED to use proper template!
        /// </summary>
        public void Log(LogLevel level, string messageTemplate, params object[] args)
        {
            // Build the full template with correlation info
            var fullTemplate = $"[{{CorrelationId}}] [{{Stage}}] {messageTemplate} [{{Pipeline}}]";

            // Build args array with correlation values first
            var fullArgs = new List<object> { CorrelationId, CurrentStage };

            // Add the user-provided args
            if (args != null && args.Length > 0)
            {
                fullArgs.AddRange(args);
            }

            // Add pipeline name at the end
            fullArgs.Add(PipelineName);

            // Log with proper template formatting
            _logger.Log(level, fullTemplate, fullArgs.ToArray());
        }

        /// <summary>
        /// Log information with correlation context
        /// </summary>
        public void LogInformation(string messageTemplate, params object[] args)
        {
            if (ShouldLog(LogVerbosity.Minimal))
            {
                Log(LogLevel.Information, messageTemplate, args);
            }
        }

        /// <summary>
        /// Log debug with correlation context
        /// </summary>
        public void LogDebug(string messageTemplate, params object[] args)
        {
            if (ShouldLog(LogVerbosity.Debug))
            {
                Log(LogLevel.Debug, messageTemplate, args);
            }
        }

        /// <summary>
        /// Log warning with correlation context
        /// </summary>
        public void LogWarning(string messageTemplate, params object[] args)
        {
            if (ShouldLog(LogVerbosity.Normal))
            {
                Log(LogLevel.Warning, messageTemplate, args);
            }
        }

        /// <summary>
        /// Log error with correlation context
        /// </summary>
        public void LogError(Exception ex, string messageTemplate, params object[] args)
        {
            // Always log errors
            var fullTemplate = $"[{{CorrelationId}}] [{{Stage}}] {messageTemplate} [{{Pipeline}}]";

            var fullArgs = new List<object> { CorrelationId, CurrentStage };
            if (args != null && args.Length > 0)
            {
                fullArgs.AddRange(args);
            }
            fullArgs.Add(PipelineName);

            _logger.LogError(ex, fullTemplate, fullArgs.ToArray());
        }

        /// <summary>
        /// Context for a processing stage with timing
        /// </summary>
        private class StageContext : IDisposable
        {
            private readonly LogContext _logContext;
            private readonly ProcessingStage _stage;
            private readonly Stopwatch _stopwatch;
            private readonly string? _customMessage;
            private bool _hasLoggedStart = false;

            public StageContext(LogContext logContext, ProcessingStage stage, string? customMessage)
            {
                _logContext = logContext;
                _stage = stage;
                _customMessage = customMessage;
                _stopwatch = Stopwatch.StartNew();

                // ONLY log start if:
                // 1. Detailed logging is enabled
                // 2. AND a custom message was provided (indicating explicit logging intent)
                if (_logContext.ShouldLog(LogVerbosity.Detailed) && !string.IsNullOrEmpty(_customMessage))
                {
                    _logContext.LogInformation(_customMessage);
                    _hasLoggedStart = true;
                }
            }

            public void Dispose()
            {
                _stopwatch.Stop();

                // ONLY log completion if:
                // 1. Normal+ logging is enabled
                // 2. AND we didn't already log a custom message
                // 3. OR it's a significant stage completion (Complete/Error)
                if (_logContext.ShouldLog(LogVerbosity.Normal))
                {
                    // Special handling for key stages
                    if (_stage == ProcessingStage.Complete || _stage == ProcessingStage.Error)
                    {
                        // Always log these important stages
                        _logContext.LogInformation("{Stage} [{Duration}ms]", _stage, _stopwatch.ElapsedMilliseconds);
                    }
                    else if (!_hasLoggedStart && _stopwatch.ElapsedMilliseconds > 100)
                    {
                        // Only log other stages if they took significant time and we didn't log start
                        _logContext.LogInformation("{Stage} completed [{Duration}ms]", _stage, _stopwatch.ElapsedMilliseconds);
                    }
                }

                // Pop from stack
                if (_logContext._stageStack.Count > 0)
                {
                    _logContext._stageStack.Pop();
                }
            }
        }
    }

    /// <summary>
    /// Extension methods for clean logging
    /// </summary>
    public static class LogContextExtensions
    {
        /// <summary>
        /// Create a log context from a logger
        /// </summary>
        public static LogContext CreateContext(
            this ILogger logger,
            string correlationId,
            string pipelineName,
            LogVerbosity verbosity = LogVerbosity.Detailed)
        {
            return new LogContext(logger, correlationId, pipelineName, verbosity);
        }

        /// <summary>
        /// Log a processing stage with timing - SIMPLIFIED!
        /// </summary>
        public static IDisposable LogStage(
            this LogContext context,
            ProcessingStage stage)
        {
            // No message = no duplicate logging!
            return context.BeginStage(stage, null);
        }

        /// <summary>
        /// Log a processing stage with custom message
        /// </summary>
        public static IDisposable LogStageWithMessage(
            this LogContext context,
            ProcessingStage stage,
            string message)
        {
            return context.BeginStage(stage, message);
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: src\CamBridge.Core\obj\Release\net8.0\CamBridge.Core.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.10+ee5ebf36a408cf8cb648db40b0c428beb752eef8")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Core\obj\x64\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: src\CamBridge.Core\obj\x64\Release\net8.0\CamBridge.Core.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.10+ee5ebf36a408cf8cb648db40b0c428beb752eef8")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Core\ValueObjects\DicomTag.cs
================================================================================

namespace CamBridge.Core.ValueObjects
{
    /// <summary>
    /// Represents a DICOM tag with group and element numbers
    /// </summary>
    public record DicomTag
    {
        public ushort Group { get; }
        public ushort Element { get; }

        public DicomTag(ushort group, ushort element)
        {
            Group = group;
            Element = element;
        }

        /// <summary>
        /// Creates a DicomTag from string format "(0010,0010)"
        /// </summary>
        public static DicomTag Parse(string tagString)
        {
            if (string.IsNullOrWhiteSpace(tagString))
                throw new ArgumentException("Tag string cannot be empty");

            // Remove parentheses and spaces
            var cleaned = tagString.Trim().Trim('(', ')').Replace(" ", "");
            var parts = cleaned.Split(',');

            if (parts.Length != 2)
                throw new ArgumentException($"Invalid tag format: {tagString}");

            var group = Convert.ToUInt16(parts[0], 16);
            var element = Convert.ToUInt16(parts[1], 16);

            return new DicomTag(group, element);
        }

        public override string ToString() => $"({Group:X4},{Element:X4})";

        // Common DICOM Tags as constants
        public static class PatientModule
        {
            public static readonly DicomTag PatientName = new(0x0010, 0x0010);
            public static readonly DicomTag PatientID = new(0x0010, 0x0020);
            public static readonly DicomTag PatientBirthDate = new(0x0010, 0x0030);
            public static readonly DicomTag PatientSex = new(0x0010, 0x0040);
            public static readonly DicomTag OtherPatientIDs = new(0x0010, 0x1000);
            public static readonly DicomTag PatientComments = new(0x0010, 0x4000);
        }

        public static class StudyModule
        {
            public static readonly DicomTag StudyInstanceUID = new(0x0020, 0x000D);
            public static readonly DicomTag StudyDate = new(0x0008, 0x0020);
            public static readonly DicomTag StudyTime = new(0x0008, 0x0030);
            public static readonly DicomTag AccessionNumber = new(0x0008, 0x0050);
            public static readonly DicomTag ReferringPhysicianName = new(0x0008, 0x0090);
            public static readonly DicomTag StudyID = new(0x0020, 0x0010);
            public static readonly DicomTag StudyDescription = new(0x0008, 0x1030);
        }

        public static class SeriesModule
        {
            public static readonly DicomTag Modality = new(0x0008, 0x0060);
            public static readonly DicomTag SeriesInstanceUID = new(0x0020, 0x000E);
            public static readonly DicomTag SeriesNumber = new(0x0020, 0x0011);
            public static readonly DicomTag SeriesDate = new(0x0008, 0x0021);
            public static readonly DicomTag SeriesTime = new(0x0008, 0x0031);
            public static readonly DicomTag SeriesDescription = new(0x0008, 0x103E);
            public static readonly DicomTag PerformingPhysicianName = new(0x0008, 0x1050);
        }

        public static class InstanceModule
        {
            public static readonly DicomTag SOPClassUID = new(0x0008, 0x0016);
            public static readonly DicomTag SOPInstanceUID = new(0x0008, 0x0018);
            public static readonly DicomTag InstanceNumber = new(0x0020, 0x0013);
            public static readonly DicomTag ContentDate = new(0x0008, 0x0023);
            public static readonly DicomTag ContentTime = new(0x0008, 0x0033);
            public static readonly DicomTag AcquisitionDateTime = new(0x0008, 0x002A);
        }

        public static class EquipmentModule
        {
            public static readonly DicomTag Manufacturer = new(0x0008, 0x0070);
            public static readonly DicomTag InstitutionName = new(0x0008, 0x0080);
            public static readonly DicomTag ManufacturerModelName = new(0x0008, 0x1090);
            public static readonly DicomTag StationName = new(0x0008, 0x1010);
            public static readonly DicomTag SoftwareVersions = new(0x0018, 0x1020);
        }

        // Legacy alias for compatibility
        public static class ImageModule
        {
            public static readonly DicomTag SOPInstanceUID = InstanceModule.SOPInstanceUID;
            public static readonly DicomTag InstanceNumber = InstanceModule.InstanceNumber;
            public static readonly DicomTag ContentDate = InstanceModule.ContentDate;
            public static readonly DicomTag ContentTime = InstanceModule.ContentTime;
            public static readonly DicomTag AcquisitionDateTime = InstanceModule.AcquisitionDateTime;
        }
    }
}


================================================================================
FILE: src\CamBridge.Core\ValueObjects\ExifTag.cs
================================================================================

namespace CamBridge.Core.ValueObjects
{
    /// <summary>
    /// Represents an EXIF tag with its ID and name
    /// </summary>
    public record ExifTag
    {
        public int Id { get; }
        public string Name { get; }
        public string Category { get; }

        public ExifTag(int id, string name, string category = "Unknown")
        {
            Id = id;
            Name = name ?? throw new ArgumentNullException(nameof(name));
            Category = category;
        }

        public override string ToString() => $"{Name} (0x{Id:X4})";

        // Common EXIF Tags
        public static class Image
        {
            public static readonly ExifTag Make = new(0x010F, "Make", "Image");
            public static readonly ExifTag Model = new(0x0110, "Model", "Image");
            public static readonly ExifTag Software = new(0x0131, "Software", "Image");
            public static readonly ExifTag DateTime = new(0x0132, "DateTime", "Image");
            public static readonly ExifTag ImageDescription = new(0x010E, "ImageDescription", "Image");
            public static readonly ExifTag Orientation = new(0x0112, "Orientation", "Image");
            public static readonly ExifTag XResolution = new(0x011A, "XResolution", "Image");
            public static readonly ExifTag YResolution = new(0x011B, "YResolution", "Image");
        }

        public static class Photo
        {
            public static readonly ExifTag ExposureTime = new(0x829A, "ExposureTime", "Photo");
            public static readonly ExifTag FNumber = new(0x829D, "FNumber", "Photo");
            public static readonly ExifTag ISOSpeedRatings = new(0x8827, "ISOSpeedRatings", "Photo");
            public static readonly ExifTag DateTimeOriginal = new(0x9003, "DateTimeOriginal", "Photo");
            public static readonly ExifTag Flash = new(0x9209, "Flash", "Photo");
            public static readonly ExifTag FocalLength = new(0x920A, "FocalLength", "Photo");
            public static readonly ExifTag UserComment = new(0x9286, "UserComment", "Photo");
            public static readonly ExifTag ExifVersion = new(0x9000, "ExifVersion", "Photo");
        }

        public static class GPS
        {
            public static readonly ExifTag GPSLatitudeRef = new(0x0001, "GPSLatitudeRef", "GPS");
            public static readonly ExifTag GPSLatitude = new(0x0002, "GPSLatitude", "GPS");
            public static readonly ExifTag GPSLongitudeRef = new(0x0003, "GPSLongitudeRef", "GPS");
            public static readonly ExifTag GPSLongitude = new(0x0004, "GPSLongitude", "GPS");
            public static readonly ExifTag GPSAltitude = new(0x0006, "GPSAltitude", "GPS");
            public static readonly ExifTag GPSTimeStamp = new(0x0007, "GPSTimeStamp", "GPS");
        }

        // Ricoh specific
        public static readonly ExifTag RicohUserComment = Photo.UserComment;
    }
}

================================================================================
FILE: src\CamBridge.Core\ValueObjects\PatientId.cs
================================================================================

using System;

namespace CamBridge.Core.ValueObjects
{
    /// <summary>
    /// Represents a patient identifier as a value object
    /// </summary>
    public class PatientId : IEquatable<PatientId>
    {
        /// <summary>
        /// Gets the patient identifier value
        /// </summary>
        public string Value { get; }

        /// <summary>
        /// Creates a new PatientId instance
        /// </summary>
        /// <param name="value">The patient identifier value</param>
        /// <exception cref="ArgumentNullException">When value is null</exception>
        /// <exception cref="ArgumentException">When value is empty or whitespace</exception>
        public PatientId(string value)
        {
            if (value == null)
                throw new ArgumentNullException(nameof(value));

            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("Patient ID cannot be empty or whitespace", nameof(value));

            Value = value.Trim();
        }

        /// <summary>
        /// Creates a new random PatientId for testing purposes
        /// </summary>
        public static PatientId NewId() => new PatientId(Guid.NewGuid().ToString("N"));

        public bool Equals(PatientId? other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            return Value == other.Value;
        }

        public override bool Equals(object? obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((PatientId)obj);
        }

        public override int GetHashCode() => Value.GetHashCode();

        public static bool operator ==(PatientId? left, PatientId? right) => Equals(left, right);

        public static bool operator !=(PatientId? left, PatientId? right) => !Equals(left, right);

        public override string ToString() => Value;

        /// <summary>
        /// Implicit conversion from string
        /// </summary>
        public static implicit operator string(PatientId patientId) => patientId.Value;

        /// <summary>
        /// Explicit conversion to PatientId
        /// </summary>
        public static explicit operator PatientId(string value) => new PatientId(value);
    }
}


================================================================================
FILE: src\CamBridge.Core\ValueObjects\StudyId.cs
================================================================================

using System;

namespace CamBridge.Core.ValueObjects
{
    /// <summary>
    /// Strongly typed study identifier
    /// </summary>
    public record StudyId
    {
        public string Value { get; }

        public StudyId(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("Study ID cannot be empty", nameof(value));

            // Validate format (max 16 chars for DICOM Study ID)
            if (value.Length > 16)
                throw new ArgumentException($"Study ID too long (max 16 chars): {value}", nameof(value));

            Value = value.Trim().ToUpper();
        }

        public override string ToString() => Value;

        // Implicit conversion to string
        public static implicit operator string(StudyId id) => id.Value;

        // Factory methods
        public static StudyId CreateFromExamId(string examId)
        {
            if (string.IsNullOrWhiteSpace(examId))
                return Generate();

            // Truncate if necessary and ensure uppercase
            var cleanId = examId.Trim().ToUpper();
            if (cleanId.Length > 16)
                cleanId = cleanId.Substring(0, 16);

            return new StudyId(cleanId);
        }

        public static StudyId Generate()
        {
            // Generate unique study ID
            // Format: SYYYYMMDDHHMMSS (max 16 chars)
            var timestamp = DateTime.UtcNow.ToString("yyyyMMddHHmmss");
            return new StudyId($"S{timestamp}");
        }

        public static StudyId GenerateForDate(DateTime date)
        {
            // Generate study ID for specific date
            var dateStr = date.ToString("yyyyMMdd");
            var random = new Random().Next(1000, 9999);
            return new StudyId($"S{dateStr}{random}");
        }
    }
}
