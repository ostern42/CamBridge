################################################################################
# CamBridge Sources - CONFIG
# Generated: 2025-06-23 20:28:24
# Root Path: src\CamBridge.Config
# Description: WPF configuration tool, UI, ViewModels
################################################################################

## PROJECT SUMMARY
Total Files: 54
Total Lines: 11675
Total Size: 468,69 KB

Files by Type:
  .cs: 40 files
  .csproj: 1 files
  .json: 1 files
  .xaml: 12 files

## DIRECTORY STRUCTURE
src\CamBridge.Config/
+-- Converters/ (1 files)
+-- Dialogs/ (4 files)
+-- Extensions/ (2 files)
+-- Helpers/ (1 files)
+-- Models/ (2 files)
+-- Properties/ (1 files)
+-- Services/ (9 files)
+-- ViewModels/ (11 files)
+-- Views/ (16 files)

## FILE CONTENTS

================================================================================
FILE: App.xaml
--------------------------------------------------------------------------------
Size: 4,67 KB | Lines: 73 | Modified: 2025-06-22 15:53:47
================================================================================

<!-- src\CamBridge.Config\App.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Application resources with global converter registration including IntToVisibilityConverter -->

<Application x:Class="CamBridge.Config.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:ui="http://schemas.modernwpf.com/2019"
             xmlns:conv="clr-namespace:CamBridge.Config.Converters"
             ShutdownMode="OnMainWindowClose">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ui:ThemeResources RequestedTheme="Light">
                    <ui:ThemeResources.ThemeDictionaries>
                        <ResourceDictionary x:Key="Light" ui:ThemeDictionary.Key="Light">
                            <!-- Blaue Akzentfarben -->
                            <Color x:Key="SystemAccentColor">#0078D4</Color>
                            <Color x:Key="SystemAccentColorLight1">#1A86E3</Color>
                            <Color x:Key="SystemAccentColorLight2">#4AA0E6</Color>
                            <Color x:Key="SystemAccentColorLight3">#6BB1EA</Color>
                            <Color x:Key="SystemAccentColorDark1">#005A9E</Color>
                            <Color x:Key="SystemAccentColorDark2">#004275</Color>
                            <Color x:Key="SystemAccentColorDark3">#002642</Color>
                        </ResourceDictionary>
                        <ResourceDictionary x:Key="Dark" ui:ThemeDictionary.Key="Dark">
                            <!-- Blaue Akzentfarben auch im Dark Mode -->
                            <Color x:Key="SystemAccentColor">#0078D4</Color>
                            <Color x:Key="SystemAccentColorLight1">#1A86E3</Color>
                            <Color x:Key="SystemAccentColorLight2">#4AA0E6</Color>
                            <Color x:Key="SystemAccentColorLight3">#6BB1EA</Color>
                            <Color x:Key="SystemAccentColorDark1">#005A9E</Color>
                            <Color x:Key="SystemAccentColorDark2">#004275</Color>
                            <Color x:Key="SystemAccentColorDark3">#002642</Color>
                        </ResourceDictionary>
                        <ResourceDictionary x:Key="HighContrast" ui:ThemeDictionary.Key="HighContrast">
                            <Color x:Key="SystemAccentColor">#0078D4</Color>
                        </ResourceDictionary>
                    </ui:ThemeResources.ThemeDictionaries>
                </ui:ThemeResources>
                <ui:XamlControlsResources />
            </ResourceDictionary.MergedDictionaries>
            <!-- Global Converters with both naming conventions -->
            <conv:BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
            <conv:BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
            <conv:InverseBooleanToVisibilityConverter x:Key="InverseBoolToVisibility"/>
            <conv:InverseBooleanToVisibilityConverter x:Key="InverseBooleanToVisibilityConverter"/>
            <conv:NullToVisibilityConverter x:Key="NullToVisibility"/>
            <conv:NullToVisibilityConverter x:Key="NullToVisibilityConverter"/>
            <conv:GreaterThanZeroConverter x:Key="GreaterThanZeroConverter"/>
            <conv:ZeroToVisibilityConverter x:Key="ZeroToVisibility"/>
            <conv:IntToVisibilityConverter x:Key="IntToVisibilityConverter"/>
            <conv:EnumToCollectionConverter x:Key="EnumToCollection"/>
            <conv:ServiceStatusToColorConverter x:Key="ServiceStatusToColor"/>
            <conv:TimeSpanToStringConverter x:Key="TimeSpanToString"/>
            <conv:FileSizeConverter x:Key="FileSizeConverter"/>

            <!-- Additional converters for Pipeline Config -->
            <conv:InverseBooleanConverter x:Key="InverseBooleanConverter"/>
            <conv:SecondsToMillisecondsConverter x:Key="SecondsToMillisecondsConverter"/>
            <conv:EnumToBooleanConverter x:Key="EnumToBooleanConverter"/>
            <conv:FileSelectConverter x:Key="FileSelectConverter"/>
            <conv:MultiBooleanAndConverter x:Key="MultiBooleanAndConverter"/>
            <conv:MultiBooleanOrConverter x:Key="MultiBooleanOrConverter"/>

            <!-- Alias for compatibility -->
            <conv:EnumToCollectionConverter x:Key="EnumToCollectionConverter"/>
            <conv:ServiceStatusToColorConverter x:Key="ServiceStatusToColorConverter"/>
            <conv:TimeSpanToStringConverter x:Key="TimeSpanToStringConverter"/>
        </ResourceDictionary>
    </Application.Resources>
</Application>


================================================================================
FILE: App.xaml.cs
--------------------------------------------------------------------------------
Size: 7,04 KB | Lines: 199 | Modified: 2025-06-23 11:53:04
================================================================================

// src\CamBridge.Config\App.xaml.cs
// Version: 0.7.28
// Description: Application entry point with LogViewer registration
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Threading;
using CamBridge.Config.Services;
using CamBridge.Config.ViewModels;
using CamBridge.Config.Views;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace CamBridge.Config
{
    /// <summary>
    /// Main application class
    /// </summary>
    public partial class App : Application
    {
        private IHost? _host;

        /// <summary>
        /// Gets the current host instance
        /// </summary>
        public IHost? Host => _host;

        /// <summary>
        /// Gets the current service provider
        /// </summary>
        public static IServiceProvider Services { get; private set; } = null!;

        /// <summary>
        /// Application startup
        /// </summary>
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // Setup global exception handlers
            AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;
            DispatcherUnhandledException += OnDispatcherUnhandledException;

            try
            {
                ConfigureHost();
            }
            catch (Exception ex)
            {
                LogException("Host configuration failed", ex);
                MessageBox.Show(
                    $"Failed to start application: {ex.Message}",
                    "Startup Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
                Shutdown(1);
            }
        }

        /// <summary>
        /// Configure the dependency injection host
        /// </summary>
        private void ConfigureHost()
        {
            // Verify config file exists - Added in v0.5.32
            var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            var configPath = System.IO.Path.Combine(appDataPath, "CamBridge", "appsettings.json");

            if (!System.IO.File.Exists(configPath))
            {
                // Also check ProgramData (where Service saves config)
                var programDataPath = System.IO.Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                    "CamBridge",
                    "appsettings.json");

                if (System.IO.File.Exists(programDataPath))
                {
                    configPath = programDataPath;
                }
                else
                {
                    MessageBox.Show(
                        $"Configuration file not found.\nExpected at: {configPath}\n\nPlease run the service first to create initial configuration.",
                        "Configuration Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                }
            }

            _host = Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder()
                .ConfigureServices((context, services) =>
                {
                    // Services
                    services.AddSingleton<INavigationService, NavigationService>();
                    services.AddSingleton<IServiceManager, ServiceManager>();
                    services.AddSingleton<IConfigurationService, ConfigurationService>();

                    // HttpClient for API calls - FIXED PORT!
                    services.AddHttpClient<IApiService, HttpApiService>(client =>
                    {
                        // CRITICAL: Use port 5111, not 5050!
                        client.BaseAddress = new Uri("http://localhost:5111/");
                        client.Timeout = TimeSpan.FromSeconds(5);
                    });

                    // ViewModels - Updated with LogViewerViewModel
                    services.AddTransient<MainViewModel>();
                    services.AddTransient<DashboardViewModel>();
                    services.AddTransient<ServiceControlViewModel>();
                    services.AddTransient<PipelineConfigViewModel>();
                    services.AddTransient<DeadLettersViewModel>();
                    services.AddTransient<MappingEditorViewModel>();
                    services.AddTransient<LogViewerViewModel>(); // NEW!

                    // Views - Registration for LogViewerPage
                    services.AddTransient<LogViewerPage>(); // NEW!

                    // Logging
                    services.AddLogging(configure =>
                    {
                        configure.AddDebug();
                        configure.SetMinimumLevel(LogLevel.Debug);
                    });
                })
                .Build();

            Services = _host.Services;

            // Create and show main window
            var mainWindow = new MainWindow();
            mainWindow.Show();
        }

        /// <summary>
        /// Application exit cleanup
        /// </summary>
        protected override void OnExit(ExitEventArgs e)
        {
            _host?.Dispose();
            base.OnExit(e);
        }

        /// <summary>
        /// Handle unhandled exceptions
        /// </summary>
        private void OnUnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            LogException("Unhandled exception", e.ExceptionObject as Exception);

            MessageBox.Show(
                "An unexpected error occurred. The application will now close.",
                "Fatal Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }

        /// <summary>
        /// Handle dispatcher unhandled exceptions
        /// </summary>
        private void OnDispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            LogException("Dispatcher exception", e.Exception);

            // Show error to user
            MessageBox.Show(
                $"An error occurred: {e.Exception.Message}",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Warning);

            // Mark as handled to prevent crash
            e.Handled = true;
        }

        /// <summary>
        /// Logs an exception
        /// </summary>
        private void LogException(string context, Exception? exception)
        {
            if (exception == null) return;

            try
            {
                var logger = Services?.GetService<ILogger<App>>();
                logger?.LogError(exception, "{Context}", context);
            }
            catch
            {
                // Fallback to debug output if logging fails
                System.Diagnostics.Debug.WriteLine($"{context}: {exception}");
            }
        }
    }
}


================================================================================
FILE: CamBridge.Config.csproj
--------------------------------------------------------------------------------
Size: 1,86 KB | Lines: 44 | Modified: 2025-06-12 23:58:03
================================================================================

<!-- Temporäre Debug-Version - src/CamBridge.Config/CamBridge.Config.csproj -->
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<!-- Changed to Exe for console output -->
		<TargetFramework>net8.0-windows</TargetFramework>
		<UseWPF>true</UseWPF>
		<Platform>x64</Platform>
		<Platforms>x64</Platforms>
		
		<Nullable>enable</Nullable>
		<ImplicitUsings>enable</ImplicitUsings>
		<ApplicationManifest>app.manifest</ApplicationManifest>
		<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="CommunityToolkit.Mvvm" Version="8.2.2" />
		<PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
		<PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />
		<PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
		<PackageReference Include="Microsoft.Extensions.Hosting" Version="8.0.0" />
		<PackageReference Include="Microsoft.Extensions.Http" Version="8.0.0" />
		<PackageReference Include="Microsoft.Extensions.Logging.Debug" Version="8.0.0" />
		<PackageReference Include="Microsoft.Extensions.Logging.Console" Version="8.0.0" />
		<PackageReference Include="ModernWpfUI" Version="0.9.6" />
		<PackageReference Include="Ookii.Dialogs.Wpf" Version="5.0.1" />
		<PackageReference Include="System.ServiceProcess.ServiceController" Version="8.0.0" />
		<PackageReference Include="System.Drawing.Common" Version="8.0.10" />
		<PackageReference Include="System.Text.Json" Version="8.0.5" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\CamBridge.Core\CamBridge.Core.csproj" />
				<ProjectReference Include="..\CamBridge.Infrastructure\CamBridge.Infrastructure.csproj" />
	</ItemGroup>

	<ItemGroup>
		<Reference Include="System.Windows.Forms" />
	</ItemGroup>

</Project>


================================================================================
FILE: Converters/ValueConverters.cs
--------------------------------------------------------------------------------
Size: 19,57 KB | Lines: 586 | Modified: 2025-06-23 11:53:04
================================================================================

// src/CamBridge.Config/Converters/ValueConverters.cs
// Version: 0.7.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Globalization;
using System.Windows;
using System.Windows.Data;
using System.Windows.Media;
using CamBridge.Core;

namespace CamBridge.Config.Converters
{
    /// <summary>
    /// Converts integer to Visibility based on comparison with parameter
    /// NEW in v0.7.28 for LogViewerPage
    /// </summary>
    public class IntToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            int intValue = 0;
            int compareValue = 0;

            // Convert value
            if (value != null)
            {
                try
                {
                    intValue = System.Convert.ToInt32(value);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Convert parameter
            if (parameter != null)
            {
                try
                {
                    compareValue = System.Convert.ToInt32(parameter);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Show when value equals compareValue
            return intValue == compareValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean values to Visibility
    /// </summary>
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = value is bool b && b;
            bool invert = parameter as string == "Inverse";

            if (invert)
                return boolValue ? Visibility.Collapsed : Visibility.Visible;
            else
                return boolValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Inverts boolean to visibility conversion
    /// </summary>
    public class InverseBooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = value is bool b && b;
            return boolValue ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts numeric values greater than zero to true
    /// </summary>
    public class GreaterThanZeroConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null) return false;

            try
            {
                double numValue = System.Convert.ToDouble(value);
                return numValue > 0;
            }
            catch
            {
                return false;
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts null values to Visibility
    /// </summary>
    public class NullToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool isNull = value == null;
            bool invert = parameter as string == "Inverse";

            if (invert)
                return isNull ? Visibility.Visible : Visibility.Collapsed;
            else
                return isNull ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts zero values to Visibility
    /// </summary>
    public class ZeroToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool isZero = false;

            if (value != null)
            {
                try
                {
                    double numValue = System.Convert.ToDouble(value);
                    isZero = Math.Abs(numValue) < 0.0001; // Floating point comparison
                }
                catch
                {
                    // If conversion fails, treat as non-zero
                }
            }

            bool invert = parameter as string == "Inverse";

            if (invert)
                return isZero ? Visibility.Collapsed : Visibility.Visible;
            else
                return isZero ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts error count to color brush
    /// </summary>
    public class ErrorCountToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            int errorCount = 0;

            if (value != null)
            {
                try
                {
                    errorCount = System.Convert.ToInt32(value);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Return red color if errors exist, otherwise default
            if (errorCount > 0)
            {
                return new SolidColorBrush(Color.FromRgb(255, 107, 107)); // Light red
            }

            return DependencyProperty.UnsetValue; // Use default style
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean values to inverse boolean
    /// </summary>
    public class InverseBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return !(value is bool b && b);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return !(value is bool b && b);
        }
    }

    /// <summary>
    /// Converts empty string to visibility
    /// </summary>
    public class EmptyStringToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            string? str = value as string;
            bool isEmpty = string.IsNullOrWhiteSpace(str);
            bool invert = parameter as string == "Inverse";

            if (invert)
                return isEmpty ? Visibility.Visible : Visibility.Collapsed;
            else
                return isEmpty ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts service status to color
    /// </summary>
    public class ServiceStatusToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            string status = value as string ?? "";

            return status.ToLower() switch
            {
                "running" => new SolidColorBrush(Colors.Green),
                "stopped" => new SolidColorBrush(Colors.Red),
                "paused" => new SolidColorBrush(Colors.Orange),
                _ => new SolidColorBrush(Colors.Gray)
            };
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts seconds to milliseconds
    /// </summary>
    public class SecondsToMillisecondsConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double seconds)
                return seconds * 1000;
            if (value is int intSeconds)
                return intSeconds * 1000;
            return 0;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double milliseconds)
                return milliseconds / 1000;
            if (value is int intMilliseconds)
                return intMilliseconds / 1000;
            return 0;
        }
    }

    /// <summary>
    /// Converts enum value to boolean based on parameter
    /// </summary>
    public class EnumToBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null || parameter == null)
                return false;

            string enumValue = value.ToString();
            string targetValue = parameter.ToString();

            return enumValue.Equals(targetValue, StringComparison.InvariantCultureIgnoreCase);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isChecked && isChecked)
            {
                if (parameter != null && targetType.IsEnum)
                {
                    return Enum.Parse(targetType, parameter.ToString());
                }
            }

            return Binding.DoNothing;
        }
    }

    /// <summary>
    /// Converter for file selection dialogs
    /// </summary>
    public class FileSelectConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // Simply pass through the value
            return value;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // Simply pass through the value
            return value;
        }
    }

    /// <summary>
    /// Multi-value boolean OR converter
    /// </summary>
    public class MultiBooleanOrConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length == 0)
                return false;

            foreach (var value in values)
            {
                if (value is bool b && b)
                    return true;
            }

            return false;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts enum types to collection for ComboBox binding
    /// </summary>
    public class EnumToCollectionConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return Enum.GetValues(parameter as Type ?? value?.GetType() ?? typeof(object));
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts file size to human-readable format
    /// </summary>
    public class FileSizeConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null) return "0 B";

            long bytes = System.Convert.ToInt64(value);
            string[] sizes = { "B", "KB", "MB", "GB", "TB" };
            int order = 0;
            double size = bytes;

            while (size >= 1024 && order < sizes.Length - 1)
            {
                order++;
                size /= 1024;
            }

            return $"{size:0.##} {sizes[order]}";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts TimeSpan to readable string
    /// </summary>
    public class TimeSpanToStringConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is TimeSpan timeSpan)
            {
                if (timeSpan.TotalDays >= 1)
                    return $"{(int)timeSpan.TotalDays}d {timeSpan.Hours}h {timeSpan.Minutes}m";
                else if (timeSpan.TotalHours >= 1)
                    return $"{(int)timeSpan.TotalHours}h {timeSpan.Minutes}m";
                else
                    return $"{timeSpan.Minutes}m {timeSpan.Seconds}s";
            }
            return "0s";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Multi-value boolean AND converter
    /// </summary>
    public class MultiBooleanAndConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length == 0)
                return false;

            foreach (var value in values)
            {
                if (!(value is bool b) || !b)
                    return false;
            }

            return true;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Null and boolean AND converter
    /// </summary>
    public class NullBooleanAndConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length < 2)
                return false;

            // First value should not be null, second should be true
            return values[0] != null && values[1] is bool b && b;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean to color (Green for true, Red for false)
    /// NEW in v0.7.21 for Dashboard minimal
    /// </summary>
    public class BoolToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isTrue)
            {
                return new SolidColorBrush(isTrue ? Colors.Green : Colors.Red);
            }
            return new SolidColorBrush(Colors.Gray);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts Transform enum to a visual symbol for display
    /// NEW in v0.7.25 for Mapping Editor Redesign
    /// </summary>
    public class TransformToSymbolConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is ValueTransform transform)
            {
                return transform switch
                {
                    ValueTransform.None => "â†’",
                    ValueTransform.DateToDicom => "ðŸ“…â†’",
                    ValueTransform.TimeToDicom => "â°â†’",
                    ValueTransform.DateTimeToDicom => "ðŸ“…â°â†’",
                    ValueTransform.MapGender => "â™‚â™€â†’",
                    ValueTransform.RemovePrefix => "âœ‚â†’",
                    ValueTransform.ExtractDate => "ðŸ“…â†",
                    ValueTransform.ExtractTime => "â°â†",
                    ValueTransform.ToUpperCase => "Aâ†’",
                    ValueTransform.ToLowerCase => "aâ†’",
                    ValueTransform.Trim => "âŽµâ†’",
                    _ => "â†’"
                };
            }
            return "â†’";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts Transform enum to a descriptive text
    /// NEW in v0.7.25 for Mapping Editor Redesign
    /// </summary>
    public class TransformToDescriptionConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is ValueTransform transform)
            {
                return transform switch
                {
                    ValueTransform.None => "Direct mapping",
                    ValueTransform.DateToDicom => "Convert date to DICOM format (YYYYMMDD)",
                    ValueTransform.TimeToDicom => "Convert time to DICOM format (HHMMSS)",
                    ValueTransform.DateTimeToDicom => "Convert datetime to DICOM format",
                    ValueTransform.MapGender => "Map gender values (M/F/O)",
                    ValueTransform.RemovePrefix => "Remove prefix from value",
                    ValueTransform.ExtractDate => "Extract date from datetime",
                    ValueTransform.ExtractTime => "Extract time from datetime",
                    ValueTransform.ToUpperCase => "Convert to uppercase",
                    ValueTransform.ToLowerCase => "Convert to lowercase",
                    ValueTransform.Trim => "Remove leading/trailing spaces",
                    _ => "Unknown transformation"
                };
            }
            return "No transformation";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


================================================================================
FILE: Dialogs/DicomTagBrowserDialog.xaml
--------------------------------------------------------------------------------
Size: 9,58 KB | Lines: 212 | Modified: 2025-06-18 01:03:53
================================================================================

<!-- src/CamBridge.Config/Dialogs/DicomTagBrowserDialog.xaml -->
<!-- Version: 0.7.25 -->
<!-- Enhanced with 3-column layout and NEMA-compliant descriptions -->
<Window x:Class="CamBridge.Config.Dialogs.DicomTagBrowserDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="http://schemas.modernwpf.com/2019"
        ui:WindowHelper.UseModernWindowStyle="True"
        Title="Select DICOM Tag - NEMA PS3.6 Data Dictionary"
        Height="700"
        Width="1000"
        WindowStartupLocation="CenterOwner"
        PreviewKeyDown="Window_PreviewKeyDown">

    <Window.Resources>
        <Style x:Key="GroupHeaderStyle" TargetType="GroupItem">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="GroupItem">
                        <Expander IsExpanded="True" Margin="0,0,0,8">
                            <Expander.Header>
                                <TextBlock Text="{Binding Name}" 
                                           FontSize="14" 
                                           FontWeight="SemiBold"
                                           Foreground="{DynamicResource SystemControlForegroundBaseHighBrush}"/>
                            </Expander.Header>
                            <ItemsPresenter Margin="20,0,0,0"/>
                        </Expander>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <DataTemplate x:Key="TagItemTemplate">
            <Border Padding="8,4" 
                    Background="Transparent"
                    BorderThickness="0">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="120"/>
                        <ColumnDefinition Width="300"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <!-- Tag Number -->
                    <TextBlock Grid.Column="0" 
                               Text="{Binding TagString}" 
                               FontFamily="Consolas"
                               FontSize="13"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>

                    <!-- DICOM Name -->
                    <TextBlock Grid.Column="1" 
                               Text="{Binding Name}" 
                               Margin="8,0,0,0"
                               FontWeight="SemiBold"/>

                    <!-- NEMA Description / Examples -->
                    <TextBlock Grid.Column="2" 
                               Text="{Binding Description}" 
                               Margin="8,0,0,0"
                               Opacity="0.8"
                               TextTrimming="CharacterEllipsis">
                        <TextBlock.ToolTip>
                            <ToolTip MaxWidth="400">
                                <StackPanel>
                                    <TextBlock Text="{Binding Name}" FontWeight="Bold" Margin="0,0,0,4"/>
                                    <TextBlock Text="{Binding Description}" TextWrapping="Wrap"/>
                                    <TextBlock Margin="0,4,0,0">
                                        <Run Text="VR: " FontWeight="SemiBold"/>
                                        <Run Text="{Binding VR}"/>
                                        <Run Text=" (" FontWeight="SemiBold"/>
                                        <Run Text="{Binding VRDescription}"/>
                                        <Run Text=")" FontWeight="SemiBold"/>
                                    </TextBlock>
                                </StackPanel>
                            </ToolTip>
                        </TextBlock.ToolTip>
                    </TextBlock>
                </Grid>
            </Border>
        </DataTemplate>
    </Window.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Search Header -->
        <Border Grid.Row="0" 
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Padding="16">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <ui:SymbolIcon Grid.Column="0" 
                               Symbol="Find" 
                               Margin="0,0,12,0"
                               VerticalAlignment="Center"/>

                <ui:AutoSuggestBox Grid.Column="1"
                                   x:Name="SearchBox"
                                   PlaceholderText="Search by tag, name, module, or description..."
                                   Text="{Binding SearchText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                                   QueryIcon="Find"
                                   KeyDown="SearchBox_KeyDown"/>

                <TextBlock Grid.Column="2"
                           VerticalAlignment="Center"
                           Margin="16,0,0,0"
                           Opacity="0.6">
                    <Run Text="DICOM Standard PS3.6"/>
                </TextBlock>
            </Grid>
        </Border>

        <!-- Column Headers -->
        <Border Grid.Row="1"
                VerticalAlignment="Top"
                Background="{DynamicResource SystemControlBackgroundListLowBrush}"
                BorderBrush="{DynamicResource SystemControlForegroundBaseLowBrush}"
                BorderThickness="0,0,0,1"
                Padding="8,4"
                Margin="0,0,0,0"
                Panel.ZIndex="1">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="140"/>
                    <ColumnDefinition Width="300"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <TextBlock Grid.Column="0" Text="Tag" FontWeight="SemiBold" Margin="20,0,0,0"/>
                <TextBlock Grid.Column="1" Text="Attribute Name" FontWeight="SemiBold" Margin="8,0,0,0"/>
                <TextBlock Grid.Column="2" Text="Description / Examples" FontWeight="SemiBold" Margin="8,0,0,0"/>
            </Grid>
        </Border>

        <!-- Tags List -->
        <ListView Grid.Row="1"
                  x:Name="TagsListView"
                  ItemsSource="{Binding TagsView}"
                  ItemTemplate="{StaticResource TagItemTemplate}"
                  SelectionMode="Single"
                  ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                  MouseDoubleClick="TagsListView_MouseDoubleClick"
                  Margin="0,30,0,0">
            <ListView.GroupStyle>
                <GroupStyle ContainerStyle="{StaticResource GroupHeaderStyle}"/>
            </ListView.GroupStyle>
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem" BasedOn="{StaticResource DefaultListViewItemStyle}">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                    <Setter Property="Padding" Value="0"/>
                </Style>
            </ListView.ItemContainerStyle>
        </ListView>

        <!-- Dialog Buttons -->
        <Border Grid.Row="2" 
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Padding="16">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <!-- Info Text -->
                <StackPanel Grid.Column="0" 
                            Orientation="Horizontal"
                            VerticalAlignment="Center">
                    <TextBlock Foreground="{DynamicResource SystemControlForegroundBaseMediumBrush}">
                        <Run Text="Selected: "/>
                    </TextBlock>
                    <TextBlock Text="{Binding ElementName=TagsListView, Path=SelectedItem.TagString}" 
                               FontFamily="Consolas"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                    <TextBlock Text="{Binding ElementName=TagsListView, Path=SelectedItem.Name}" 
                               Margin="8,0,0,0"/>
                </StackPanel>

                <!-- Buttons -->
                <Button Grid.Column="1" 
                        x:Name="OkButton"
                        Content="Select"
                        IsDefault="True"
                        Margin="0,0,8,0"
                        MinWidth="100"
                        Click="OkButton_Click"
                        Style="{StaticResource AccentButtonStyle}"/>

                <Button Grid.Column="2" 
                        x:Name="CancelButton"
                        Content="Cancel"
                        IsCancel="True"
                        MinWidth="100"
                        Click="CancelButton_Click"/>
            </Grid>
        </Border>
    </Grid>
</Window>


================================================================================
FILE: Dialogs/DicomTagBrowserDialog.xaml.cs
--------------------------------------------------------------------------------
Size: 13,35 KB | Lines: 313 | Modified: 2025-06-23 11:53:04
================================================================================

// src/CamBridge.Config/Dialogs/DicomTagBrowserDialog.xaml.cs
// Version: 0.7.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Enhanced with NEMA-compliant descriptions

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using ModernWpf.Controls;
// Use alias to avoid conflicts
using CoreDicomTag = CamBridge.Core.ValueObjects.DicomTag;

namespace CamBridge.Config.Dialogs
{
    /// <summary>
    /// Dialog for browsing and selecting DICOM tags with search functionality
    /// </summary>
    [SupportedOSPlatform("windows")]
    public partial class DicomTagBrowserDialog : Window, INotifyPropertyChanged
    {
        #region Properties

        private string? _searchText;
        public string? SearchText
        {
            get => _searchText;
            set
            {
                if (_searchText != value)
                {
                    _searchText = value;
                    OnPropertyChanged();
                    UpdateFilter();
                }
            }
        }

        public CoreDicomTag? SelectedTag { get; private set; }

        private CollectionViewSource _tagsViewSource = null!;
        public ICollectionView TagsView => _tagsViewSource.View;

        private List<DicomTagInfo> _allTags = null!;

        #endregion

        public DicomTagBrowserDialog()
        {
            InitializeComponent();
            DataContext = this;

            // Initialize collections before use
            _allTags = new List<DicomTagInfo>();
            _tagsViewSource = new CollectionViewSource();

            LoadDicomTags();
            SearchBox.Focus();
        }

        #region Initialization

        private void LoadDicomTags()
        {
            // Clear and reinitialize
            _allTags.Clear();

            // Patient Module - NEMA PS3.3 Table C.7-1
            AddTag("Patient", CoreDicomTag.PatientModule.PatientName, "Patient's Name", "PN",
                "Primary identifier - Format: Family^Given^Middle^Prefix^Suffix");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientID, "Patient ID", "LO",
                "Primary hospital/institution identification number");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientBirthDate, "Patient's Birth Date", "DA",
                "Format: YYYYMMDD (e.g., 19850315 for March 15, 1985)");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientSex, "Patient's Sex", "CS",
                "M=Male, F=Female, O=Other (fixed enumeration)");
            AddTag("Patient", CoreDicomTag.PatientModule.OtherPatientIDs, "Other Patient IDs", "LO",
                "Additional identifiers from other systems");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientComments, "Patient Comments", "LT",
                "Additional information about the patient");

            // Study Module - NEMA PS3.3 Table C.7-3
            AddTag("Study", CoreDicomTag.StudyModule.StudyInstanceUID, "Study Instance UID", "UI",
                "Unique identifier for the study - automatically generated");
            AddTag("Study", CoreDicomTag.StudyModule.StudyDate, "Study Date", "DA",
                "Date the study started - Format: YYYYMMDD");
            AddTag("Study", CoreDicomTag.StudyModule.StudyTime, "Study Time", "TM",
                "Time the study started - Format: HHMMSS.FFFFFF");
            AddTag("Study", CoreDicomTag.StudyModule.StudyID, "Study ID", "SH",
                "Institution-generated study identifier");
            AddTag("Study", CoreDicomTag.StudyModule.AccessionNumber, "Accession Number", "SH",
                "RIS/HIS generated number that identifies the order");
            AddTag("Study", CoreDicomTag.StudyModule.StudyDescription, "Study Description", "LO",
                "Institution-generated description or classification of the study");
            AddTag("Study", CoreDicomTag.StudyModule.ReferringPhysicianName, "Referring Physician's Name", "PN",
                "Name of the physician who requested the study");

            // Series Module - NEMA PS3.3 Table C.7-5a
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesInstanceUID, "Series Instance UID", "UI",
                "Unique identifier for the series - automatically generated");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesNumber, "Series Number", "IS",
                "A number that identifies this series (e.g., 1, 2, 3...)");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesDate, "Series Date", "DA",
                "Date the series started");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesTime, "Series Time", "TM",
                "Time the series started");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesDescription, "Series Description", "LO",
                "Description of the series (e.g., 'Chest PA', 'Lateral View')");
            AddTag("Series", CoreDicomTag.SeriesModule.Modality, "Modality", "CS",
                "Type of equipment (e.g., XA=X-Ray Angiography, OT=Other)");

            // General Image Module - NEMA PS3.3 Table C.7-9
            AddTag("Image", CoreDicomTag.InstanceModule.SOPInstanceUID, "SOP Instance UID", "UI",
                "Unique identifier for this image - automatically generated");
            AddTag("Image", CoreDicomTag.InstanceModule.InstanceNumber, "Instance Number", "IS",
                "A number that identifies this image (1, 2, 3...)");
            AddTag("Image", CoreDicomTag.InstanceModule.ContentDate, "Content Date", "DA",
                "The date the image pixel data creation started");
            AddTag("Image", CoreDicomTag.InstanceModule.ContentTime, "Content Time", "TM",
                "The time the image pixel data creation started");
            AddTag("Image", CoreDicomTag.InstanceModule.AcquisitionDateTime, "Acquisition DateTime", "DT",
                "Date and time the acquisition started - Format: YYYYMMDDHHMMSS.FFFFFF");

            // General Equipment Module - NEMA PS3.3 Table C.7-8
            AddTag("Equipment", CoreDicomTag.EquipmentModule.Manufacturer, "Manufacturer", "LO",
                "Manufacturer of the equipment (e.g., 'RICOH')");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.InstitutionName, "Institution Name", "LO",
                "Institution where the equipment is located");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.StationName, "Station Name", "SH",
                "User-defined name identifying the machine");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.ManufacturerModelName, "Manufacturer's Model Name", "LO",
                "Manufacturer's model name (e.g., 'G900 II')");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.SoftwareVersions, "Software Versions", "LO",
                "Manufacturer's software version (e.g., 'CamBridge 0.7.25')");

            // Additional commonly used tags
            AddTag("General", new CoreDicomTag(0x0008, 0x0005), "Specific Character Set", "CS",
                "Character encoding (e.g., 'ISO_IR 100' for Latin-1)");
            AddTag("General", new CoreDicomTag(0x0008, 0x0016), "SOP Class UID", "UI",
                "Identifies the DICOM IOD (e.g., Secondary Capture)");
            AddTag("General", new CoreDicomTag(0x0008, 0x0064), "Conversion Type", "CS",
                "Describes the conversion (e.g., 'WSD' = Workstation)");
            AddTag("General", new CoreDicomTag(0x0020, 0x0013), "Instance Number", "IS",
                "Number that identifies this instance");
            AddTag("General", new CoreDicomTag(0x0028, 0x0002), "Samples per Pixel", "US",
                "Number of samples per pixel (1=grayscale, 3=color)");
            AddTag("General", new CoreDicomTag(0x0028, 0x0004), "Photometric Interpretation", "CS",
                "Color space (e.g., 'RGB', 'YBR_FULL_422')");

            // Setup CollectionViewSource with grouping
            _tagsViewSource = new CollectionViewSource { Source = _allTags };
            _tagsViewSource.GroupDescriptions.Add(new PropertyGroupDescription("Module"));
            _tagsViewSource.SortDescriptions.Add(new SortDescription("Module", ListSortDirection.Ascending));
            _tagsViewSource.SortDescriptions.Add(new SortDescription("TagString", ListSortDirection.Ascending));

            // Notify UI
            OnPropertyChanged(nameof(TagsView));
        }

        private void AddTag(string module, CoreDicomTag tag, string name, string vr, string description)
        {
            _allTags.Add(new DicomTagInfo
            {
                Module = module,
                Tag = tag,
                Name = name,
                VR = vr,
                VRDescription = GetVRDescription(vr),
                TagString = tag.ToString(),
                Description = description,
                DisplayText = $"{tag} - {name} ({vr})"
            });
        }

        private string GetVRDescription(string vr)
        {
            return vr switch
            {
                "CS" => "Code String - max 16 chars",
                "DA" => "Date - YYYYMMDD",
                "DT" => "DateTime - YYYYMMDDHHMMSS.FFFFFF",
                "IS" => "Integer String - max 12 chars",
                "LO" => "Long String - max 64 chars",
                "LT" => "Long Text - max 10240 chars",
                "PN" => "Person Name - 5 components with ^",
                "SH" => "Short String - max 16 chars",
                "TM" => "Time - HHMMSS.FFFFFF",
                "UI" => "Unique Identifier - max 64 chars",
                "US" => "Unsigned Short - 2 bytes",
                _ => vr
            };
        }

        #endregion

        #region Search and Filter

        private void UpdateFilter()
        {
            if (TagsView == null) return;

            if (string.IsNullOrWhiteSpace(SearchText))
            {
                TagsView.Filter = null;
            }
            else
            {
                TagsView.Filter = obj =>
                {
                    if (obj is DicomTagInfo tagInfo)
                    {
                        var searchLower = SearchText.ToLower();
                        return tagInfo.Name.ToLower().Contains(searchLower) ||
                               tagInfo.TagString.Contains(searchLower) ||
                               tagInfo.Module.ToLower().Contains(searchLower) ||
                               tagInfo.VR.ToLower().Contains(searchLower) ||
                               tagInfo.Description.ToLower().Contains(searchLower);
                    }
                    return false;
                };
            }

            // Select first item if any
            TagsView.MoveCurrentToFirst();
        }

        #endregion

        #region Event Handlers

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            if (TagsListView.SelectedItem is DicomTagInfo tagInfo)
            {
                SelectedTag = tagInfo.Tag;
                DialogResult = true;
            }
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        private void TagsListView_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (TagsListView.SelectedItem != null)
            {
                OkButton_Click(sender, e);
            }
        }

        private void SearchBox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Down && TagsListView.Items.Count > 0)
            {
                TagsListView.Focus();
                TagsListView.SelectedIndex = 0;
            }
        }

        private void Window_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Escape)
            {
                DialogResult = false;
            }
            else if (e.Key == Key.Enter && TagsListView.SelectedItem != null)
            {
                OkButton_Click(sender, e);
            }
        }

        #endregion

        #region INotifyPropertyChanged

        public event PropertyChangedEventHandler? PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion

        #region Inner Classes

        /// <summary>
        /// DICOM tag information for display
        /// </summary>
        public class DicomTagInfo
        {
            public string Module { get; set; } = string.Empty;
            public CoreDicomTag Tag { get; set; } = null!;
            public string Name { get; set; } = string.Empty;
            public string VR { get; set; } = string.Empty;
            public string VRDescription { get; set; } = string.Empty;
            public string TagString { get; set; } = string.Empty;
            public string Description { get; set; } = string.Empty;
            public string DisplayText { get; set; } = string.Empty;
        }

        #endregion
    }
}


================================================================================
FILE: Dialogs/TransformEditorDialog.xaml
--------------------------------------------------------------------------------
Size: 10,90 KB | Lines: 242 | Modified: 2025-06-18 14:35:08
================================================================================

<ui:ContentDialog x:Class="CamBridge.Config.Dialogs.TransformEditorDialog"
                   xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                   xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                   xmlns:ui="http://schemas.modernwpf.com/2019"
                   xmlns:converters="clr-namespace:CamBridge.Config.Converters"
                   Title="Edit Transformation"
                   PrimaryButtonText="OK"
                   SecondaryButtonText="Cancel"
                   DefaultButton="Primary"
                   Width="600">

    <ui:ContentDialog.Resources>
        <converters:TransformToDescriptionConverter x:Key="TransformToDescriptionConverter"/>
        <converters:TransformToSymbolConverter x:Key="TransformToSymbolConverter"/>
        <BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
    </ui:ContentDialog.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Current Mapping Info -->
        <Border Grid.Row="0" 
                Background="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"
                Padding="12"
                CornerRadius="4"
                Margin="0,0,0,16">
            <StackPanel>
                <TextBlock>
                    <Run Text="{Binding SourceField}" FontWeight="SemiBold"/>
                    <Run Text=" â†’ "/>
                    <Run Text="{Binding DicomTag}" Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                </TextBlock>
                <TextBlock Text="{Binding DicomTagName}" 
                           Opacity="0.7" 
                           FontSize="12"
                           Margin="0,2,0,0"/>
            </StackPanel>
        </Border>

        <!-- Transform Selection -->
        <TextBlock Grid.Row="1" 
                   Text="Select Transformation:"
                   FontWeight="SemiBold"
                   Margin="0,0,0,8"/>

        <ComboBox Grid.Row="2" 
                  ItemsSource="{Binding AvailableTransforms}"
                  SelectedItem="{Binding SelectedTransform}"
                  Margin="0,0,0,16">
            <ComboBox.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="30"/>
                            <ColumnDefinition Width="120"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>

                        <TextBlock Grid.Column="0"
                                   Text="{Binding Converter={StaticResource TransformToSymbolConverter}}"
                                   FontSize="14"/>

                        <TextBlock Grid.Column="1"
                                   Text="{Binding}"
                                   FontWeight="SemiBold"
                                   Margin="8,0,0,0"/>

                        <TextBlock Grid.Column="2"
                                   Text="{Binding Converter={StaticResource TransformToDescriptionConverter}}"
                                   Opacity="0.7"
                                   TextWrapping="Wrap"
                                   Margin="8,0,0,0"/>
                    </Grid>
                </DataTemplate>
            </ComboBox.ItemTemplate>
        </ComboBox>

        <!-- Preview Section -->
        <Border Grid.Row="3"
                BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                BorderThickness="1"
                CornerRadius="4"
                Padding="12"
                Margin="0,0,0,16"
                Visibility="{Binding ShowPreview, Converter={StaticResource BoolToVisibility}}">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Text="Preview:"
                               FontWeight="SemiBold"
                               Margin="0,0,0,8"/>

                    <!-- View Mode Selector -->
                    <StackPanel Grid.Column="1" 
                                Orientation="Horizontal"
                                Margin="0,0,0,8">
                        <RadioButton Content="Normal" 
                                     IsChecked="{Binding ShowNormalView}"
                                     Margin="0,0,8,0"/>
                        <RadioButton Content="Special Chars" 
                                     IsChecked="{Binding ShowSpecialCharsView}"
                                     Margin="0,0,8,0"/>
                        <RadioButton Content="HEX" 
                                     IsChecked="{Binding ShowHexView}"/>
                    </StackPanel>
                </Grid>

                <!-- Input Section -->
                <Grid Grid.Row="1">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Text="Test input:"
                               VerticalAlignment="Center"
                               Margin="0,0,8,0"/>

                    <TextBox Grid.Column="1"
                             Text="{Binding PreviewInput, UpdateSourceTrigger=PropertyChanged}"
                             ui:ControlHelper.PlaceholderText="Enter test value..."
                             FontFamily="Consolas"/>

                    <TextBlock Grid.Column="2"
                               Text="{Binding InputEncoding}"
                               FontSize="11"
                               Opacity="0.6"
                               VerticalAlignment="Center"
                               Margin="8,0,0,0"/>
                </Grid>

                <!-- Output Section -->
                <Grid Grid.Row="2" Margin="0,8,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Text="Result:"
                               VerticalAlignment="Center"
                               Margin="0,0,8,0"/>

                    <!-- Normal View -->
                    <TextBlock Grid.Column="1"
                               Text="{Binding PreviewOutput}"
                               FontFamily="Consolas"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"
                               Visibility="{Binding ShowNormalView, Converter={StaticResource BoolToVisibility}}"/>

                    <!-- Special Chars View -->
                    <TextBlock Grid.Column="1"
                               Text="{Binding PreviewOutputSpecialChars}"
                               FontFamily="Consolas"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"
                               Visibility="{Binding ShowSpecialCharsView, Converter={StaticResource BoolToVisibility}}"/>

                    <!-- HEX View -->
                    <ScrollViewer Grid.Column="1"
                                  HorizontalScrollBarVisibility="Auto"
                                  VerticalScrollBarVisibility="Disabled"
                                  MaxHeight="60"
                                  Visibility="{Binding ShowHexView, Converter={StaticResource BoolToVisibility}}">
                        <TextBlock Text="{Binding PreviewOutputHex}"
                                   FontFamily="Consolas"
                                   FontSize="12"
                                   FontWeight="SemiBold"
                                   Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                    </ScrollViewer>

                    <TextBlock Grid.Column="2"
                               Text="{Binding OutputEncoding}"
                               FontSize="11"
                               Opacity="0.6"
                               VerticalAlignment="Center"
                               Margin="8,0,0,0"/>
                </Grid>

                <!-- Encoding Warning -->
                <Border Grid.Row="3"
                        Background="Orange"
                        CornerRadius="4"
                        Padding="8,4"
                        Margin="0,8,0,0"
                        Visibility="{Binding ShowEncodingWarning, Converter={StaticResource BoolToVisibility}}">
                    <TextBlock Text="{Binding EncodingWarning}"
                               Foreground="White"
                               FontSize="12"
                               TextWrapping="Wrap"/>
                </Border>
            </Grid>
        </Border>

        <!-- DICOM Compliance Info -->
        <Border Grid.Row="4"
                Background="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"
                Padding="8"
                CornerRadius="4"
                Margin="0,0,0,12"
                Visibility="{Binding ShowDicomInfo, Converter={StaticResource BoolToVisibility}}">
            <StackPanel>
                <TextBlock Text="DICOM Information:" 
                           FontWeight="SemiBold"
                           FontSize="12"
                           Margin="0,0,0,4"/>
                <TextBlock Text="{Binding DicomInfo}"
                           FontSize="11"
                           Opacity="0.8"
                           TextWrapping="Wrap"/>
            </StackPanel>
        </Border>

        <!-- Description -->
        <TextBlock Grid.Row="5"
                   Text="{Binding SelectedTransform, Converter={StaticResource TransformToDescriptionConverter}}"
                   TextWrapping="Wrap"
                   Opacity="0.7"
                   FontSize="12"/>
    </Grid>
</ui:ContentDialog>


================================================================================
FILE: Dialogs/TransformEditorDialog.xaml.cs
--------------------------------------------------------------------------------
Size: 16,25 KB | Lines: 524 | Modified: 2025-06-23 11:53:04
================================================================================

// src/CamBridge.Config/Dialogs/TransformEditorDialog.xaml.cs
// Version: 0.7.26
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.ValueObjects;
using ModernWpf.Controls;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace CamBridge.Config.Dialogs
{
    /// <summary>
    /// Enhanced dialog for editing mapping rule transformations with encoding preview
    /// </summary>
    public partial class TransformEditorDialog : ContentDialog, INotifyPropertyChanged
    {
        private ValueTransform _selectedTransform;
        private string _sourceField = "";
        private string _dicomTag = "";
        private string _dicomTagName = "";
        private string _previewInput = "";
        private string _previewOutput = "";
        private string _previewOutputSpecialChars = "";
        private string _previewOutputHex = "";
        private bool _showPreview = true;
        private bool _showNormalView = true;
        private bool _showSpecialCharsView = false;
        private bool _showHexView = false;
        private string _inputEncoding = "UTF-8";
        private string _outputEncoding = "ISO_IR 100";
        private bool _showEncodingWarning = false;
        private string _encodingWarning = "";
        private bool _showDicomInfo = false;
        private string _dicomInfo = "";

        public TransformEditorDialog()
        {
            InitializeComponent();
            DataContext = this;
            InitializeTransforms();
        }

        #region Properties

        public ObservableCollection<ValueTransform> AvailableTransforms { get; } = new();

        public ValueTransform SelectedTransform
        {
            get => _selectedTransform;
            set
            {
                if (_selectedTransform != value)
                {
                    _selectedTransform = value;
                    OnPropertyChanged();

                    // Update preview input based on new transform
                    UpdatePreviewInputForTransform();

                    UpdatePreview();
                    UpdateShowPreview();
                    UpdateDicomInfo();
                }
            }
        }

        public string SourceField
        {
            get => _sourceField;
            set
            {
                _sourceField = value;
                OnPropertyChanged();
            }
        }

        public string DicomTag
        {
            get => _dicomTag;
            set
            {
                _dicomTag = value;
                OnPropertyChanged();
                UpdateDicomInfo();
            }
        }

        public string DicomTagName
        {
            get => _dicomTagName;
            set
            {
                _dicomTagName = value;
                OnPropertyChanged();
            }
        }

        public string PreviewInput
        {
            get => _previewInput;
            set
            {
                _previewInput = value;
                OnPropertyChanged();
                DetectInputEncoding();
                UpdatePreview();
            }
        }

        public string PreviewOutput
        {
            get => _previewOutput;
            set
            {
                _previewOutput = value;
                OnPropertyChanged();
            }
        }

        public string PreviewOutputSpecialChars
        {
            get => _previewOutputSpecialChars;
            set
            {
                _previewOutputSpecialChars = value;
                OnPropertyChanged();
            }
        }

        public string PreviewOutputHex
        {
            get => _previewOutputHex;
            set
            {
                _previewOutputHex = value;
                OnPropertyChanged();
            }
        }

        public bool ShowPreview
        {
            get => _showPreview;
            set
            {
                _showPreview = value;
                OnPropertyChanged();
            }
        }

        public bool ShowNormalView
        {
            get => _showNormalView;
            set
            {
                _showNormalView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowSpecialCharsView = false;
                    ShowHexView = false;
                }
            }
        }

        public bool ShowSpecialCharsView
        {
            get => _showSpecialCharsView;
            set
            {
                _showSpecialCharsView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowNormalView = false;
                    ShowHexView = false;
                }
            }
        }

        public bool ShowHexView
        {
            get => _showHexView;
            set
            {
                _showHexView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowNormalView = false;
                    ShowSpecialCharsView = false;
                }
            }
        }

        public string InputEncoding
        {
            get => _inputEncoding;
            set
            {
                _inputEncoding = value;
                OnPropertyChanged();
            }
        }

        public string OutputEncoding
        {
            get => _outputEncoding;
            set
            {
                _outputEncoding = value;
                OnPropertyChanged();
            }
        }

        public bool ShowEncodingWarning
        {
            get => _showEncodingWarning;
            set
            {
                _showEncodingWarning = value;
                OnPropertyChanged();
            }
        }

        public string EncodingWarning
        {
            get => _encodingWarning;
            set
            {
                _encodingWarning = value;
                OnPropertyChanged();
            }
        }

        public bool ShowDicomInfo
        {
            get => _showDicomInfo;
            set
            {
                _showDicomInfo = value;
                OnPropertyChanged();
            }
        }

        public string DicomInfo
        {
            get => _dicomInfo;
            set
            {
                _dicomInfo = value;
                OnPropertyChanged();
            }
        }

        #endregion

        #region Methods

        private void UpdatePreviewInputForTransform()
        {
            // Update preview input when transform changes to provide appropriate test data
            PreviewInput = SelectedTransform switch
            {
                ValueTransform.DateToDicom => "1985-03-15",
                ValueTransform.ExtractDate => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.ExtractTime => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.DateTimeToDicom => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.TimeToDicom => "14:30:45",
                ValueTransform.MapGender => "M",
                ValueTransform.ToUpperCase => "test text",
                ValueTransform.ToLowerCase => "TEST TEXT",
                ValueTransform.Trim => "  trimmed text  ",
                ValueTransform.RemovePrefix => "PREFIX_Value",
                ValueTransform.None => SourceField switch
                {
                    "birthdate" => "1985-03-15",
                    "gender" => "M",
                    "DateTimeOriginal" => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                    "name" => "Schmidt, Maria",
                    "examid" => "EX002",
                    "comment" => "RÃ¶ntgen Thorax",
                    _ => "Sample Text"
                },
                _ => PreviewInput // Keep existing input
            };
        }

        private void InitializeTransforms()
        {
            // Add all available transforms
            foreach (ValueTransform transform in Enum.GetValues(typeof(ValueTransform)))
            {
                AvailableTransforms.Add(transform);
            }
        }

        private void DetectInputEncoding()
        {
            if (string.IsNullOrEmpty(PreviewInput))
            {
                InputEncoding = "UTF-8";
                return;
            }

            // Check for common encoding indicators
            bool hasUmlauts = PreviewInput.Any(c => "Ã¤Ã¶Ã¼Ã„Ã–ÃœÃŸ".Contains(c));
            bool hasExtendedAscii = PreviewInput.Any(c => c > 127);

            if (hasExtendedAscii && !hasUmlauts)
            {
                InputEncoding = "Windows-1252";
            }
            else if (hasUmlauts)
            {
                InputEncoding = "UTF-8";
            }
            else
            {
                InputEncoding = "ASCII";
            }
        }

        private void UpdatePreview()
        {
            if (string.IsNullOrEmpty(PreviewInput))
            {
                PreviewOutput = "";
                PreviewOutputSpecialChars = "";
                PreviewOutputHex = "";
                ShowEncodingWarning = false;
                return;
            }

            try
            {
                // Create a temporary rule to apply the transform
                var tempRule = new MappingRule
                {
                    Transform = SelectedTransform.ToString()
                };

                PreviewOutput = tempRule.ApplyTransform(PreviewInput) ?? "";

                // Create special chars view
                PreviewOutputSpecialChars = CreateSpecialCharsView(PreviewOutput);

                // Create hex view
                PreviewOutputHex = CreateHexView(PreviewOutput);

                // Check for encoding issues
                CheckEncodingIssues();
            }
            catch (Exception ex)
            {
                PreviewOutput = $"Error: {ex.Message}";
                PreviewOutputSpecialChars = PreviewOutput;
                PreviewOutputHex = "";
            }
        }

        private string CreateSpecialCharsView(string input)
        {
            if (string.IsNullOrEmpty(input)) return "";

            return input
                .Replace("\r", "[CR]")
                .Replace("\n", "[LF]")
                .Replace("\t", "[TAB]")
                .Replace("\0", "[NULL]")
                .Replace("\x1B", "[ESC]");
        }

        private string CreateHexView(string input)
        {
            if (string.IsNullOrEmpty(input)) return "";

            var sb = new StringBuilder();
            var bytes = Encoding.UTF8.GetBytes(input);

            for (int i = 0; i < bytes.Length; i++)
            {
                if (i > 0 && i % 16 == 0)
                {
                    sb.AppendLine();
                }
                else if (i > 0)
                {
                    sb.Append(" ");
                }

                sb.AppendFormat("{0:X2}", bytes[i]);
            }

            return sb.ToString();
        }

        private void CheckEncodingIssues()
        {
            ShowEncodingWarning = false;

            // Check for problematic characters
            if (PreviewOutput.Contains('?') && !PreviewInput.Contains('?'))
            {
                ShowEncodingWarning = true;
                EncodingWarning = "âš  Character encoding issue detected - some characters may be lost in DICOM conversion";
            }
            else if (PreviewOutput.Any(c => c > 255))
            {
                ShowEncodingWarning = true;
                EncodingWarning = "âš  Output contains Unicode characters that may not be supported in DICOM ISO_IR 100";
            }
        }

        private void UpdateShowPreview()
        {
            // Hide preview for certain transforms that don't need it
            ShowPreview = SelectedTransform != ValueTransform.None;
        }

        private void UpdateDicomInfo()
        {
            ShowDicomInfo = false;

            // Show DICOM-specific info for certain tags/transforms
            if (DicomTag == "(0010,0010)" && SelectedTransform == ValueTransform.None)
            {
                ShowDicomInfo = true;
                DicomInfo = "Patient Name: Max 64 chars, format: Last^First^Middle^Prefix^Suffix";
            }
            else if (DicomTag == "(0010,0030)" && SelectedTransform == ValueTransform.DateToDicom)
            {
                ShowDicomInfo = true;
                DicomInfo = "Birth Date: DICOM format YYYYMMDD, no separators";
            }
            else if (DicomTag == "(0010,0040)" && SelectedTransform == ValueTransform.MapGender)
            {
                ShowDicomInfo = true;
                DicomInfo = "Patient Sex: Valid values are M, F, O (Other)";
            }
        }

        public void SetMapping(string sourceField, string dicomTag, ValueTransform currentTransform)
        {
            SourceField = sourceField;
            DicomTag = dicomTag;
            SelectedTransform = currentTransform;

            // Look up DICOM tag name
            DicomTagName = GetDicomTagNameByString(dicomTag);

            // Set appropriate preview input based on transform type
            PreviewInput = currentTransform switch
            {
                ValueTransform.DateToDicom => "1985-03-15",
                ValueTransform.ExtractDate => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.ExtractTime => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.DateTimeToDicom => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.TimeToDicom => "14:30:45",
                ValueTransform.MapGender => "M",
                ValueTransform.ToUpperCase => "test text",
                ValueTransform.ToLowerCase => "TEST TEXT",
                ValueTransform.Trim => "  trimmed text  ",
                ValueTransform.RemovePrefix => "PREFIX_Value",
                _ => sourceField switch
                {
                    "birthdate" => "1985-03-15",
                    "gender" => "M",
                    "DateTimeOriginal" => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                    "name" => "Schmidt, Maria",
                    "examid" => "EX002",
                    "comment" => "RÃ¶ntgen Thorax\r\nAP-Aufnahme",
                    _ => "Sample Text"
                }
            };
        }

        private string GetDicomTagNameByString(string tagString)
        {
            // Direct tag name lookup by string
            return tagString switch
            {
                "(0010,0010)" => "Patient's Name",
                "(0010,0020)" => "Patient ID",
                "(0010,0030)" => "Patient's Birth Date",
                "(0010,0040)" => "Patient's Sex",
                "(0020,0010)" => "Study ID",
                "(0008,1030)" => "Study Description",
                "(0008,0020)" => "Study Date",
                "(0008,0030)" => "Study Time",
                "(0008,0070)" => "Manufacturer",
                "(0008,1090)" => "Manufacturer's Model Name",
                "(0018,1020)" => "Software Versions",
                "(0008,002A)" => "Acquisition DateTime",
                "(0010,4000)" => "Patient Comments",
                "(0008,0050)" => "Accession Number",
                _ => "Custom Tag"
            };
        }

        private string GetDicomTagName(Core.ValueObjects.DicomTag tag)
        {
            return GetDicomTagNameByString(tag.ToString());
        }

        #endregion

        #region INotifyPropertyChanged

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion
    }
}


================================================================================
FILE: Extensions/MappingConfigurationExtensions.cs
--------------------------------------------------------------------------------
Size: 1,45 KB | Lines: 43 | Modified: 2025-06-23 11:53:04
================================================================================

// File: src/CamBridge.Config/Extensions/MappingConfigurationExtensions.cs
// Version: 0.5.24
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-04
// Status: Development/Local

using System.Threading.Tasks;
using CamBridge.Core.Interfaces;
using CamBridge.Infrastructure.Services;

namespace CamBridge.Config.Extensions
{
    /// <summary>
    /// Extension methods for MappingConfigurationLoader to provide UI-expected methods
    /// </summary>
    public static class MappingConfigurationExtensions
    {
        /// <summary>
        /// Load configuration from file (UI-expected method name)
        /// </summary>
        public static async Task<IMappingConfiguration> LoadFromFileAsync(
            this MappingConfigurationLoader loader,
            string filePath)
        {
            await loader.LoadConfigurationAsync(filePath);
            return loader;
        }

        /// <summary>
        /// Save configuration to file (UI-expected method name)
        /// </summary>
        public static async Task SaveToFileAsync(
            this MappingConfigurationLoader loader,
            IMappingConfiguration config,
            string filePath)
        {
            // The loader itself implements IMappingConfiguration
            // So we just save its current rules
            await loader.SaveConfigurationAsync(loader.GetMappingRules(), filePath);
        }
    }
}


================================================================================
FILE: Extensions/MappingRuleExtensions.cs
--------------------------------------------------------------------------------
Size: 2,91 KB | Lines: 75 | Modified: 2025-06-23 11:53:04
================================================================================

// File: src/CamBridge.Config/Extensions/MappingRuleExtensions.cs
// Version: 0.6.2
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-07
// Status: Development/Local

using System;
using CamBridge.Core;

namespace CamBridge.Config.Extensions
{
    /// <summary>
    /// Extension methods for MappingRule to support UI-specific functionality
    /// </summary>
    public static class MappingRuleExtensions
    {
        // HINWEIS: Die ApplyTransform Methode ist jetzt direkt in MappingRule.cs implementiert!
        // Diese Klasse kÃ¶nnte gelÃ¶scht werden, oder wir behalten sie fÃ¼r andere UI-spezifische Extensions

        /// <summary>
        /// Gets a display-friendly description of the transform
        /// </summary>
        public static string GetTransformDescription(this MappingRule rule)
        {
            return rule.TransformEnum switch
            {
                ValueTransform.None => "No transformation",
                ValueTransform.DateToDicom => "Convert date to DICOM format (YYYYMMDD)",
                ValueTransform.TimeToDicom => "Convert time to DICOM format (HHMMSS)",
                ValueTransform.DateTimeToDicom => "Convert datetime to DICOM format",
                ValueTransform.MapGender => "Map gender to DICOM values (M/F/O)",
                ValueTransform.RemovePrefix => "Remove prefix from value",
                ValueTransform.ExtractDate => "Extract date from datetime",
                ValueTransform.ExtractTime => "Extract time from datetime",
                ValueTransform.ToUpperCase => "Convert to uppercase",
                ValueTransform.ToLowerCase => "Convert to lowercase",
                ValueTransform.Trim => "Remove leading/trailing spaces",
                _ => "Unknown transformation"
            };
        }

        /// <summary>
        /// Validates if the rule is properly configured
        /// </summary>
        public static bool IsValid(this MappingRule rule)
        {
            if (string.IsNullOrWhiteSpace(rule.SourceField))
                return false;

            if (string.IsNullOrWhiteSpace(rule.DicomTag))
                return false;

            // Validate DICOM tag format (XXXX,XXXX)
            if (!System.Text.RegularExpressions.Regex.IsMatch(rule.DicomTag, @"^\([0-9A-Fa-f]{4},[0-9A-Fa-f]{4}\)$"))
                return false;

            return true;
        }

        /// <summary>
        /// Gets a UI-friendly display name for the rule
        /// </summary>
        public static string GetDisplayName(this MappingRule rule)
        {
            if (!string.IsNullOrWhiteSpace(rule.Description))
                return rule.Description;

            if (!string.IsNullOrWhiteSpace(rule.Name))
                return rule.Name;

            return $"{rule.SourceType}.{rule.SourceField} â†’ {rule.DicomTag}";
        }
    }
}


================================================================================
FILE: Helpers/PasswordBoxHelper.cs
--------------------------------------------------------------------------------
Size: 3,49 KB | Lines: 100 | Modified: 2025-06-23 11:53:04
================================================================================

// src\CamBridge.Config\Helpers\PasswordBoxHelper.cs
// Version: 0.5.26
// Helper for binding PasswordBox (which doesn't support direct binding)

using System.Windows;
using System.Windows.Controls;

namespace CamBridge.Config.Helpers
{
    /// <summary>
    /// Helper class to enable binding on PasswordBox
    /// </summary>
    public static class PasswordBoxHelper
    {
        public static readonly DependencyProperty BoundPasswordProperty =
            DependencyProperty.RegisterAttached("BoundPassword", typeof(string), typeof(PasswordBoxHelper),
                new PropertyMetadata(string.Empty, OnBoundPasswordChanged));

        public static readonly DependencyProperty BindPasswordProperty =
            DependencyProperty.RegisterAttached("BindPassword", typeof(bool), typeof(PasswordBoxHelper),
                new PropertyMetadata(false, OnBindPasswordChanged));

        private static readonly DependencyProperty UpdatingPasswordProperty =
            DependencyProperty.RegisterAttached("UpdatingPassword", typeof(bool), typeof(PasswordBoxHelper),
                new PropertyMetadata(false));

        public static void SetBindPassword(DependencyObject dp, bool value)
        {
            dp.SetValue(BindPasswordProperty, value);
        }

        public static bool GetBindPassword(DependencyObject dp)
        {
            return (bool)dp.GetValue(BindPasswordProperty);
        }

        public static string GetBoundPassword(DependencyObject dp)
        {
            return (string)dp.GetValue(BoundPasswordProperty);
        }

        public static void SetBoundPassword(DependencyObject dp, string value)
        {
            dp.SetValue(BoundPasswordProperty, value);
        }

        private static bool GetUpdatingPassword(DependencyObject dp)
        {
            return (bool)dp.GetValue(UpdatingPasswordProperty);
        }

        private static void SetUpdatingPassword(DependencyObject dp, bool value)
        {
            dp.SetValue(UpdatingPasswordProperty, value);
        }

        private static void OnBoundPasswordChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is PasswordBox passwordBox)
            {
                // Disconnect the handler while we're updating
                passwordBox.PasswordChanged -= HandlePasswordChanged;

                if (!GetUpdatingPassword(passwordBox))
                {
                    passwordBox.Password = (string)e.NewValue;
                }

                passwordBox.PasswordChanged += HandlePasswordChanged;
            }
        }

        private static void OnBindPasswordChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e)
        {
            if (dp is PasswordBox passwordBox)
            {
                if ((bool)e.OldValue)
                {
                    passwordBox.PasswordChanged -= HandlePasswordChanged;
                }

                if ((bool)e.NewValue)
                {
                    passwordBox.PasswordChanged += HandlePasswordChanged;
                }
            }
        }

        private static void HandlePasswordChanged(object sender, RoutedEventArgs e)
        {
            if (sender is PasswordBox passwordBox)
            {
                SetUpdatingPassword(passwordBox, true);
                SetBoundPassword(passwordBox, passwordBox.Password);
                SetUpdatingPassword(passwordBox, false);
            }
        }
    }
}


================================================================================
FILE: MainWindow.xaml
--------------------------------------------------------------------------------
Size: 4,47 KB | Lines: 101 | Modified: 2025-06-22 17:51:24
================================================================================

<!-- src\CamBridge.Config\MainWindow.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Main window with perfect edge alignment -->
<Window x:Class="CamBridge.Config.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="http://schemas.modernwpf.com/2019"
        ui:WindowHelper.UseModernWindowStyle="True"
        Title="CamBridge Configuration"
        Height="800" Width="1200"
        MinHeight="600" MinWidth="900"
        WindowStartupLocation="CenterScreen">

    <Window.Resources>
        <!-- Override NavigationView default padding/margin -->
        <Style TargetType="ScrollViewer">
            <Setter Property="Padding" Value="0"/>
        </Style>
    </Window.Resources>

    <Grid>
        <ui:NavigationView x:Name="NavView" 
                          PaneDisplayMode="Left"
                          IsBackButtonVisible="Collapsed"
                          IsSettingsVisible="False"
                          OpenPaneLength="200"
                          CompactModeThresholdWidth="0"
                          ExpandedModeThresholdWidth="200"
                          SelectionChanged="NavigationView_SelectionChanged"
                          IsPaneToggleButtonVisible="False">

            <!-- Override ALL NavigationView margins -->
            <ui:NavigationView.Resources>
                <Thickness x:Key="NavigationViewContentMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewContentPresenterMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewPageContentMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewContentGridMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewTopPaneHeight">0</Thickness>
            </ui:NavigationView.Resources>

            <!-- Menu Items - NEUE REIHENFOLGE! -->
            <ui:NavigationView.MenuItems>
                <!-- 1. Dashboard -->
                <ui:NavigationViewItem Content="Dashboard" Tag="Dashboard">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Home"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 2. Pipeline -->
                <ui:NavigationViewItem Content="Pipeline Config" Tag="PipelineConfig">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Sync"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 3. Mapping -->
                <ui:NavigationViewItem Content="Mapping Editor" Tag="MappingEditor">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Edit"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 4. Error -->
                <ui:NavigationViewItem Content="Error Management" Tag="DeadLetters">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Important"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 5. Log Viewer -->
                <ui:NavigationViewItem Content="Log Viewer" Tag="LogViewer">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Document"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 6. Service -->
                <ui:NavigationViewItem Content="Service Control" Tag="ServiceControl">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Setting"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 7. About -->
                <ui:NavigationViewItem Content="About" Tag="About">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Help"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>
            </ui:NavigationView.MenuItems>

            <!-- Content Frame ohne negativen Margin -->
            <Frame x:Name="ContentFrame" 
                   NavigationUIVisibility="Hidden"
                   JournalOwnership="OwnsJournal"/>

        </ui:NavigationView>
    </Grid>
</Window>


================================================================================
FILE: MainWindow.xaml.cs
--------------------------------------------------------------------------------
Size: 2,72 KB | Lines: 84 | Modified: 2025-06-23 11:53:04
================================================================================

// src\CamBridge.Config\MainWindow.xaml.cs
// Version: 0.7.23
// Description: Main window code-behind with navigation history fix

using System;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using ModernWpf.Controls;
using CamBridge.Config.Services;
using CamBridge.Config.ViewModels;
using CamBridge.Config.Views;

namespace CamBridge.Config
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private readonly INavigationService _navigationService;
        private readonly MainViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();

            // Set version dynamically from assembly
            var version = Assembly.GetExecutingAssembly()
                .GetCustomAttribute<AssemblyInformationalVersionAttribute>()
                ?.InformationalVersion ?? "Unknown";

            Title = $"CamBridge Configuration v{version}";

            // Get services from DI
            var app = (App)App.Current;
            _navigationService = app.Host!.Services.GetRequiredService<INavigationService>();
            _viewModel = app.Host!.Services.GetRequiredService<MainViewModel>();

            DataContext = _viewModel;

            // Initialize navigation
            if (_navigationService is NavigationService navService)
            {
                navService.SetFrame(ContentFrame);
            }

            // Clear navigation journal to prevent history
            ContentFrame.NavigationService.RemoveBackEntry();

            // Navigate to dashboard on startup
            NavView.SelectedItem = NavView.MenuItems[0];
        }

        private void NavigationView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
        {
            if (args.SelectedItem is NavigationViewItem item)
            {
                var tag = item.Tag?.ToString();
                if (!string.IsNullOrEmpty(tag))
                {
                    _navigationService.NavigateTo(tag);

                    // Clear navigation history after each navigation
                    // This prevents the dropdown from appearing
                    while (ContentFrame.NavigationService.CanGoBack)
                    {
                        ContentFrame.NavigationService.RemoveBackEntry();
                    }
                }
            }
        }

        protected override void OnClosed(EventArgs e)
        {
            base.OnClosed(e);

            // Clean shutdown
            Application.Current.Shutdown();
        }
    }
}


================================================================================
FILE: Models/DeadLetterModels.cs
--------------------------------------------------------------------------------
Size: 2,07 KB | Lines: 60 | Modified: 2025-06-23 11:53:04
================================================================================

// src\CamBridge.Config\Models\DeadLetterModels.cs
// Version: 0.7.1
// Description: Dead letter queue models for API communication
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;

namespace CamBridge.Config.Models
{
    /// <summary>
    /// Dead letter item from API
    /// </summary>
    public class DeadLetterItemModel
    {
        public Guid Id { get; set; }
        public string FileName { get; set; } = string.Empty;
        public string FilePath { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public DateTime FailedAt { get; set; }
        public DateTime FirstAttempt { get; set; }
        public DateTime LastAttempt { get; set; }
        public string ErrorMessage { get; set; } = string.Empty;
        public int RetryCount { get; set; }
        public int AttemptCount { get; set; }
        public string OriginalPath { get; set; } = string.Empty;
        public long FileSize { get; set; }
    }

    /// <summary>
    /// Detailed statistics from API
    /// </summary>
    public class DetailedStatisticsModel
    {
        public int TotalProcessed { get; set; }
        public int TotalSuccessful { get; set; }
        public int TotalFailed { get; set; }
        public int TotalQueued { get; set; }
        public double AverageProcessingTimeMs { get; set; }
        public DateTime LastUpdate { get; set; }

        // Per-pipeline statistics
        public Dictionary<string, PipelineStatistics>? PipelineStats { get; set; }
    }

    /// <summary>
    /// Statistics for a single pipeline
    /// </summary>
    public class PipelineStatistics
    {
        public string PipelineId { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public int Processed { get; set; }
        public int Successful { get; set; }
        public int Failed { get; set; }
        public int Queued { get; set; }
        public double SuccessRate { get; set; }
    }
}


================================================================================
FILE: Models/ServiceStatusModel.cs
--------------------------------------------------------------------------------
Size: 6,91 KB | Lines: 232 | Modified: 2025-06-23 11:53:04
================================================================================

// src\CamBridge.Config\Models\ServiceStatusModel.cs
// Version: 0.7.28
// Description: Service status model matching the actual API response
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace CamBridge.Config.Models
{
    /// <summary>
    /// Root response from /api/status endpoint
    /// </summary>
    public class ServiceStatusModel
    {
        // Nested service info
        [JsonPropertyName("service")]
        public ServiceInfo Service { get; set; } = new();

        // Environment info
        [JsonPropertyName("environment")]
        public EnvironmentInfo? Environment { get; set; }

        // Pipeline list
        [JsonPropertyName("pipelines")]
        public List<PipelineStatusData> Pipelines { get; set; } = new();

        // Statistics
        [JsonPropertyName("statistics")]
        public ServiceStatistics? Statistics { get; set; }

        // Configuration
        [JsonPropertyName("configuration")]
        public ServiceConfigurationInfo? Configuration { get; set; }

        // Helper properties for backward compatibility
        [JsonIgnore]
        public string ServiceStatus => Service?.Status ?? "Unknown";

        [JsonIgnore]
        public string Version => Service?.Version ?? "Unknown";

        [JsonIgnore]
        public TimeSpan Uptime => ParseUptime(Service?.Uptime);

        [JsonIgnore]
        public int PipelineCount => Statistics?.TotalPipelines ?? 0;

        [JsonIgnore]
        public int ActivePipelines => Statistics?.ActivePipelines ?? 0;

        [JsonIgnore]
        public int TotalSuccessful => Statistics?.TotalProcessed ?? 0;

        [JsonIgnore]
        public int TotalFailed => Statistics?.TotalErrors ?? 0;

        private static TimeSpan ParseUptime(string? uptimeStr)
        {
            if (string.IsNullOrEmpty(uptimeStr))
                return TimeSpan.Zero;

            // Parse formats like "2m", "1h 5m", "2d 3h 5m"
            var parts = uptimeStr.Split(' ');
            var totalMinutes = 0;

            foreach (var part in parts)
            {
                if (part.EndsWith("d"))
                {
                    if (int.TryParse(part.TrimEnd('d'), out var days))
                        totalMinutes += days * 24 * 60;
                }
                else if (part.EndsWith("h"))
                {
                    if (int.TryParse(part.TrimEnd('h'), out var hours))
                        totalMinutes += hours * 60;
                }
                else if (part.EndsWith("m"))
                {
                    if (int.TryParse(part.TrimEnd('m'), out var minutes))
                        totalMinutes += minutes;
                }
            }

            return TimeSpan.FromMinutes(totalMinutes);
        }
    }

    /// <summary>
    /// Service information
    /// </summary>
    public class ServiceInfo
    {
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        [JsonPropertyName("displayName")]
        public string DisplayName { get; set; } = string.Empty;

        [JsonPropertyName("version")]
        public string Version { get; set; } = "Unknown";

        [JsonPropertyName("status")]
        public string Status { get; set; } = "Unknown";

        [JsonPropertyName("timestamp")]
        public DateTime Timestamp { get; set; }

        [JsonPropertyName("startTime")]
        public DateTime StartTime { get; set; }

        [JsonPropertyName("uptime")]
        public string Uptime { get; set; } = "";

        [JsonPropertyName("processId")]
        public int ProcessId { get; set; }
    }

    /// <summary>
    /// Environment information
    /// </summary>
    public class EnvironmentInfo
    {
        [JsonPropertyName("machineName")]
        public string MachineName { get; set; } = string.Empty;

        [JsonPropertyName("osVersion")]
        public string OsVersion { get; set; } = string.Empty;

        [JsonPropertyName("processorCount")]
        public int ProcessorCount { get; set; }

        [JsonPropertyName("workingSet")]
        public long WorkingSet { get; set; }

        [JsonPropertyName("dotNetVersion")]
        public string DotNetVersion { get; set; } = string.Empty;
    }

    /// <summary>
    /// Service statistics
    /// </summary>
    public class ServiceStatistics
    {
        [JsonPropertyName("totalPipelines")]
        public int TotalPipelines { get; set; }

        [JsonPropertyName("activePipelines")]
        public int ActivePipelines { get; set; }

        [JsonPropertyName("totalProcessed")]
        public int TotalProcessed { get; set; }

        [JsonPropertyName("totalErrors")]
        public int TotalErrors { get; set; }

        [JsonPropertyName("totalQueued")]
        public int TotalQueued { get; set; }
    }

    /// <summary>
    /// Individual pipeline status
    /// </summary>
    public class PipelineStatusData
    {
        [JsonPropertyName("id")]
        public string Id { get; set; } = string.Empty;

        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        [JsonPropertyName("isActive")]
        public bool IsActive { get; set; }

        [JsonPropertyName("queueDepth")]
        public int QueueDepth { get; set; }

        [JsonPropertyName("processedCount")]
        public int ProcessedCount { get; set; }

        [JsonPropertyName("errorCount")]
        public int ErrorCount { get; set; }

        [JsonPropertyName("lastProcessed")]
        public DateTime LastProcessed { get; set; }

        [JsonPropertyName("watchPath")]
        public string WatchPath { get; set; } = string.Empty;

        [JsonPropertyName("outputPath")]
        public string OutputPath { get; set; } = string.Empty;

        // Backward compatibility
        [JsonIgnore]
        public int QueueLength => QueueDepth;

        [JsonIgnore]
        public int TotalProcessed => ProcessedCount;

        [JsonIgnore]
        public int TotalFailed => ErrorCount;

        [JsonIgnore]
        public int TotalSuccessful => ProcessedCount - ErrorCount;

        [JsonIgnore]
        public List<string> WatchedFolders => new() { WatchPath };

        [JsonIgnore]
        public int ActiveProcessing => 0; // Not in new API
    }

    /// <summary>
    /// Service configuration information
    /// </summary>
    public class ServiceConfigurationInfo
    {
        [JsonPropertyName("path")]
        public string? Path { get; set; }

        [JsonPropertyName("logsDirectory")]
        public string? LogsDirectory { get; set; }

        // Legacy properties
        public string? DefaultOutputFolder { get; set; }
        public string? ExifToolPath { get; set; }
        public string? Version { get; set; }
    }
}


================================================================================
FILE: obj/x64/Release/net8.0-windows/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
--------------------------------------------------------------------------------
Size: 198 bytes | Lines: 5 | Modified: 2025-06-23 19:50:05
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: obj/x64/Release/net8.0-windows/CamBridge.Config.AssemblyInfo.cs
--------------------------------------------------------------------------------
Size: 1,58 KB | Lines: 29 | Modified: 2025-06-23 19:50:05
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.0+a2bed238060f0dad03d59d67aabd71062e685301")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Config")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.0.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows7.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows7.0")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: Properties/launchSettings.json
--------------------------------------------------------------------------------
Size: 182 bytes | Lines: 11 | Modified: 2025-06-02 18:43:30
================================================================================

{
  "profiles": {
    "CamBridge.Config": {
      "commandName": "Project",
      "environmentVariables": {
        "DOTNET_ENVIRONMENT": "Development"
      }
    }
  }
}


================================================================================
FILE: Services/ConfigurationService.cs
--------------------------------------------------------------------------------
Size: 10,50 KB | Lines: 248 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Services\ConfigurationService.cs
// Version: 0.7.17
// Description: Configuration service with enum validation
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Infrastructure;
using System.Diagnostics;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Configuration service using centralized config management
    /// KISS: One config path, one format (V2 with CamBridge wrapper)!
    /// NEW in 0.7.17: Enum validation for OutputOrganization
    /// </summary>
    public class ConfigurationService : IConfigurationService
    {
        private readonly JsonSerializerOptions _jsonOptions;
        private readonly string _configPath;

        public ConfigurationService()
        {
            _jsonOptions = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNameCaseInsensitive = true,
                // Add converter for enum validation
                Converters = { new JsonStringEnumConverter() }
            };

            // SINGLE SOURCE OF TRUTH!
            _configPath = ConfigurationPaths.GetPrimaryConfigPath();

            Debug.WriteLine("=== ConfigurationService INIT ===");
            Debug.WriteLine($"Config Path: {_configPath}");
            Debug.WriteLine($"Config Exists: {File.Exists(_configPath)}");
            Debug.WriteLine("=================================");
        }

        public async Task<T?> LoadConfigurationAsync<T>() where T : class
        {
            Debug.WriteLine($"\n=== LOADING {typeof(T).Name} ===");
            Debug.WriteLine($"From: {_configPath}");

            try
            {
                if (!File.Exists(_configPath))
                {
                    Debug.WriteLine("Config file not found - will be created by InitializePrimaryConfig");
                    return null;
                }

                var json = await File.ReadAllTextAsync(_configPath);
                Debug.WriteLine($"Read {json.Length} characters");

                // Special handling for CamBridgeSettingsV2 - ALWAYS load from "CamBridge" section
                if (typeof(T) == typeof(CamBridgeSettingsV2))
                {
                    using var doc = JsonDocument.Parse(json);
                    var root = doc.RootElement;

                    // We REQUIRE a "CamBridge" section - no fallbacks!
                    if (!root.TryGetProperty("CamBridge", out var cambridgeSection))
                    {
                        throw new InvalidOperationException(
                            "Configuration file is missing required 'CamBridge' section! " +
                            "This is not a valid V2 configuration file. " +
                            "Expected format: { \"CamBridge\": { \"Version\": \"2.0\", ... } }");
                    }

                    // Deserialize from the CamBridge section
                    var settings = JsonSerializer.Deserialize<CamBridgeSettingsV2>(
                        cambridgeSection.GetRawText(),
                        _jsonOptions);

                    if (settings == null)
                    {
                        throw new InvalidOperationException(
                            "Failed to deserialize CamBridge section to CamBridgeSettingsV2");
                    }

                    // NEW in 0.7.17: Validate all enum values in pipelines
                    ValidateEnumValues(settings);

                    Debug.WriteLine($"âœ… Loaded settings from CamBridge section");
                    Debug.WriteLine($"   Version: {settings.Version}");
                    Debug.WriteLine($"   Pipelines: {settings.Pipelines.Count}");
                    Debug.WriteLine($"   MappingSets: {settings.MappingSets.Count}");

                    return settings as T;
                }
                else
                {
                    // Generic deserialization (for other types if needed)
                    var config = JsonSerializer.Deserialize<T>(json, _jsonOptions);
                    if (config != null)
                    {
                        Debug.WriteLine($"âœ… Loaded {typeof(T).Name} successfully");
                        return config;
                    }
                }

                Debug.WriteLine("âŒ Failed to deserialize config");
                return null;
            }
            catch (JsonException jsonEx)
            {
                // Special handling for enum parsing errors
                if (jsonEx.Message.Contains("OutputOrganization"))
                {
                    throw new InvalidOperationException(
                        "Invalid OutputOrganization value in configuration. " +
                        "Valid values are: None, ByPatient, ByDate, ByPatientAndDate. " +
                        "Please check your pipeline ProcessingOptions settings.", jsonEx);
                }
                throw;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR loading config: {ex.Message}");
                Debug.WriteLine($"Stack: {ex.StackTrace}");
                throw;
            }
        }

        /// <summary>
        /// NEW in 0.7.17: Validate enum values after deserialization
        /// </summary>
        private void ValidateEnumValues(CamBridgeSettingsV2 settings)
        {
            var validOutputOrgValues = Enum.GetNames(typeof(OutputOrganization));
            var validOutputOrgStr = string.Join(", ", validOutputOrgValues);

            foreach (var pipeline in settings.Pipelines)
            {
                // Validate OutputOrganization
                if (pipeline.ProcessingOptions != null)
                {
                    var orgValue = pipeline.ProcessingOptions.OutputOrganization;
                    if (!Enum.IsDefined(typeof(OutputOrganization), orgValue))
                    {
                        throw new InvalidOperationException(
                            $"Pipeline '{pipeline.Name}' has invalid OutputOrganization value. " +
                            $"Valid values are: {validOutputOrgStr}. " +
                            $"Found: {orgValue}");
                    }
                }

                // Validate PostProcessingActions
                if (pipeline.ProcessingOptions != null)
                {
                    if (!Enum.IsDefined(typeof(PostProcessingAction), pipeline.ProcessingOptions.SuccessAction))
                    {
                        throw new InvalidOperationException(
                            $"Pipeline '{pipeline.Name}' has invalid SuccessAction value. " +
                            $"Valid values are: {string.Join(", ", Enum.GetNames(typeof(PostProcessingAction)))}");
                    }

                    if (!Enum.IsDefined(typeof(PostProcessingAction), pipeline.ProcessingOptions.FailureAction))
                    {
                        throw new InvalidOperationException(
                            $"Pipeline '{pipeline.Name}' has invalid FailureAction value. " +
                            $"Valid values are: {string.Join(", ", Enum.GetNames(typeof(PostProcessingAction)))}");
                    }
                }
            }

            Debug.WriteLine("âœ… All enum values validated successfully");
        }

        public async Task SaveConfigurationAsync<T>(T configuration) where T : class
        {
            if (configuration == null)
                throw new ArgumentNullException(nameof(configuration));

            try
            {
                Debug.WriteLine($"\n=== SAVING {typeof(T).Name} ===");
                Debug.WriteLine($"To: {_configPath}");

                // Create backup before saving
                if (File.Exists(_configPath))
                {
                    try
                    {
                        // Simple inline backup implementation
                        var backupPath = $"{_configPath}.backup_{DateTime.Now:yyyyMMdd_HHmmss}";
                        File.Copy(_configPath, backupPath, true);
                        Debug.WriteLine($"Created backup: {backupPath}");
                    }
                    catch (Exception backupEx)
                    {
                        Debug.WriteLine($"Backup failed (continuing): {backupEx.Message}");
                    }
                }

                // For CamBridgeSettingsV2, we ALWAYS wrap it in the CamBridge section
                if (configuration is CamBridgeSettingsV2 v2Settings)
                {
                    // Validate before saving
                    ValidateEnumValues(v2Settings);

                    // Create wrapper object with proper V2 format
                    var wrapper = new Dictionary<string, object>
                    {
                        ["CamBridge"] = v2Settings,
                        ["Logging"] = new
                        {
                            LogLevel = new
                            {
                                Default = "Information",
                                Microsoft = "Warning",
                                CamBridge = "Information"
                            }
                        }
                    };

                    var json = JsonSerializer.Serialize(wrapper, _jsonOptions);
                    await File.WriteAllTextAsync(_configPath, json);

                    Debug.WriteLine($"âœ… Config saved with CamBridge wrapper ({json.Length} characters)");
                    Debug.WriteLine($"   Pipelines saved: {v2Settings.Pipelines.Count}");
                }
                else
                {
                    // Generic save (shouldn't happen in normal use)
                    var json = JsonSerializer.Serialize(configuration, _jsonOptions);
                    await File.WriteAllTextAsync(_configPath, json);
                    Debug.WriteLine($"âœ… Config saved successfully ({json.Length} characters)");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR saving config: {ex.Message}");
                throw new InvalidOperationException($"Failed to save configuration to {_configPath}", ex);
            }
        }
    }
}


================================================================================
FILE: Services/HttpApiService.cs
--------------------------------------------------------------------------------
Size: 3,35 KB | Lines: 94 | Modified: 2025-06-23 11:53:05
================================================================================

/**************************************************************************
*  HttpApiService.cs                                                      *
*  PATH: src\CamBridge.Config\Services\HttpApiService.cs                  *
*  VERSION: 0.7.11 | SIZE: ~7KB | MODIFIED: 2025-06-13                   *
*                                                                         *
*  DESCRIPTION: HTTP client for CamBridge Service API with PORT FIX      *
*  Copyright (c) 2025 Claude's Improbably Reliable Software Solutions     *
**************************************************************************/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using CamBridge.Config.Models;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// KISS implementation of IApiService - now with correct port!
    /// </summary>
    public class HttpApiService : IApiService
    {
        private readonly HttpClient _httpClient;

        public HttpApiService(HttpClient httpClient, object? unused = null)
        {
            _httpClient = httpClient;
            // CRITICAL FIX: Use port 5111 to match Service configuration!
            _httpClient.BaseAddress = new Uri("http://localhost:5111/"); // FIX: Was 5050!
            _httpClient.Timeout = TimeSpan.FromSeconds(5);
        }

        public async Task<ServiceStatusModel?> GetStatusAsync()
        {
            return await TryGetAsync<ServiceStatusModel>("api/status");
        }

        public async Task<bool> IsServiceAvailableAsync()
        {
            return await TryGetAsync<object>("health") != null;
        }

        public async Task<DetailedStatisticsModel?> GetStatisticsAsync()
        {
            // KISS: Not implemented yet, return null
            await Task.CompletedTask;
            return null;
        }

        /// <summary>
        /// KISS Helper: One method to rule them all!
        /// </summary>
        private async Task<T?> TryGetAsync<T>(string endpoint) where T : class
        {
            try
            {
                var response = await _httpClient.GetAsync(endpoint);
                if (!response.IsSuccessStatusCode)
                {
                    Debug.WriteLine($"API call failed ({endpoint}): {response.StatusCode}");
                    return null;
                }

                var json = await response.Content.ReadAsStringAsync();
                Debug.WriteLine($"API Response ({endpoint}): {json.Length} characters");

                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };

                return JsonSerializer.Deserialize<T>(json, options);
            }
            catch (HttpRequestException httpEx)
            {
                Debug.WriteLine($"HTTP error ({endpoint}): {httpEx.Message}");
                return null;
            }
            catch (TaskCanceledException)
            {
                Debug.WriteLine($"API call timeout ({endpoint})");
                return null;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"API call failed ({endpoint}): {ex.Message}");
                return null;
            }
        }
    }
}


================================================================================
FILE: Services/IApiService.cs
--------------------------------------------------------------------------------
Size: 1011 bytes | Lines: 35 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Config/Services/IApiService.cs
// Version: 0.7.8
// Description: Interface for CamBridge Service API - KISS without DeadLetter!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CamBridge.Config.Models;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Interface for CamBridge Service API communication
    /// KISS: Removed DeadLetter methods!
    /// </summary>
    public interface IApiService
    {
        /// <summary>
        /// Gets the current service status
        /// </summary>
        Task<ServiceStatusModel?> GetStatusAsync();

        /// <summary>
        /// Gets detailed statistics
        /// </summary>
        Task<DetailedStatisticsModel?> GetStatisticsAsync();

        /// <summary>
        /// Checks if the service is reachable
        /// </summary>
        Task<bool> IsServiceAvailableAsync();
    }
}


================================================================================
FILE: Services/IConfigurationService.cs
--------------------------------------------------------------------------------
Size: 274 bytes | Lines: 11 | Modified: 2025-06-23 11:53:05
================================================================================

using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    public interface IConfigurationService
    {
        Task<T?> LoadConfigurationAsync<T>() where T : class;
        Task SaveConfigurationAsync<T>(T configuration) where T : class;
    }
}


================================================================================
FILE: Services/INavigationService.cs
--------------------------------------------------------------------------------
Size: 294 bytes | Lines: 15 | Modified: 2025-06-23 11:53:05
================================================================================

using System;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Navigation service interface
    /// </summary>
    public interface INavigationService
    {
        bool CanGoBack { get; }
        void NavigateTo(string pageKey);
        void GoBack();
    }
}


================================================================================
FILE: Services/IServiceManager.cs
--------------------------------------------------------------------------------
Size: 1,80 KB | Lines: 70 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Config/Services/IServiceManager.cs
using System;
using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Interface for managing the CamBridge Windows Service
    /// </summary>
    public interface IServiceManager
    {
        /// <summary>
        /// Checks if the application is running with administrator privileges
        /// </summary>
        bool IsRunningAsAdministrator();

        /// <summary>
        /// Checks if the CamBridge service is installed
        /// </summary>
        Task<bool> IsServiceInstalledAsync();

        /// <summary>
        /// Gets the current status of the CamBridge service
        /// </summary>
        Task<ServiceStatus> GetServiceStatusAsync();

        /// <summary>
        /// Gets the start time of the service if it's running
        /// </summary>
        Task<DateTime?> GetServiceStartTimeAsync();

        /// <summary>
        /// Installs the CamBridge service
        /// </summary>
        Task<bool> InstallServiceAsync();

        /// <summary>
        /// Uninstalls the CamBridge service
        /// </summary>
        Task<bool> UninstallServiceAsync();

        /// <summary>
        /// Starts the CamBridge service
        /// </summary>
        Task<bool> StartServiceAsync();

        /// <summary>
        /// Stops the CamBridge service
        /// </summary>
        Task<bool> StopServiceAsync();

        /// <summary>
        /// Restarts the CamBridge service
        /// </summary>
        Task<bool> RestartServiceAsync();
    }

    /// <summary>
    /// Service status enumeration
    /// </summary>
    public enum ServiceStatus
    {
        Unknown,
        Running,
        Stopped,
        Starting,
        Stopping
    }
}


================================================================================
FILE: Services/ISettingsService.cs
--------------------------------------------------------------------------------
Size: 7,38 KB | Lines: 240 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Services\ISettingsService.cs
// Version: 0.7.3
// Description: Multi-layer settings service interface
// Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CamBridge.Core;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Service for managing the 3-layer settings architecture:
    /// - System settings (shared between Service and Config Tool)
    /// - Pipeline configurations (shared, multiple instances)
    /// - User preferences (per-user UI settings)
    /// </summary>
    public interface ISettingsService
    {
        // === SYSTEM-WIDE SETTINGS ===

        /// <summary>
        /// Gets the current system settings
        /// </summary>
        Task<SystemSettings> GetSystemSettingsAsync();

        /// <summary>
        /// Saves system settings with backup
        /// </summary>
        Task SaveSystemSettingsAsync(SystemSettings settings);

        /// <summary>
        /// Reloads system settings from disk
        /// </summary>
        Task ReloadSystemSettingsAsync();

        /// <summary>
        /// Validates system settings
        /// </summary>
        Task<SettingsValidationResult> ValidateSystemSettingsAsync(SystemSettings settings);

        // === PIPELINE CONFIGURATIONS ===

        /// <summary>
        /// Gets all available pipeline configurations
        /// </summary>
        Task<IList<PipelineConfiguration>> GetPipelinesAsync();

        /// <summary>
        /// Gets a specific pipeline configuration
        /// </summary>
        Task<PipelineConfiguration?> GetPipelineAsync(Guid pipelineId);

        /// <summary>
        /// Saves a pipeline configuration
        /// </summary>
        Task SavePipelineAsync(PipelineConfiguration pipeline);

        /// <summary>
        /// Deletes a pipeline configuration
        /// </summary>
        Task DeletePipelineAsync(Guid pipelineId);

        /// <summary>
        /// Imports a pipeline configuration from file
        /// </summary>
        Task<PipelineConfiguration> ImportPipelineAsync(string filePath);

        /// <summary>
        /// Exports a pipeline configuration to file
        /// </summary>
        Task ExportPipelineAsync(Guid pipelineId, string filePath);

        /// <summary>
        /// Creates a copy of an existing pipeline
        /// </summary>
        Task<PipelineConfiguration> ClonePipelineAsync(Guid sourcePipelineId, string newName);

        // === USER PREFERENCES ===

        /// <summary>
        /// Gets the current user preferences
        /// </summary>
        Task<UserPreferences> GetUserPreferencesAsync();

        /// <summary>
        /// Saves user preferences
        /// </summary>
        Task SaveUserPreferencesAsync(UserPreferences preferences);

        /// <summary>
        /// Resets user preferences to defaults
        /// </summary>
        Task ResetUserPreferencesAsync();

        /// <summary>
        /// Exports user preferences for backup
        /// </summary>
        Task ExportUserPreferencesAsync(string filePath);

        /// <summary>
        /// Imports user preferences from backup
        /// </summary>
        Task ImportUserPreferencesAsync(string filePath);

        // === MIGRATION AND MAINTENANCE ===

        /// <summary>
        /// Checks if settings migration is needed and performs it
        /// </summary>
        Task<SettingsMigrationResult> MigrateSettingsIfNeededAsync();

        /// <summary>
        /// Creates backups of all settings
        /// </summary>
        Task<SettingsBackupResult> BackupAllSettingsAsync();

        /// <summary>
        /// Restores settings from a backup
        /// </summary>
        Task RestoreFromBackupAsync(string backupPath);

        /// <summary>
        /// Validates all settings files
        /// </summary>
        Task<SettingsHealthCheckResult> ValidateAllSettingsAsync();

        /// <summary>
        /// Cleans up old backups and temporary files
        /// </summary>
        Task CleanupAsync(int keepBackupCount = 10);

        // === EVENTS ===

        /// <summary>
        /// Raised when system settings change
        /// </summary>
        event EventHandler<SettingsChangedEventArgs>? SystemSettingsChanged;

        /// <summary>
        /// Raised when a pipeline configuration changes
        /// </summary>
        event EventHandler<PipelineChangedEventArgs>? PipelineChanged;

        /// <summary>
        /// Raised when user preferences change
        /// </summary>
        event EventHandler<SettingsChangedEventArgs>? UserPreferencesChanged;
    }

    /// <summary>
    /// Result of settings validation
    /// </summary>
    public class SettingsValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
    }

    /// <summary>
    /// Result of settings migration
    /// </summary>
    public class SettingsMigrationResult
    {
        public bool MigrationPerformed { get; set; }
        public string FromVersion { get; set; } = string.Empty;
        public string ToVersion { get; set; } = string.Empty;
        public List<string> MigratedFiles { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
    }

    /// <summary>
    /// Result of backup operation
    /// </summary>
    public class SettingsBackupResult
    {
        public bool Success { get; set; }
        public string BackupPath { get; set; } = string.Empty;
        public List<string> BackedUpFiles { get; set; } = new();
        public long TotalSizeBytes { get; set; }
    }

    /// <summary>
    /// Result of health check
    /// </summary>
    public class SettingsHealthCheckResult
    {
        public bool IsHealthy { get; set; }
        public Dictionary<string, FileHealthStatus> FileStatuses { get; set; } = new();
        public List<string> Issues { get; set; } = new();
    }

    /// <summary>
    /// Health status of a settings file
    /// </summary>
    public class FileHealthStatus
    {
        public bool Exists { get; set; }
        public bool IsReadable { get; set; }
        public bool IsWritable { get; set; }
        public bool IsValidJson { get; set; }
        public long SizeBytes { get; set; }
        public DateTime LastModified { get; set; }
    }

    /// <summary>
    /// Event args for settings changes
    /// </summary>
    public class SettingsChangedEventArgs : EventArgs
    {
        public string SettingsType { get; set; } = string.Empty;
        public string ChangedBy { get; set; } = string.Empty;
        public DateTime ChangeTime { get; set; } = DateTime.UtcNow;
    }

    /// <summary>
    /// Event args for pipeline changes
    /// </summary>
    public class PipelineChangedEventArgs : SettingsChangedEventArgs
    {
        public Guid PipelineId { get; set; }
        public string PipelineName { get; set; } = string.Empty;
        public PipelineChangeType ChangeType { get; set; }
    }

    /// <summary>
    /// Type of pipeline change
    /// </summary>
    public enum PipelineChangeType
    {
        Created,
        Updated,
        Deleted,
        Imported,
        Exported
    }
}


================================================================================
FILE: Services/NavigationService.cs
--------------------------------------------------------------------------------
Size: 3,03 KB | Lines: 83 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Services\NavigationService.cs
// Version: 0.7.28
// Description: Navigation service with LogViewer page added

using System;
using System.Collections.Generic;
using System.Windows.Controls;
using CamBridge.Config.Views;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;

namespace CamBridge.Config.Services
{
    public class NavigationService : INavigationService
    {
        private Frame? _frame;
        private readonly Dictionary<string, Type> _pages = new();
        private readonly IServiceProvider _serviceProvider;

        public NavigationService()
        {
            // Get service provider from App
            var app = (App)App.Current;
            _serviceProvider = app.Host!.Services;

            // Register pages - Updated with LogViewer
            _pages["Dashboard"] = typeof(DashboardPage);
            _pages["PipelineConfig"] = typeof(PipelineConfigPage);
            _pages["DeadLetters"] = typeof(DeadLettersPage);
            _pages["MappingEditor"] = typeof(MappingEditorPage);
            _pages["ServiceControl"] = typeof(ServiceControlPage);
            _pages["LogViewer"] = typeof(LogViewerPage);
            _pages["About"] = typeof(AboutPage);
        }

        public bool CanGoBack => _frame?.CanGoBack ?? false;

        public void SetFrame(object frame)
        {
            _frame = frame as Frame;
        }

        public void NavigateTo(string pageKey)
        {
            if (_frame != null && _pages.TryGetValue(pageKey, out var pageType))
            {
                var page = Activator.CreateInstance(pageType);

                // CRITICAL: Inject ViewModel based on page type!
                if (page is Page pageInstance)
                {
                    object? viewModel = pageKey switch
                    {
                        "Dashboard" => _serviceProvider.GetService<DashboardViewModel>(),
                        "PipelineConfig" => _serviceProvider.GetService<PipelineConfigViewModel>(),
                        "DeadLetters" => _serviceProvider.GetService<DeadLettersViewModel>(),
                        "MappingEditor" => _serviceProvider.GetService<MappingEditorViewModel>(),
                        "ServiceControl" => _serviceProvider.GetService<ServiceControlViewModel>(),
                        "LogViewer" => _serviceProvider.GetService<LogViewerViewModel>(),
                        _ => null
                    };

                    if (viewModel != null)
                    {
                        pageInstance.DataContext = viewModel;
                        System.Diagnostics.Debug.WriteLine($"NavigationService: Injected {viewModel.GetType().Name} into {pageType.Name}");
                    }

                    _frame.Navigate(pageInstance);
                }
            }
        }

        public void GoBack()
        {
            if (_frame?.CanGoBack == true)
            {
                _frame.GoBack();
            }
        }
    }
}


================================================================================
FILE: Services/ServiceManager.cs
--------------------------------------------------------------------------------
Size: 17,13 KB | Lines: 424 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Config/Services/ServiceManager.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Principal;
using System.ServiceProcess;
using System.Text;
using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Implementation of service management functionality
    /// </summary>
    public class ServiceManager : IServiceManager
    {
        private const string ServiceName = "CamBridgeService";
        private const string ServiceDisplayName = "CamBridge Image Processing Service";
        private const string ServiceDescription = "Monitors folders for JPEG images and converts them to DICOM format.";

        public bool IsRunningAsAdministrator()
        {
            var identity = WindowsIdentity.GetCurrent();
            var principal = new WindowsPrincipal(identity);
            return principal.IsInRole(WindowsBuiltInRole.Administrator);
        }

        public async Task<bool> IsServiceInstalledAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    using var controller = ServiceController.GetServices()
                        .FirstOrDefault(s => s.ServiceName == ServiceName);
                    return controller != null;
                }
                catch
                {
                    return false;
                }
            });
        }

        public async Task<ServiceStatus> GetServiceStatusAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    using var controller = new ServiceController(ServiceName);
                    controller.Refresh();

                    return controller.Status switch
                    {
                        ServiceControllerStatus.Running => ServiceStatus.Running,
                        ServiceControllerStatus.Stopped => ServiceStatus.Stopped,
                        ServiceControllerStatus.StartPending => ServiceStatus.Starting,
                        ServiceControllerStatus.StopPending => ServiceStatus.Stopping,
                        _ => ServiceStatus.Unknown
                    };
                }
                catch
                {
                    return ServiceStatus.Unknown;
                }
            });
        }

        public async Task<DateTime?> GetServiceStartTimeAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    // Try to get start time from Windows Management
                    using var process = Process.GetProcessesByName("CamBridge.Service").FirstOrDefault();
                    return process?.StartTime;
                }
                catch
                {
                    return null;
                }
            });
        }

        public async Task<bool> InstallServiceAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    // Find the service executable
                    var serviceExePath = FindServiceExecutable();
                    if (string.IsNullOrEmpty(serviceExePath))
                    {
                        // Log all searched paths for debugging
                        var searchPaths = GetSearchPaths();
                        var pathList = string.Join("\n", searchPaths);

                        // Create a detailed error message
                        var errorMsg = new StringBuilder();
                        errorMsg.AppendLine("Could not find CamBridge.Service.exe");
                        errorMsg.AppendLine("\nSearched in:");
                        foreach (var path in searchPaths)
                        {
                            var exists = File.Exists(path);
                            errorMsg.AppendLine($"  {(exists ? "âœ“" : "âœ—")} {path}");
                        }

                        throw new FileNotFoundException(errorMsg.ToString());
                    }

                    // Log the found path
                    Debug.WriteLine($"Found service executable at: {serviceExePath}");

                    // Use sc.exe to install the service
                    var processInfo = new ProcessStartInfo
                    {
                        FileName = "sc.exe",
                        Arguments = $"create {ServiceName} binPath= \"{serviceExePath}\" DisplayName= \"{ServiceDisplayName}\" start= auto",
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = true,
                        Verb = "runas"
                    };

                    using var process = Process.Start(processInfo);
                    if (process == null)
                    {
                        throw new InvalidOperationException("Failed to start sc.exe process");
                    }

                    var output = process.StandardOutput.ReadToEnd();
                    var error = process.StandardError.ReadToEnd();
                    process.WaitForExit();

                    Debug.WriteLine($"sc.exe output: {output}");
                    if (!string.IsNullOrEmpty(error))
                    {
                        Debug.WriteLine($"sc.exe error: {error}");
                    }

                    if (process.ExitCode == 0)
                    {
                        // Set service description
                        var descProcessInfo = new ProcessStartInfo
                        {
                            FileName = "sc.exe",
                            Arguments = $"description {ServiceName} \"{ServiceDescription}\"",
                            UseShellExecute = false,
                            CreateNoWindow = true,
                            Verb = "runas"
                        };

                        using var descProcess = Process.Start(descProcessInfo);
                        descProcess?.WaitForExit();

                        // Configure recovery options
                        ConfigureServiceRecovery();

                        return true;
                    }
                    else
                    {
                        var errorMessage = $"sc.exe failed with exit code {process.ExitCode}";
                        if (!string.IsNullOrEmpty(error))
                        {
                            errorMessage += $"\nError: {error}";
                        }
                        if (!string.IsNullOrEmpty(output) && output.Contains("error", StringComparison.OrdinalIgnoreCase))
                        {
                            errorMessage += $"\nOutput: {output}";
                        }

                        throw new InvalidOperationException(errorMessage);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Service installation failed: {ex}");
                    throw;
                }
            });
        }

        public async Task<bool> UninstallServiceAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    // Use sc.exe to delete the service
                    var processInfo = new ProcessStartInfo
                    {
                        FileName = "sc.exe",
                        Arguments = $"delete {ServiceName}",
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = true,
                        Verb = "runas"
                    };

                    using var process = Process.Start(processInfo);
                    process?.WaitForExit();

                    return process?.ExitCode == 0;
                }
                catch
                {
                    return false;
                }
            });
        }

        public async Task<bool> StartServiceAsync()
        {
            try
            {
                using var controller = new ServiceController(ServiceName);

                if (controller.Status == ServiceControllerStatus.Running)
                    return true;

                controller.Start();
                await WaitForServiceStatusAsync(controller, ServiceControllerStatus.Running, TimeSpan.FromSeconds(30));

                return controller.Status == ServiceControllerStatus.Running;
            }
            catch
            {
                return false;
            }
        }

        public async Task<bool> StopServiceAsync()
        {
            try
            {
                using var controller = new ServiceController(ServiceName);

                if (controller.Status == ServiceControllerStatus.Stopped)
                    return true;

                controller.Stop();
                await WaitForServiceStatusAsync(controller, ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(30));

                return controller.Status == ServiceControllerStatus.Stopped;
            }
            catch
            {
                return false;
            }
        }

        public async Task<bool> RestartServiceAsync()
        {
            try
            {
                // Stop service
                var stopResult = await StopServiceAsync();
                if (!stopResult)
                    return false;

                // Wait a bit before starting
                await Task.Delay(1000);

                // Start service
                return await StartServiceAsync();
            }
            catch
            {
                return false;
            }
        }

        private async Task WaitForServiceStatusAsync(ServiceController controller, ServiceControllerStatus desiredStatus, TimeSpan timeout)
        {
            await Task.Run(() =>
            {
                try
                {
                    controller.WaitForStatus(desiredStatus, timeout);
                }
                catch (System.ServiceProcess.TimeoutException)
                {
                    // Status change timed out
                }
            });
        }

        private string? FindServiceExecutable()
        {
            var possiblePaths = GetSearchPaths();

            foreach (var path in possiblePaths)
            {
                try
                {
                    var normalizedPath = Path.GetFullPath(path);
                    Debug.WriteLine($"Checking: {normalizedPath}");
                    if (File.Exists(normalizedPath))
                    {
                        Debug.WriteLine($"Found service at: {normalizedPath}");
                        return normalizedPath;
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error checking path {path}: {ex.Message}");
                }
            }

            return null;
        }

        private string[] GetSearchPaths()
        {
            var paths = new List<string>
            {
                // Same directory as config app
                Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? "", "CamBridge.Service.exe"),
                // Parent directory (if config is in subfolder)
                Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? "", "..", "CamBridge.Service.exe"),
                // Debug/Release output paths
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "CamBridge.Service.exe"),
            };

            // Find solution directory first for more accurate paths
            var solutionDir = FindSolutionDirectory();
            if (!string.IsNullOrEmpty(solutionDir))
            {
                // Add all known locations from PROJECT_WISDOM
                paths.AddRange(new[]
                {
                    // Standard debug/release paths
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0", "CamBridge.Service.exe"),
                    
                    // win-x64 specific paths (from PROJECT_WISDOM)
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    
                    // x64 configuration paths
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Debug", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Release", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Release", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    
                    // net8.0-windows paths (this was missing!)
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0-windows", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0-windows", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Debug", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Release", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    
                    // Published output
                    Path.Combine(solutionDir, "publish", "CamBridge.Service.exe")
                });
            }
            else
            {
                // Fallback paths relative to current directory
                paths.AddRange(new[]
                {
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "Debug", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "Release", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "x64", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "x64", "Debug", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "publish", "CamBridge.Service.exe")
                });
            }

            return paths.Distinct().ToArray();
        }

        private string? FindSolutionDirectory()
        {
            var directory = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory);

            while (directory != null && directory.Parent != null)
            {
                if (directory.GetFiles("CamBridge.sln").Any())
                {
                    return directory.FullName;
                }
                directory = directory.Parent;
            }

            return null;
        }

        private void ConfigureServiceRecovery()
        {
            try
            {
                // Configure service to restart on failure
                var processInfo = new ProcessStartInfo
                {
                    FileName = "sc.exe",
                    Arguments = $"failure {ServiceName} reset= 86400 actions= restart/60000/restart/60000/restart/60000",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    Verb = "runas"
                };

                using var process = Process.Start(processInfo);
                process?.WaitForExit();
            }
            catch
            {
                // Recovery configuration is optional, so we don't fail the installation
            }
        }
    }
}


================================================================================
FILE: ViewModels/DashboardViewModel.cs
--------------------------------------------------------------------------------
Size: 6,78 KB | Lines: 201 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\ViewModels\DashboardViewModel.cs
// Version: 0.7.21
// Description: MINIMAL Dashboard - Just show if service is running!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using CamBridge.Config.Models;
using CamBridge.Config.Services;
using CamBridge.Core;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// MINIMAL Dashboard - KISS approach!
    /// </summary>
    public partial class DashboardViewModel : ObservableObject
    {
        private readonly IConfigurationService _configurationService;
        private DispatcherTimer? _refreshTimer;
        private readonly HttpClient _httpClient = new();

        [ObservableProperty]
        private string serviceStatus = "Checking...";

        [ObservableProperty]
        private bool isServiceRunning = false;

        [ObservableProperty]
        private string uptimeText = "";

        [ObservableProperty]
        private string versionText = "";

        [ObservableProperty]
        private DateTime lastUpdate = DateTime.Now;

        [ObservableProperty]
        private bool isLoading;

        // Collections
        public ObservableCollection<PipelineStatusViewModel> PipelineStatuses { get; }

        // Commands
        public IAsyncRelayCommand RefreshCommand { get; }
        public IAsyncRelayCommand StartServiceCommand { get; }

        public DashboardViewModel(IApiService? apiService = null, IConfigurationService? configurationService = null)
        {
            // We ignore IApiService - go direct!
            _configurationService = configurationService ?? new ConfigurationService();

            PipelineStatuses = new ObservableCollection<PipelineStatusViewModel>();

            RefreshCommand = new AsyncRelayCommand(RefreshAsync);
            StartServiceCommand = new AsyncRelayCommand(StartServiceAsync);

            // Setup timer
            _refreshTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(5)
            };
            _refreshTimer.Tick += async (s, e) => await RefreshAsync();
            _refreshTimer.Start();

            // Initial load
            Task.Run(async () => await RefreshAsync());
        }

        private async Task RefreshAsync()
        {
            try
            {
                IsLoading = true;
                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss}] Dashboard refresh...");

                // MINIMAL: Direct HTTP call!
                var response = await _httpClient.GetAsync("http://localhost:5111/api/status");

                if (response.IsSuccessStatusCode)
                {
                    var json = await response.Content.ReadAsStringAsync();
                    var status = JsonSerializer.Deserialize<ServiceStatusModel>(json, new JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true
                    });

                    if (status != null)
                    {
                        // Update UI on dispatcher
                        await Application.Current.Dispatcher.InvokeAsync(() =>
                        {
                            IsServiceRunning = true;
                            ServiceStatus = status.Service.Status;
                            UptimeText = $"Uptime: {status.Service.Uptime}";
                            VersionText = $"Version: {status.Service.Version}";

                            Debug.WriteLine($"Service is {status.ServiceStatus}!");

                            // Update pipelines
                            if (status.Pipelines != null)
                            {
                                UpdatePipelines(status.Pipelines);
                            }
                        });
                    }
                }
                else
                {
                    // Service offline
                    await Application.Current.Dispatcher.InvokeAsync(() =>
                    {
                        IsServiceRunning = false;
                        ServiceStatus = "Offline";
                        UptimeText = "";
                        VersionText = "";
                        Debug.WriteLine("Service is offline!");
                    });
                }

                LastUpdate = DateTime.Now;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Dashboard refresh error: {ex.Message}");

                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    IsServiceRunning = false;
                    ServiceStatus = "Offline";
                    UptimeText = "";
                    VersionText = "Cannot connect to service";
                });
            }
            finally
            {
                IsLoading = false;
            }
        }

private void UpdatePipelines(List<PipelineStatusData> pipelines)
{
    PipelineStatuses.Clear();

    foreach (var p in pipelines)
    {
        PipelineStatuses.Add(new PipelineStatusViewModel
        {
            PipelineName = p.Name,
            Status = p.IsActive ? "Active" : "Inactive",
            IsEnabled = p.IsActive,
            QueueLength = p.QueueDepth,           // Changed from QueueLength
            ProcessedToday = p.ProcessedCount,    // Changed from TotalProcessed
            ErrorsToday = p.ErrorCount,           // Changed from TotalFailed
            WatchFolder = p.WatchPath             // Changed from WatchedFolders[0]
        });
    }
}

        private async Task StartServiceAsync()
        {
            try
            {
                var startInfo = new ProcessStartInfo
                {
                    FileName = "net.exe",
                    Arguments = "start CamBridgeService",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    Verb = "runas"
                };

                var process = Process.Start(startInfo);
                await process!.WaitForExitAsync();

                // Wait and refresh
                await Task.Delay(2000);
                await RefreshAsync();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Failed to start service: {ex.Message}");
            }
        }

        public void Cleanup()
        {
            _refreshTimer?.Stop();
            _httpClient?.Dispose();
        }
    }
}


================================================================================
FILE: ViewModels/DeadLettersViewModel.cs
--------------------------------------------------------------------------------
Size: 2,71 KB | Lines: 95 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Config/ViewModels/DeadLettersViewModel.cs
// Version: 0.7.8
// Description: SIMPLE error folder viewer - KISS approach!

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Simple ViewModel for error folder viewing - KISS!
    /// </summary>
    public partial class DeadLettersViewModel : ViewModelBase
    {
        [ObservableProperty] private string _errorFolder;
        [ObservableProperty] private bool _errorFolderExists;
        [ObservableProperty] private int _errorFileCount;

        public DeadLettersViewModel()
        {
            // Default error folder from ProcessingOptions
            _errorFolder = @"C:\CamBridge\Errors";
            CheckErrorFolder();
        }

        /// <summary>
        /// Open error folder in Windows Explorer
        /// </summary>
        [RelayCommand]
        private void OpenErrorFolder()
        {
            try
            {
                if (!Directory.Exists(ErrorFolder))
                {
                    Directory.CreateDirectory(ErrorFolder);
                }

                Process.Start("explorer.exe", ErrorFolder);
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show(
                    $"Could not open error folder: {ex.Message}",
                    "Error",
                    System.Windows.MessageBoxButton.OK,
                    System.Windows.MessageBoxImage.Warning);
            }
        }

        /// <summary>
        /// Refresh error folder status
        /// </summary>
        [RelayCommand]
        private async Task RefreshAsync()
        {
            await Task.Run(() => CheckErrorFolder());
        }

        /// <summary>
        /// Check if error folder exists and count files
        /// </summary>
        private void CheckErrorFolder()
        {
            try
            {
                ErrorFolderExists = Directory.Exists(ErrorFolder);

                if (ErrorFolderExists)
                {
                    var errorFiles = Directory.GetFiles(ErrorFolder, "*.jpg", SearchOption.AllDirectories);
                    ErrorFileCount = errorFiles.Length;
                }
                else
                {
                    ErrorFileCount = 0;
                }
            }
            catch
            {
                ErrorFileCount = 0;
            }
        }

        public void Cleanup()
        {
            // Nothing to cleanup in simple implementation
        }
    }
}


================================================================================
FILE: ViewModels/LogViewerViewModel.cs
--------------------------------------------------------------------------------
Size: 33,04 KB | Lines: 899 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\ViewModels\LogViewerViewModel.cs
// Version: 0.7.28
// Description: Professional log viewer with multi-pipeline support, Unicode handling, and real-time updates
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.Services;
using CamBridge.Core;
using CamBridge.Core.Infrastructure;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Tracks file position for incremental reading
    /// </summary>
    public class FilePositionInfo
    {
        public long Position { get; set; }
        public DateTime LastRead { get; set; }
    }

    /// <summary>
    /// Represents a selectable pipeline in the multi-select dropdown
    /// </summary>
    public class PipelineSelection : ViewModelBase
    {
        private bool _isSelected;

        public string Name { get; set; } = string.Empty;
        public string SanitizedName { get; set; } = string.Empty;

        public bool IsSelected
        {
            get => _isSelected;
            set => SetProperty(ref _isSelected, value);
        }
    }

    /// <summary>
    /// ViewModel for the professional log viewer with multi-pipeline support
    /// </summary>
    public partial class LogViewerViewModel : ViewModelBase
    {
        private readonly ILogger<LogViewerViewModel> _logger;
        private readonly IConfigurationService _configurationService;
        private readonly Dictionary<string, string> _pipelineNameMapping;
        private readonly Timer _refreshTimer;
        private readonly Dictionary<string, long> _filePositions;
        private CancellationTokenSource? _watcherCancellation;
        private FileSystemWatcher? _logWatcher;

        // Constants
        private const int MaxDisplayedEntries = 10000;
        private const int TailLineCount = 1000;
        private const int RefreshIntervalMs = 1000;

        public LogViewerViewModel(
            ILogger<LogViewerViewModel> logger,
            IConfigurationService configurationService)
        {
            _logger = logger;
            _configurationService = configurationService;
            _pipelineNameMapping = new Dictionary<string, string>();
            _filePositions = new Dictionary<string, long>();

            // Initialize collections
            LogEntries = new ObservableCollection<LogEntry>();
            FilteredCombinedEntries = new ObservableCollection<LogEntry>();
            CombinedLogEntries = new ObservableCollection<LogEntry>();
            AvailablePipelines = new ObservableCollection<string>();
            PipelineSelections = new ObservableCollection<PipelineSelection>();

            // Initialize commands
            RefreshCommand = new AsyncRelayCommand(RefreshLogsAsync);
            ClearLogCommand = new RelayCommand(ClearLogs);
            ExportLogCommand = new AsyncRelayCommand(ExportLogsAsync);

            // Initialize timer for auto-refresh
            _refreshTimer = new Timer(OnRefreshTimer, null, Timeout.Infinite, Timeout.Infinite);

            // Set default filter values - ALLE AN fÃ¼r sinnvolle Defaults!
            ShowDebug = false;  // Debug meist zu viel
            ShowInformation = true;
            ShowWarning = true;
            ShowError = true;
            ShowCritical = true;
            IsAutoScrollEnabled = false; // Default OFF to prevent flicker
        }

        #region Properties

        [ObservableProperty]
        private ObservableCollection<LogEntry> logEntries;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(DisplayedLineCount))]
        private ObservableCollection<LogEntry> filteredCombinedEntries;

        [ObservableProperty]
        private ObservableCollection<LogEntry> combinedLogEntries;

        [ObservableProperty]
        private ObservableCollection<string> availablePipelines;

        [ObservableProperty]
        private ObservableCollection<PipelineSelection> pipelineSelections;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        private string? searchText;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        private bool showDebug;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        private bool showInformation;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        private bool showWarning;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        private bool showError;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        private bool showCritical;

        [ObservableProperty]
        private bool isAutoScrollEnabled;

        [ObservableProperty]
        private bool isLoading;

        [ObservableProperty]
        private string currentLogFile = "No log file loaded";

        [ObservableProperty]
        private string currentLogFiles = "No files selected";

        [ObservableProperty]
        private int totalLineCount;

        [ObservableProperty]
        private DateTime lastUpdateTime = DateTime.Now;

        public int DisplayedLineCount => FilteredCombinedEntries?.Count ?? 0;

        public int SelectedPipelineCount => PipelineSelections?.Count(p => p.IsSelected) ?? 0;

        public int SelectedLevelCount
        {
            get
            {
                var count = 0;
                if (ShowDebug) count++;
                if (ShowInformation) count++;
                if (ShowWarning) count++;
                if (ShowError) count++;
                if (ShowCritical) count++;
                return count;
            }
        }

        #endregion

        #region Commands

        public IAsyncRelayCommand RefreshCommand { get; }
        public IRelayCommand ClearLogCommand { get; }
        public IAsyncRelayCommand ExportLogCommand { get; }

        #endregion

        #region Public Methods

        public async Task InitializeAsync()
        {
            try
            {
                _logger.LogInformation("Initializing LogViewerViewModel");

                // Load available pipelines
                await LoadAvailablePipelinesAsync();

                // PipelineSelections sollte bereits "Service (Global)" als ausgewÃ¤hlt haben!
                // (Das passiert in LoadAvailablePipelinesAsync mit IsSelected = true)

                // Update count display
                OnPropertyChanged(nameof(SelectedPipelineCount));
                OnPropertyChanged(nameof(SelectedLevelCount));

                // Log initial filter state
                _logger.LogInformation("Initial filter state: Debug={Debug}, Info={Info}, Warn={Warn}, Error={Error}, Critical={Critical}",
                    ShowDebug, ShowInformation, ShowWarning, ShowError, ShowCritical);

                // Log selected pipelines
                var selected = PipelineSelections.Where(p => p.IsSelected).Select(p => p.Name).ToList();
                _logger.LogInformation("Selected pipelines: {Pipelines}", string.Join(", ", selected));

                // Load initial logs
                await RefreshLogsAsync();

                // Start auto-refresh if enabled
                if (IsAutoScrollEnabled)
                {
                    _refreshTimer.Change(RefreshIntervalMs, RefreshIntervalMs);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to initialize LogViewerViewModel");
            }
        }

        public void Cleanup()
        {
            try
            {
                _refreshTimer?.Change(Timeout.Infinite, Timeout.Infinite);
                _refreshTimer?.Dispose();
                _watcherCancellation?.Cancel();
                _watcherCancellation?.Dispose();
                _logWatcher?.Dispose();

                // Unsubscribe from selection changes
                foreach (var selection in PipelineSelections)
                {
                    selection.PropertyChanged -= OnPipelineSelectionChanged;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during cleanup");
            }
        }

        #endregion

        private void ApplyFilters()
        {
            // WICHTIG: Muss auf dem UI Thread laufen!
            if (!Application.Current.Dispatcher.CheckAccess())
            {
                Application.Current.Dispatcher.Invoke(() => ApplyFilters());
                return;
            }

            _logger.LogDebug("ApplyFilters: Starting with {Count} combined entries", CombinedLogEntries.Count);

            var filtered = CombinedLogEntries.AsEnumerable();

            // Apply level filters - wenn KEINS ausgewÃ¤hlt, zeige ALLE!
            var anyLevelSelected = ShowDebug || ShowInformation || ShowWarning || ShowError || ShowCritical;

            _logger.LogDebug("Level filter state: Debug={Debug}, Info={Info}, Warn={Warn}, Error={Error}, Critical={Critical}, Any={Any}",
                ShowDebug, ShowInformation, ShowWarning, ShowError, ShowCritical, anyLevelSelected);

            if (anyLevelSelected)
            {
                filtered = filtered.Where(e =>
                    (ShowDebug && e.Level == LogLevel.Debug) ||
                    (ShowInformation && e.Level == LogLevel.Information) ||
                    (ShowWarning && e.Level == LogLevel.Warning) ||
                    (ShowError && e.Level == LogLevel.Error) ||
                    (ShowCritical && e.Level == LogLevel.Critical));
            }
            // Wenn keine Level ausgewÃ¤hlt â†’ zeige alle!

            // Apply search filter
            if (!string.IsNullOrWhiteSpace(SearchText))
            {
                var searchLower = SearchText.ToLowerInvariant();
                filtered = filtered.Where(e =>
                    e.Message.ToLowerInvariant().Contains(searchLower) ||
                    e.LevelText.ToLowerInvariant().Contains(searchLower) ||
                    e.Source.ToLowerInvariant().Contains(searchLower));

                _logger.LogDebug("Search filter applied: '{Search}'", SearchText);
            }

            // Update filtered collection
            var filteredList = filtered.ToList();
            _logger.LogDebug("After filtering: {Count} entries remain", filteredList.Count);

            FilteredCombinedEntries.Clear();
            foreach (var entry in filteredList)
            {
                FilteredCombinedEntries.Add(entry);
            }
        }

        private async Task LoadAvailablePipelinesAsync()
        {
            try
            {
                AvailablePipelines.Clear();
                PipelineSelections.Clear();
                _pipelineNameMapping.Clear();

                // Always add Service (Global) log
                AvailablePipelines.Add("Service (Global)");
                PipelineSelections.Add(new PipelineSelection
                {
                    Name = "Service (Global)",
                    SanitizedName = "service",
                    IsSelected = true // Default selected
                });

                // Get configured pipelines
                var settings = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();
                if (settings?.Pipelines != null)
                {
                    foreach (var pipeline in settings.Pipelines)
                    {
                        var displayName = $"{pipeline.Name}";
                        var sanitizedName = SanitizeForFileName(pipeline.Name);

                        AvailablePipelines.Add(displayName);
                        _pipelineNameMapping[displayName] = sanitizedName;

                        PipelineSelections.Add(new PipelineSelection
                        {
                            Name = displayName,
                            SanitizedName = sanitizedName,
                            IsSelected = false
                        });
                    }
                }

                // Also check for existing log files that might not be in config
                var logPath = ConfigurationPaths.GetLogsDirectory();
                if (Directory.Exists(logPath))
                {
                    // Check for old combined pipelines log
                    if (File.Exists(Path.Combine(logPath, $"pipelines_{DateTime.Now:yyyyMMdd}.log")))
                    {
                        PipelineSelections.Add(new PipelineSelection
                        {
                            Name = "All Pipelines (Legacy)",
                            SanitizedName = "pipelines",
                            IsSelected = false
                        });
                    }

                    var pipelineLogFiles = Directory.GetFiles(logPath, "pipeline_*.log")
                        .Select(Path.GetFileNameWithoutExtension)
                        .Where(f => f != null && f.StartsWith("pipeline_"))
                        .Select(f => f!.Substring("pipeline_".Length))
                        .Distinct();

                    foreach (var logName in pipelineLogFiles)
                    {
                        if (!_pipelineNameMapping.Values.Contains(logName))
                        {
                            var displayName = $"{logName} (Archived)";
                            AvailablePipelines.Add(displayName);
                            _pipelineNameMapping[displayName] = logName;

                            PipelineSelections.Add(new PipelineSelection
                            {
                                Name = displayName,
                                SanitizedName = logName,
                                IsSelected = false
                            });
                        }
                    }
                }

                // Listen for selection changes
                foreach (var selection in PipelineSelections)
                {
                    selection.PropertyChanged += OnPipelineSelectionChanged;
                }

                // Update initial count
                OnPropertyChanged(nameof(SelectedPipelineCount));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to load available pipelines");
            }
        }

        private async Task RefreshLogsAsync()
        {
            try
            {
                IsLoading = true;

                // Get selected pipelines
                var selectedPipelines = PipelineSelections.Where(p => p.IsSelected).ToList();
                if (!selectedPipelines.Any())
                {
                    CombinedLogEntries.Clear();
                    CurrentLogFiles = "No pipelines selected";
                    return;
                }

                // Update current files display
                CurrentLogFiles = string.Join(", ", selectedPipelines.Select(p => p.Name));

                // Collect all log entries from selected pipelines
                var allEntries = new List<LogEntry>();

                foreach (var pipeline in selectedPipelines)
                {
                    var logFileName = GetLogFileName(pipeline.Name);
                    var logPath = Path.Combine(ConfigurationPaths.GetLogsDirectory(), logFileName);

                    if (File.Exists(logPath))
                    {
                        // Read entries from this pipeline
                        var entries = await ReadLogFileAsync(logPath, pipeline.Name);
                        allEntries.AddRange(entries);
                    }
                }

                // Sort all entries by timestamp (millisecond precision)
                var sortedEntries = allEntries
                    .OrderBy(e => e.Timestamp)
                    .TakeLast(MaxDisplayedEntries)
                    .ToList();

                // Update collection efficiently (minimize UI updates)
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    // For auto-scroll, append only new entries to prevent flicker
                    if (IsAutoScrollEnabled && CombinedLogEntries.Count > 0)
                    {
                        // Find the last timestamp we have
                        var lastTimestamp = CombinedLogEntries.Last().Timestamp;

                        // Add only newer entries
                        var newEntries = sortedEntries
                            .Where(e => e.Timestamp > lastTimestamp)
                            .ToList();

                        foreach (var entry in newEntries)
                        {
                            CombinedLogEntries.Add(entry);

                            // Maintain max entries
                            if (CombinedLogEntries.Count > MaxDisplayedEntries)
                                CombinedLogEntries.RemoveAt(0);
                        }
                    }
                    else
                    {
                        // Full refresh when not auto-scrolling
                        CombinedLogEntries.Clear();
                        foreach (var entry in sortedEntries)
                        {
                            CombinedLogEntries.Add(entry);
                        }
                    }
                });

                TotalLineCount = CombinedLogEntries.Count;
                LastUpdateTime = DateTime.Now;
                ApplyFilters();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to refresh logs");
            }
            finally
            {
                IsLoading = false;
            }
        }

        private async Task<List<LogEntry>> ReadLogFileAsync(string logPath, string sourcePipeline)
        {
            var entries = new List<LogEntry>();

            try
            {
                _logger.LogInformation("Reading log file: {Path} for pipeline: {Pipeline}", logPath, sourcePipeline);

                using (var fs = new FileStream(logPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var reader = new StreamReader(fs, Encoding.UTF8))
                {
                    string? line;
                    int lineCount = 0;
                    int parsedCount = 0;

                    while ((line = await reader.ReadLineAsync()) != null)
                    {
                        lineCount++;
                        var entry = ParseLogLine(line);
                        if (entry != null)
                        {
                            entry.Source = sourcePipeline; // Tag with source
                            entries.Add(entry);
                            parsedCount++;
                        }
                    }

                    _logger.LogInformation("Read {Lines} lines, parsed {Parsed} entries from {File}",
                        lineCount, parsedCount, Path.GetFileName(logPath));
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to read log file: {LogPath}", logPath);
            }

            return entries;
        }

        private async Task ReadTailAsync(string logPath, int lineCount)
        {
            try
            {
                var lines = new List<string>();

                using (var fs = new FileStream(logPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var reader = new StreamReader(fs, Encoding.UTF8))
                {
                    // Efficient tail reading
                    var buffer = new Queue<string>(lineCount);
                    string? line;

                    while ((line = await reader.ReadLineAsync()) != null)
                    {
                        if (buffer.Count >= lineCount)
                            buffer.Dequeue();
                        buffer.Enqueue(line);
                    }

                    lines.AddRange(buffer);
                    _filePositions[logPath] = fs.Position;
                }

                // Parse and add entries
                LogEntries.Clear();
                foreach (var line in lines)
                {
                    var entry = ParseLogLine(line);
                    if (entry != null)
                        LogEntries.Add(entry);
                }

                TotalLineCount = LogEntries.Count;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to read tail of log file: {LogPath}", logPath);
            }
        }

        private async Task ReadNewLinesAsync(string logPath, long lastPosition)
        {
            try
            {
                using (var fs = new FileStream(logPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    // If file was truncated, reset
                    if (fs.Length < lastPosition)
                    {
                        await ReadTailAsync(logPath, TailLineCount);
                        return;
                    }

                    fs.Seek(lastPosition, SeekOrigin.Begin);
                    using (var reader = new StreamReader(fs, Encoding.UTF8))
                    {
                        string? line;
                        var newEntries = new List<LogEntry>();

                        while ((line = await reader.ReadLineAsync()) != null)
                        {
                            var entry = ParseLogLine(line);
                            if (entry != null)
                                newEntries.Add(entry);
                        }

                        // Add new entries and maintain max count
                        foreach (var entry in newEntries)
                        {
                            LogEntries.Add(entry);
                            if (LogEntries.Count > MaxDisplayedEntries)
                                LogEntries.RemoveAt(0);
                        }

                        _filePositions[logPath] = fs.Position;
                        TotalLineCount = LogEntries.Count;
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to read new lines from log file: {LogPath}", logPath);
            }
        }

        private LogEntry? ParseLogLine(string line)
        {
            if (string.IsNullOrWhiteSpace(line))
                return null;

            try
            {
                // Serilog format: [HH:mm:ss LVL] Message
                // Example: [14:23:45 INF] Pipeline Radiology started
                // Flexibleres Pattern fÃ¼r verschiedene Level-LÃ¤ngen (INF, INFO, ERR, ERROR etc.)
                var match = Regex.Match(line, @"^\[(\d{2}:\d{2}:\d{2})\s+(\w+)\]\s+(.+)$");

                if (match.Success)
                {
                    var timeStr = match.Groups[1].Value;
                    var levelStr = match.Groups[2].Value;
                    var message = match.Groups[3].Value;

                    // Parse timestamp - handle with or without milliseconds
                    DateTime timestamp;
                    if (timeStr.Contains('.'))
                    {
                        timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss.fff", CultureInfo.InvariantCulture);
                    }
                    else
                    {
                        timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss", CultureInfo.InvariantCulture);
                    }

                    // Add today's date
                    timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

                    var level = ParseLogLevel(levelStr);

                    return new LogEntry
                    {
                        Timestamp = timestamp,
                        Level = level,
                        Message = message,
                        RawLine = line
                    };
                }
                else
                {
                    // Try alternative format without brackets
                    // Example: 2025-06-22 14:23:45 [INF] Message
                    match = Regex.Match(line, @"^(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\s+\[(\w{3})\]\s+(.+)$");

                    if (match.Success)
                    {
                        var dateTimeStr = match.Groups[1].Value;
                        var levelStr = match.Groups[2].Value;
                        var message = match.Groups[3].Value;

                        var timestamp = DateTime.Parse(dateTimeStr);
                        var level = ParseLogLevel(levelStr);

                        return new LogEntry
                        {
                            Timestamp = timestamp,
                            Level = level,
                            Message = message,
                            RawLine = line
                        };
                    }

                    // Fallback for non-standard format
                    _logger.LogDebug("Could not parse log line format: {Line}", line);
                    return new LogEntry
                    {
                        Timestamp = DateTime.Now,
                        Level = LogLevel.Information,
                        Message = line,
                        RawLine = line
                    };
                }
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to parse log line: {Line}", line);
                // Return the line as-is
                return new LogEntry
                {
                    Timestamp = DateTime.Now,
                    Level = LogLevel.Information,
                    Message = line,
                    RawLine = line
                };
            }
        }

        private LogLevel ParseLogLevel(string levelStr)
        {
            return levelStr.ToUpperInvariant() switch
            {
                "DBG" or "DEB" or "DEBUG" => LogLevel.Debug,
                "INF" or "INFO" or "INFORMATION" => LogLevel.Information,
                "WRN" or "WARN" or "WARNING" => LogLevel.Warning,
                "ERR" or "ERROR" => LogLevel.Error,
                "CRT" or "CRIT" or "CRITICAL" or "FTL" or "FATAL" => LogLevel.Critical,
                _ => LogLevel.Information  // Default to Information instead of failing
            };
        }

        private void ClearLogs()
        {
            LogEntries.Clear();
            CombinedLogEntries.Clear();
            FilteredCombinedEntries.Clear();
            TotalLineCount = 0;
            _filePositions.Clear();
        }

        private async Task ExportLogsAsync()
        {
            try
            {
                // Create export dialog
                var dialog = new Microsoft.Win32.SaveFileDialog
                {
                    Filter = "Log files (*.log)|*.log|Text files (*.txt)|*.txt|All files (*.*)|*.*",
                    DefaultExt = ".log",
                    FileName = $"CamBridge_Export_{DateTime.Now:yyyyMMdd_HHmmss}.log"
                };

                if (dialog.ShowDialog() == true)
                {
                    var lines = FilteredCombinedEntries.Select(e => e.RawLine ?? e.Message);
                    await File.WriteAllLinesAsync(dialog.FileName, lines, Encoding.UTF8);

                    _logger.LogInformation("Exported {Count} log entries to {FileName}",
                        FilteredCombinedEntries.Count, dialog.FileName);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to export logs");
            }
        }

        private string GetLogFileName(string pipelineSelection)
        {
            var today = DateTime.Now.ToString("yyyyMMdd");

            if (pipelineSelection == "Service (Global)")
            {
                return $"service_{today}.log";
            }

            if (pipelineSelection == "All Pipelines (Legacy)")
            {
                return $"pipelines_{today}.log";
            }

            // Get sanitized name from mapping
            if (_pipelineNameMapping.TryGetValue(pipelineSelection, out var sanitizedName))
            {
                return $"pipeline_{sanitizedName}_{today}.log";
            }

            // Fallback - sanitize the selection directly
            var safeName = SanitizeForFileName(pipelineSelection.Replace(" (Archived)", ""));
            return $"pipeline_{safeName}_{today}.log";
        }

        private string SanitizeForFileName(string pipelineName)
        {
            // Replace invalid filename characters and common separators
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(new[] { ' ', '.', ',', '/', '\\', ':', '-' })
                .Distinct()
                .ToArray();

            var sanitized = string.Join("_", pipelineName.Split(invalid, StringSplitOptions.RemoveEmptyEntries));

            // Limit length
            if (sanitized.Length > 100)
            {
                sanitized = sanitized.Substring(0, 97) + "...";
            }

            return sanitized;
        }

        private void OnRefreshTimer(object? state)
        {
            if (IsAutoScrollEnabled && !IsLoading)
            {
                _ = RefreshLogsAsync();
            }
        }

        private void OnPipelineSelectionChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(PipelineSelection.IsSelected))
            {
                // Update count
                OnPropertyChanged(nameof(SelectedPipelineCount));

                // Update current files display
                var selectedNames = PipelineSelections.Where(p => p.IsSelected).Select(p => p.Name).ToList();
                CurrentLogFiles = selectedNames.Any()
                    ? string.Join(", ", selectedNames)
                    : "No pipelines selected";

                // Refresh logs with new selection
                _ = RefreshLogsAsync();
            }
        }

        partial void OnSearchTextChanged(string? value)
        {
            // Debounce search to avoid too many updates
            ApplyFilters();
        }

        partial void OnShowDebugChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowInformationChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowWarningChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowErrorChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowCriticalChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }
    }

    /// <summary>
    /// Represents a single log entry with metadata
    /// </summary>
    public class LogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogLevel Level { get; set; }
        public string Message { get; set; } = string.Empty;
        public string? RawLine { get; set; }
        public string Source { get; set; } = string.Empty; // Which pipeline this came from

        // UI Helper Properties
        public string LevelText => Level switch
        {
            LogLevel.Debug => "DBG",
            LogLevel.Information => "INF",
            LogLevel.Warning => "WRN",
            LogLevel.Error => "ERR",
            LogLevel.Critical => "CRT",
            _ => "???"
        };

        public string LevelColor => Level switch
        {
            LogLevel.Debug => "#808080",      // Gray
            LogLevel.Information => "#0078D4", // Blue
            LogLevel.Warning => "#FFA500",     // Orange
            LogLevel.Error => "#FF0000",       // Red
            LogLevel.Critical => "#8B0000",    // Dark Red
            _ => "#000000"
        };
    }
}


================================================================================
FILE: ViewModels/MainViewModel.cs
--------------------------------------------------------------------------------
Size: 377 bytes | Lines: 13 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\ViewModels\MainViewModel.cs
// Version: 0.6.8
// Description: Main view model with correct version
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

namespace CamBridge.Config.ViewModels
{
    public class MainViewModel : ViewModelBase
    {
        public string Title => "CamBridge Configuration v0.6.8";
    }
}


================================================================================
FILE: ViewModels/MappingEditorViewModel.cs
--------------------------------------------------------------------------------
Size: 47,99 KB | Lines: 1190 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Config/ViewModels/MappingEditorViewModel.cs
// Version: 0.7.26
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-18
// Status: Development/Local - Transform Editor Enhanced

using CamBridge.Config.Dialogs;
using CamBridge.Config.Extensions;
using CamBridge.Config.Services;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using CamBridge.Core.ValueObjects;
using CamBridge.Infrastructure.Services;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Win32;
using ModernWpf.Controls;
using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

// Alias to avoid ambiguity with FellowOakDicom.DicomTag
using DicomTag = CamBridge.Core.ValueObjects.DicomTag;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// ViewModel for the mapping editor with multiple mapping sets support
    /// </summary>
    public partial class MappingEditorViewModel : ViewModelBase
    {
        private readonly ILogger<MappingEditorViewModel> _logger;
        private readonly IConfigurationService _configurationService;
        private IMappingConfiguration? _mappingConfiguration;
        private bool _isInitialized = false;

        #region Properties

        // Mapping Sets
        [ObservableProperty] private ObservableCollection<MappingSet> _mappingSets = new();
        [ObservableProperty] private MappingSet? _selectedMappingSet;
        [ObservableProperty] private bool _canEditCurrentSet = true;

        // Mapping Rules
        [ObservableProperty] private ObservableCollection<MappingRuleViewModel> _mappingRules = new();
        [ObservableProperty] private MappingRuleViewModel? _selectedRule;

        // Preview
        [ObservableProperty] private string? _previewInput;
        [ObservableProperty] private string? _previewOutput;

        // State
        [ObservableProperty] private bool _isModified;
        [ObservableProperty] private string? _statusMessage;
        [ObservableProperty] private bool _isLoading;
        [ObservableProperty] private bool _isError;

        // Save feedback
        [ObservableProperty] private bool _showSaveSuccess;
        private System.Windows.Threading.DispatcherTimer? _saveSuccessTimer;

        // Available source fields
        public ObservableCollection<SourceFieldInfo> QRBridgeFields { get; } = new();
        public ObservableCollection<SourceFieldInfo> ExifFields { get; } = new();

        #endregion

        public MappingEditorViewModel(
            ILogger<MappingEditorViewModel> logger,
            IConfigurationService configurationService)
        {
            _logger = logger;
            _configurationService = configurationService;

            InitializeSourceFields();
            StatusMessage = "Ready";
        }

        /// <summary>
        /// Initialize the ViewModel - call this from the View's Loaded event
        /// </summary>
        public async Task InitializeAsync()
        {
            if (_isInitialized) return;

            try
            {
                IsLoading = true;
                StatusMessage = "Initializing mapping editor...";

                // Create MappingConfigurationLoader with proper logger
                var nullLoggerFactory = new NullLoggerFactory();
                var mappingLoaderLogger = nullLoggerFactory.CreateLogger<MappingConfigurationLoader>();
                _mappingConfiguration = new MappingConfigurationLoader(mappingLoaderLogger);

                // Load mapping sets
                await LoadMappingSetsAsync();

                _isInitialized = true;
                StatusMessage = "Mapping editor ready";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to initialize mapping editor");
                StatusMessage = "Initialization failed";
                MessageBox.Show(
                    $"Failed to initialize mapping editor:\n{ex.Message}",
                    "Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        #region Initialization

        private void InitializeSourceFields()
        {
            // QRBridge fields (from QR code data)
            QRBridgeFields.Add(new SourceFieldInfo("examid", "Examination ID", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("name", "Patient Name", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("birthdate", "Birth Date", "date"));
            QRBridgeFields.Add(new SourceFieldInfo("gender", "Gender", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("comment", "Comment", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("patientid", "Patient ID", "string"));

            // EXIF fields (from image metadata)
            ExifFields.Add(new SourceFieldInfo("Make", "Camera Manufacturer", "string"));
            ExifFields.Add(new SourceFieldInfo("Model", "Camera Model", "string"));
            ExifFields.Add(new SourceFieldInfo("DateTimeOriginal", "Capture Date/Time", "datetime"));
            ExifFields.Add(new SourceFieldInfo("Software", "Software Version", "string"));
            ExifFields.Add(new SourceFieldInfo("ImageDescription", "Image Description", "string"));
        }

        private async Task LoadMappingSetsAsync()
        {
            try
            {
                IsLoading = true;
                IsError = false;
                StatusMessage = "Loading mapping sets...";

                // IMMER zuerst System Defaults laden - sie sind die Basis!
                LoadSystemDefaults();
                _logger.LogInformation("Loaded system default mapping sets");

                // Try to load v2 settings
                var settingsV2 = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();

                if (settingsV2 != null && settingsV2.MappingSets.Count > 0)
                {
                    // Add user sets from v2 settings
                    foreach (var set in settingsV2.MappingSets.Where(s => !s.IsSystemDefault))
                    {
                        MappingSets.Add(set);
                    }
                    _logger.LogInformation($"Loaded {settingsV2.MappingSets.Count(s => !s.IsSystemDefault)} user mapping sets from settings");
                }

                // Debug: Log all loaded sets
                _logger.LogInformation($"Total mapping sets loaded: {MappingSets.Count}");
                foreach (var set in MappingSets)
                {
                    _logger.LogInformation($"  - {set.Name} (System: {set.IsSystemDefault}, Rules: {set.Rules?.Count ?? 0})");
                }

                // Select appropriate set - prefer Ricoh for initial experience
                var ricohSet = MappingSets.FirstOrDefault(s => s.Name.Contains("Ricoh", StringComparison.OrdinalIgnoreCase));
                SelectedMappingSet = ricohSet ?? MappingSets.FirstOrDefault();

                StatusMessage = $"Loaded {MappingSets.Count} mapping sets";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading mapping sets");
                StatusMessage = "Failed to load mapping sets";
                IsError = true;

                // Even on error, ensure system defaults are available
                if (MappingSets.Count == 0)
                {
                    LoadSystemDefaults();
                }
                SelectedMappingSet = MappingSets.FirstOrDefault();
            }
            finally
            {
                IsLoading = false;
            }
        }

        private void LoadSystemDefaults()
        {
            // Ricoh G900 Standard Set
            var ricohSet = new MappingSet
            {
                Id = Guid.Parse("00000000-0000-0000-0000-000000000001"),
                Name = "[System] Ricoh G900 Standard",
                Description = "Standard mapping for Ricoh G900 II cameras",
                IsSystemDefault = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                Rules = new List<MappingRule>
                {
                    // Patient identification
                    new() { SourceField = "name", DicomTag = "(0010,0010)", Description = "Patient Name",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "patientid", DicomTag = "(0010,0020)", Description = "Patient ID",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "birthdate", DicomTag = "(0010,0030)", Description = "Patient Birth Date",
                            SourceType = "QRBridge", Transform = "DateToDicom" },
                    new() { SourceField = "gender", DicomTag = "(0010,0040)", Description = "Patient Sex",
                            SourceType = "QRBridge", Transform = "MapGender" },
                    
                    // Study information
                    new() { SourceField = "examid", DicomTag = "(0020,0010)", Description = "Study ID",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "comment", DicomTag = "(0008,1030)", Description = "Study Description",
                            SourceType = "QRBridge", Transform = "None" },
                    
                    // Image date/time from EXIF
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0020)", Description = "Study Date",
                            SourceType = "EXIF", Transform = "ExtractDate" },
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0030)", Description = "Study Time",
                            SourceType = "EXIF", Transform = "ExtractTime" },
                    
                    // Equipment info
                    new() { SourceField = "Make", DicomTag = "(0008,0070)", Description = "Manufacturer",
                            SourceType = "EXIF", Transform = "None" },
                    new() { SourceField = "Model", DicomTag = "(0008,1090)", Description = "Manufacturer Model Name",
                            SourceType = "EXIF", Transform = "None" }
                }
            };

            // Minimal Required Set
            var minimalSet = new MappingSet
            {
                Id = Guid.Parse("00000000-0000-0000-0000-000000000002"),
                Name = "[System] Minimal Required",
                Description = "Only the required DICOM fields",
                IsSystemDefault = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                Rules = new List<MappingRule>
                {
                    new() { SourceField = "name", DicomTag = "(0010,0010)", Description = "Patient Name",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "patientid", DicomTag = "(0010,0020)", Description = "Patient ID",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "examid", DicomTag = "(0020,0010)", Description = "Study ID",
                            SourceType = "QRBridge", Transform = "None" }
                }
            };

            // Full Comprehensive Set
            var fullSet = new MappingSet
            {
                Id = Guid.Parse("00000000-0000-0000-0000-000000000003"),
                Name = "[System] Full Comprehensive",
                Description = "Comprehensive mapping with all standard fields",
                IsSystemDefault = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                Rules = new List<MappingRule>
                {
                    // Patient Module
                    new() { SourceField = "name", DicomTag = "(0010,0010)", Description = "Patient Name",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "patientid", DicomTag = "(0010,0020)", Description = "Patient ID",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "birthdate", DicomTag = "(0010,0030)", Description = "Patient Birth Date",
                            SourceType = "QRBridge", Transform = "DateToDicom" },
                    new() { SourceField = "gender", DicomTag = "(0010,0040)", Description = "Patient Sex",
                            SourceType = "QRBridge", Transform = "MapGender" },
                    new() { SourceField = "comment", DicomTag = "(0010,4000)", Description = "Patient Comments",
                            SourceType = "QRBridge", Transform = "None" },
                    
                    // Study Module
                    new() { SourceField = "examid", DicomTag = "(0020,0010)", Description = "Study ID",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "examid", DicomTag = "(0008,0050)", Description = "Accession Number",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "comment", DicomTag = "(0008,1030)", Description = "Study Description",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0020)", Description = "Study Date",
                            SourceType = "EXIF", Transform = "ExtractDate" },
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0030)", Description = "Study Time",
                            SourceType = "EXIF", Transform = "ExtractTime" },
                    
                    // Equipment Module
                    new() { SourceField = "Make", DicomTag = "(0008,0070)", Description = "Manufacturer",
                            SourceType = "EXIF", Transform = "None" },
                    new() { SourceField = "Model", DicomTag = "(0008,1090)", Description = "Manufacturer Model Name",
                            SourceType = "EXIF", Transform = "None" },
                    new() { SourceField = "Software", DicomTag = "(0018,1020)", Description = "Software Versions",
                            SourceType = "EXIF", Transform = "None" },
                    
                    // Image Module
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,002A)", Description = "Acquisition DateTime",
                            SourceType = "EXIF", Transform = "DateTimeToDicom" }
                }
            };

            MappingSets.Add(ricohSet);
            MappingSets.Add(minimalSet);
            MappingSets.Add(fullSet);
        }

        private MappingRuleViewModel CreateRuleViewModel(MappingRule rule)
        {
            var vm = new MappingRuleViewModel(rule);

            // Attach property changed handler
            vm.PropertyChanged += (s, e) =>
            {
                // Avoid recursive updates
                if (!IsLoading)
                {
                    IsModified = true;
                    if (s == SelectedRule && e.PropertyName != nameof(MappingRuleViewModel.DisplayName))
                    {
                        UpdatePreview();
                    }
                }
            };

            return vm;
        }

        #endregion

        #region Mapping Set Commands

        [RelayCommand]
        private async Task AddMappingSetAsync()
        {
            var newSet = new MappingSet
            {
                Name = $"New Mapping Set {DateTime.Now:HHmmss}",
                Description = "Custom mapping configuration",
                Rules = new List<MappingRule>(),
                IsSystemDefault = false,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            MappingSets.Add(newSet);
            SelectedMappingSet = newSet;
            IsModified = true;
            StatusMessage = $"Created new mapping set: {newSet.Name}";
        }

        [RelayCommand(CanExecute = nameof(CanDuplicateMappingSet))]
        private async Task DuplicateMappingSetAsync()
        {
            if (SelectedMappingSet == null) return;

            var duplicate = new MappingSet
            {
                Name = $"{SelectedMappingSet.Name} (Copy)",
                Description = SelectedMappingSet.Description,
                Rules = SelectedMappingSet.Rules.Select(r => new MappingRule
                {
                    SourceField = r.SourceField,
                    DicomTag = r.DicomTag,
                    Description = r.Description,
                    SourceType = r.SourceType,
                    Transform = r.Transform,
                    Required = r.Required,
                    DefaultValue = r.DefaultValue
                }).ToList(),
                IsSystemDefault = false,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            MappingSets.Add(duplicate);
            SelectedMappingSet = duplicate;
            IsModified = true;
            StatusMessage = $"Duplicated mapping set: {duplicate.Name}";
        }

        private bool CanDuplicateMappingSet() => SelectedMappingSet != null;

        [RelayCommand(CanExecute = nameof(CanDeleteMappingSet))]
        private async Task DeleteMappingSetAsync()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            var result = MessageBox.Show(
                $"Delete mapping set '{SelectedMappingSet.Name}'?\n\nThis action cannot be undone.",
                "Confirm Delete",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question);

            if (result == MessageBoxResult.Yes)
            {
                var setName = SelectedMappingSet.Name;
                MappingSets.Remove(SelectedMappingSet);
                SelectedMappingSet = MappingSets.FirstOrDefault();
                IsModified = true;
                StatusMessage = $"Deleted mapping set: {setName}";
            }
        }

        private bool CanDeleteMappingSet() => SelectedMappingSet != null && !SelectedMappingSet.IsSystemDefault;

        #endregion

        #region Rule Commands

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void AddRule()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            var newRule = new MappingRule
            {
                SourceField = "Select a field...",
                DicomTag = "(0010,0010)",
                Description = "New Mapping Rule",
                SourceType = "QRBridge",
                Transform = ValueTransform.None.ToString(),
                Required = false
            };

            var vm = CreateRuleViewModel(newRule);
            MappingRules.Add(vm);
            SelectedRule = vm;

            // Update the set's rules
            SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
            SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

            IsModified = true;
            StatusMessage = "Added new mapping rule - drag a source field to configure";
        }

        [RelayCommand]
        private void RemoveRule(MappingRuleViewModel? rule)
        {
            if (rule != null && SelectedMappingSet != null && !SelectedMappingSet.IsSystemDefault)
            {
                MappingRules.Remove(rule);

                // Update the set's rules
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                SelectedRule = MappingRules.FirstOrDefault();
                StatusMessage = "Removed mapping rule";
            }
        }

        [RelayCommand(CanExecute = nameof(CanMoveRuleUp))]
        private void MoveRuleUp()
        {
            if (SelectedRule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var index = MappingRules.IndexOf(SelectedRule);
            if (index > 0)
            {
                MappingRules.Move(index, index - 1);

                // Update the set's rules
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
            }
        }

        private bool CanMoveRuleUp() => SelectedRule != null && CanEditCurrentSet && MappingRules.IndexOf(SelectedRule) > 0;

        [RelayCommand(CanExecute = nameof(CanMoveRuleDown))]
        private void MoveRuleDown()
        {
            if (SelectedRule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var index = MappingRules.IndexOf(SelectedRule);
            if (index < MappingRules.Count - 1)
            {
                MappingRules.Move(index, index + 1);

                // Update the set's rules
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
            }
        }

        private bool CanMoveRuleDown() => SelectedRule != null && CanEditCurrentSet && MappingRules.IndexOf(SelectedRule) < MappingRules.Count - 1;

        #endregion

        #region Transform Edit Command

        [RelayCommand(CanExecute = nameof(CanEditTransform))]
        private async void EditTransform(MappingRuleViewModel? rule)
        {
            if (rule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var dialog = new TransformEditorDialog();

            dialog.SetMapping(rule.SourceField, rule.DicomTagString, rule.Transform);

            var result = await dialog.ShowAsync();
            if (result == ContentDialogResult.Primary)
            {
                // Update the transform
                rule.Transform = dialog.SelectedTransform;

                // Update the set
                if (SelectedMappingSet != null)
                {
                    SelectedMappingSet.UpdatedAt = DateTime.UtcNow;
                    IsModified = true;
                }

                StatusMessage = $"Transform updated for {rule.SourceField}";
            }
        }

        private bool CanEditTransform(MappingRuleViewModel? rule) => rule != null && CanEditCurrentSet;

        #endregion

        #region Save/Load Commands

        [RelayCommand]
        private async Task SaveMappingsAsync()
        {
            try
            {
                IsLoading = true;
                StatusMessage = "Saving mapping sets...";

                // Update rules in selected set if it's not read-only
                if (SelectedMappingSet != null && !SelectedMappingSet.IsSystemDefault)
                {
                    SelectedMappingSet.Rules = MappingRules.Select(vm => vm.ToMappingRule()).ToList();
                    SelectedMappingSet.UpdatedAt = DateTime.UtcNow;
                }

                // Load current v2 settings or create new
                var settingsV2 = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>()
                                 ?? new CamBridgeSettingsV2();

                // Update mapping sets - nur User Sets speichern!
                settingsV2.MappingSets = MappingSets.Where(s => !s.IsSystemDefault).ToList();

                // Save
                await _configurationService.SaveConfigurationAsync(settingsV2);

                IsModified = false;
                StatusMessage = "Mapping sets saved successfully";

                // Show save success feedback
                ShowSaveSuccess = true;

                // Hide after 3 seconds
                if (_saveSuccessTimer == null)
                {
                    _saveSuccessTimer = new System.Windows.Threading.DispatcherTimer
                    {
                        Interval = TimeSpan.FromSeconds(3)
                    };
                    _saveSuccessTimer.Tick += (s, e) =>
                    {
                        ShowSaveSuccess = false;
                        _saveSuccessTimer.Stop();
                    };
                }
                _saveSuccessTimer.Start();

                _logger.LogInformation($"Saved {settingsV2.MappingSets.Count} user mapping sets");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to save mapping sets");
                StatusMessage = "Failed to save mapping sets";
                MessageBox.Show($"Error saving mapping sets: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task ImportMappingsAsync()
        {
            try
            {
                var dialog = new OpenFileDialog
                {
                    Title = "Import Mapping Configuration",
                    Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                    DefaultExt = ".json"
                };

                if (dialog.ShowDialog() == true)
                {
                    IsLoading = true;
                    StatusMessage = "Importing mappings...";

                    // Read file content
                    var jsonContent = await File.ReadAllTextAsync(dialog.FileName);

                    // Try to deserialize as array of MappingRule
                    var rules = System.Text.Json.JsonSerializer.Deserialize<List<MappingRule>>(jsonContent);

                    if (rules != null && rules.Count > 0)
                    {
                        // Create new set from imported rules
                        var importedSet = new MappingSet
                        {
                            Name = $"Imported from {Path.GetFileName(dialog.FileName)}",
                            Description = $"Imported on {DateTime.Now:yyyy-MM-dd HH:mm}",
                            Rules = rules,
                            IsSystemDefault = false,
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow
                        };

                        MappingSets.Add(importedSet);
                        SelectedMappingSet = importedSet;
                        IsModified = true;
                        StatusMessage = $"Imported {rules.Count} mapping rules";

                        MessageBox.Show($"Successfully imported {rules.Count} mapping rules.", "Import Successful",
                            MessageBoxButton.OK, MessageBoxImage.Information);
                    }
                    else
                    {
                        StatusMessage = "No mapping rules found in file";
                        MessageBox.Show("No valid mapping rules found in the selected file.", "Import Failed",
                            MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to import mappings");
                MessageBox.Show($"Error importing mappings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanExportMappings))]
        private async Task ExportMappingsAsync()
        {
            if (SelectedMappingSet == null) return;

            try
            {
                var dialog = new SaveFileDialog
                {
                    Title = "Export Mapping Configuration",
                    Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                    DefaultExt = ".json",
                    FileName = $"{SelectedMappingSet.Name.Replace("[System]", "").Trim()}_{DateTime.Now:yyyyMMdd_HHmmss}.json"
                };

                if (dialog.ShowDialog() == true)
                {
                    IsLoading = true;
                    StatusMessage = "Exporting mappings...";

                    // Serialize rules to JSON
                    var jsonOptions = new System.Text.Json.JsonSerializerOptions
                    {
                        WriteIndented = true,
                        PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase
                    };

                    var json = System.Text.Json.JsonSerializer.Serialize(SelectedMappingSet.Rules, jsonOptions);
                    await File.WriteAllTextAsync(dialog.FileName, json);

                    StatusMessage = $"Exported {SelectedMappingSet.Rules.Count} rules to {Path.GetFileName(dialog.FileName)}";

                    MessageBox.Show($"Successfully exported {SelectedMappingSet.Rules.Count} mapping rules.", "Export Successful",
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to export mappings");
                MessageBox.Show($"Error exporting mappings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        private bool CanExportMappings() => SelectedMappingSet != null;

        [RelayCommand]
        private async Task TestMappingAsync()
        {
            if (SelectedMappingSet == null)
            {
                MessageBox.Show("Please select a mapping set to test", "No Mapping Set",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                IsLoading = true;
                StatusMessage = "Testing mapping configuration...";

                // Create test data
                var testData = new System.Collections.Generic.Dictionary<string, string>
                {
                    { "examid", "TEST001" },
                    { "name", "Test, Patient" },
                    { "birthdate", "1990-01-15" },
                    { "gender", "M" },
                    { "comment", "Test mapping" },
                    { "patientid", "PAT001" },
                    { "Make", "RICOH" },
                    { "Model", "G900 II" },
                    { "DateTimeOriginal", DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss") },
                    { "Software", "CamBridge Test" }
                };

                var results = new System.Text.StringBuilder();
                results.AppendLine($"Testing Mapping Set: {SelectedMappingSet.Name}");
                results.AppendLine($"Rules: {SelectedMappingSet.Rules.Count}");
                results.AppendLine();

                int successCount = 0;
                int errorCount = 0;

                foreach (var rule in SelectedMappingSet.Rules)
                {
                    try
                    {
                        if (testData.TryGetValue(rule.SourceField, out var sourceValue))
                        {
                            var transformedValue = rule.ApplyTransform(sourceValue);
                            results.AppendLine($"âœ” {rule.SourceField} â†’ {rule.DicomTag}: '{transformedValue}'");
                            successCount++;
                        }
                        else
                        {
                            results.AppendLine($"âš  {rule.SourceField}: No test data available");
                        }
                    }
                    catch (Exception ex)
                    {
                        results.AppendLine($"âœ— {rule.SourceField}: Error - {ex.Message}");
                        errorCount++;
                    }
                }

                results.AppendLine();
                results.AppendLine($"Summary: {successCount} successful, {errorCount} errors");

                // Show results
                MessageBox.Show(results.ToString(), "Mapping Test Results",
                    MessageBoxButton.OK,
                    errorCount > 0 ? MessageBoxImage.Warning : MessageBoxImage.Information);

                StatusMessage = $"Test completed: {successCount} successful, {errorCount} errors";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to test mappings");
                MessageBox.Show($"Error testing mappings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanBrowseDicomTags))]
        private void BrowseDicomTags()
        {
            if (SelectedRule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var dialog = new DicomTagBrowserDialog
            {
                Owner = Application.Current.MainWindow
            };

            if (dialog.ShowDialog() == true && dialog.SelectedTag != null)
            {
                // Convert DicomTag object to string format
                SelectedRule.DicomTagString = dialog.SelectedTag.ToString();
                UpdatePreview();

                // Update the set
                if (SelectedMappingSet != null)
                {
                    SelectedMappingSet.UpdatedAt = DateTime.UtcNow;
                    IsModified = true;
                }
            }
        }

        private bool CanBrowseDicomTags() => SelectedRule != null && CanEditCurrentSet;

        #endregion

        #region Template Commands

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void ApplyRicohTemplate()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            if (MessageBox.Show(
                "This will replace all current mappings with the Ricoh G900 II template. Continue?",
                "Apply Template",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question) != MessageBoxResult.Yes)
            {
                return;
            }

            // Find the Ricoh system template
            var ricohTemplate = MappingSets.FirstOrDefault(s => s.Name.Contains("Ricoh") && s.IsSystemDefault);
            if (ricohTemplate != null)
            {
                MappingRules.Clear();
                foreach (var rule in ricohTemplate.Rules)
                {
                    // Create copies of the rules
                    var newRule = new MappingRule
                    {
                        SourceField = rule.SourceField,
                        DicomTag = rule.DicomTag,
                        Description = rule.Description,
                        SourceType = rule.SourceType,
                        Transform = rule.Transform,
                        Required = rule.Required,
                        DefaultValue = rule.DefaultValue
                    };
                    var vm = CreateRuleViewModel(newRule);
                    MappingRules.Add(vm);
                }

                // Update the set
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                StatusMessage = "Ricoh template applied";
            }
        }

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void ApplyMinimalTemplate()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            if (MessageBox.Show(
                "This will replace all current mappings with a minimal template. Continue?",
                "Apply Template",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question) != MessageBoxResult.Yes)
            {
                return;
            }

            // Find the minimal system template
            var minimalTemplate = MappingSets.FirstOrDefault(s => s.Name.Contains("Minimal") && s.IsSystemDefault);
            if (minimalTemplate != null)
            {
                MappingRules.Clear();
                foreach (var rule in minimalTemplate.Rules)
                {
                    // Create copies of the rules
                    var newRule = new MappingRule
                    {
                        SourceField = rule.SourceField,
                        DicomTag = rule.DicomTag,
                        Description = rule.Description,
                        SourceType = rule.SourceType,
                        Transform = rule.Transform,
                        Required = rule.Required,
                        DefaultValue = rule.DefaultValue
                    };
                    var vm = CreateRuleViewModel(newRule);
                    MappingRules.Add(vm);
                }

                // Update the set
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                StatusMessage = "Minimal template applied";
            }
        }

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void ApplyFullTemplate()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            if (MessageBox.Show(
                "This will replace all current mappings with a comprehensive template. Continue?",
                "Apply Template",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question) != MessageBoxResult.Yes)
            {
                return;
            }

            // Find the full system template
            var fullTemplate = MappingSets.FirstOrDefault(s => s.Name.Contains("Full") && s.IsSystemDefault);
            if (fullTemplate != null)
            {
                MappingRules.Clear();
                foreach (var rule in fullTemplate.Rules)
                {
                    // Create copies of the rules
                    var newRule = new MappingRule
                    {
                        SourceField = rule.SourceField,
                        DicomTag = rule.DicomTag,
                        Description = rule.Description,
                        SourceType = rule.SourceType,
                        Transform = rule.Transform,
                        Required = rule.Required,
                        DefaultValue = rule.DefaultValue
                    };
                    var vm = CreateRuleViewModel(newRule);
                    MappingRules.Add(vm);
                }

                // Update the set
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                StatusMessage = "Full template applied";
            }
        }

        #endregion

        #region Drag & Drop Support

        /// <summary>
        /// Add a new rule from a dropped field
        /// </summary>
        public void AddRuleFromField(SourceFieldInfo fieldInfo)
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            // Determine appropriate DICOM tag based on field
            string dicomTag = fieldInfo.FieldName switch
            {
                "name" => "(0010,0010)",          // Patient Name
                "patientid" => "(0010,0020)",     // Patient ID
                "birthdate" => "(0010,0030)",     // Patient Birth Date
                "gender" => "(0010,0040)",        // Patient Sex
                "examid" => "(0020,0010)",        // Study ID
                "comment" => "(0008,1030)",       // Study Description
                "Make" => "(0008,0070)",          // Manufacturer
                "Model" => "(0008,1090)",         // Model Name
                "DateTimeOriginal" => "(0008,0020)", // Study Date
                "Software" => "(0018,1020)",      // Software Version
                _ => "(0010,0010)"                // Default to Patient Name
            };

            // Determine transform based on field type
            ValueTransform transform = fieldInfo.FieldName switch
            {
                "birthdate" => ValueTransform.DateToDicom,
                "gender" => ValueTransform.MapGender,
                "DateTimeOriginal" when dicomTag == "(0008,0020)" => ValueTransform.ExtractDate,
                "DateTimeOriginal" when dicomTag == "(0008,0030)" => ValueTransform.ExtractTime,
                _ => ValueTransform.None
            };

            var newRule = new MappingRule
            {
                SourceField = fieldInfo.FieldName,
                DicomTag = dicomTag,
                Description = fieldInfo.DisplayName,
                SourceType = QRBridgeFields.Contains(fieldInfo) ? "QRBridge" : "EXIF",
                Transform = transform.ToString(),
                Required = fieldInfo.FieldName == "name" || fieldInfo.FieldName == "patientid"
            };

            var vm = CreateRuleViewModel(newRule);
            MappingRules.Add(vm);
            SelectedRule = vm;

            // Update the set's rules
            SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
            SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

            IsModified = true;
            StatusMessage = $"Added mapping for {fieldInfo.DisplayName}";
        }

        #endregion

        #region Preview

        public void UpdatePreview()
        {
            if (SelectedRule == null || string.IsNullOrWhiteSpace(PreviewInput))
            {
                PreviewOutput = string.Empty;
                return;
            }

            try
            {
                var rule = SelectedRule.ToMappingRule();
                PreviewOutput = rule.ApplyTransform(PreviewInput);
            }
            catch (Exception ex)
            {
                PreviewOutput = $"Error: {ex.Message}";
            }
        }

        partial void OnPreviewInputChanged(string? value)
        {
            UpdatePreview();
        }

        partial void OnSelectedRuleChanged(MappingRuleViewModel? value)
        {
            UpdatePreview();

            // Update command states
            BrowseDicomTagsCommand.NotifyCanExecuteChanged();
            MoveRuleUpCommand.NotifyCanExecuteChanged();
            MoveRuleDownCommand.NotifyCanExecuteChanged();
            EditTransformCommand.NotifyCanExecuteChanged();
        }

        partial void OnSelectedMappingSetChanged(MappingSet? value)
        {
            if (value == null) return;

            CanEditCurrentSet = !value.IsSystemDefault;
            LoadRulesFromSet(value);

            // Update command states
            DuplicateMappingSetCommand.NotifyCanExecuteChanged();
            DeleteMappingSetCommand.NotifyCanExecuteChanged();
            AddRuleCommand.NotifyCanExecuteChanged();
            MoveRuleUpCommand.NotifyCanExecuteChanged();
            MoveRuleDownCommand.NotifyCanExecuteChanged();
            BrowseDicomTagsCommand.NotifyCanExecuteChanged();
            ExportMappingsCommand.NotifyCanExecuteChanged();
            ApplyRicohTemplateCommand.NotifyCanExecuteChanged();
            ApplyMinimalTemplateCommand.NotifyCanExecuteChanged();
            ApplyFullTemplateCommand.NotifyCanExecuteChanged();
            EditTransformCommand.NotifyCanExecuteChanged();
        }

        private void LoadRulesFromSet(MappingSet set)
        {
            IsLoading = true;
            try
            {
                MappingRules.Clear();

                if (set.Rules != null)
                {
                    foreach (var rule in set.Rules)
                    {
                        var vm = CreateRuleViewModel(rule);
                        MappingRules.Add(vm);
                    }

                    StatusMessage = $"Loaded {set.Rules.Count} rules from '{set.Name}'";
                }
                else
                {
                    StatusMessage = $"Selected '{set.Name}' (no rules defined)";
                }
            }
            finally
            {
                IsLoading = false;
            }
        }

        #endregion

        #region Inner Classes

        public class SourceFieldInfo
        {
            public string FieldName { get; }
            public string DisplayName { get; }
            public string DataType { get; }

            public SourceFieldInfo(string fieldName, string displayName, string dataType)
            {
                FieldName = fieldName;
                DisplayName = displayName;
                DataType = dataType;
            }
        }

        #endregion
    }

    /// <summary>
    /// ViewModel wrapper for MappingRule
    /// </summary>
    public partial class MappingRuleViewModel : ObservableObject
    {
        private readonly MappingRule _rule;

        // UI-friendly properties that map to Core properties
        [ObservableProperty] private string _displayName;
        [ObservableProperty] private string _sourceType;
        [ObservableProperty] private string _sourceField;
        [ObservableProperty] private string _dicomTagString;
        [ObservableProperty] private ValueTransform _transform;
        [ObservableProperty] private bool _isRequired;
        [ObservableProperty] private string? _defaultValue;

        public MappingRuleViewModel(MappingRule rule)
        {
            _rule = rule;

            // Map Core properties to UI properties
            _displayName = rule.Description ?? $"{rule.SourceType}.{rule.SourceField}";
            _sourceType = rule.SourceType ?? "QRBridge";
            _sourceField = rule.SourceField;
            _dicomTagString = rule.DicomTag;
            _transform = Enum.TryParse<ValueTransform>(rule.Transform, out var t) ? t : ValueTransform.None;
            _isRequired = rule.Required;
            _defaultValue = rule.DefaultValue;
        }

        public MappingRule ToMappingRule()
        {
            // Update Core rule with UI values
            _rule.Description = DisplayName;
            _rule.SourceType = SourceType;
            _rule.SourceField = SourceField;
            _rule.DicomTag = DicomTagString;
            _rule.Transform = Transform.ToString();
            _rule.Required = IsRequired;
            _rule.DefaultValue = DefaultValue;

            return _rule;
        }

        partial void OnDicomTagStringChanged(string value)
        {
            // Validate DICOM tag format
            try
            {
                var tag = DicomTag.Parse(value);
                // Valid tag
            }
            catch
            {
                // Invalid tag format - could show error in UI
            }
        }
    }
}


================================================================================
FILE: ViewModels/PipelineConfigViewModel.cs
--------------------------------------------------------------------------------
Size: 24,40 KB | Lines: 649 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\ViewModels\PipelineConfigViewModel.cs
// Version: 0.7.27
// Description: Pipeline Configuration ViewModel - Improved Status & Layout

using CamBridge.Config.Services;
using CamBridge.Core;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Runtime.Versioning;
using System.Threading.Tasks;
using System.Windows;
using System.Diagnostics;

namespace CamBridge.Config.ViewModels
{
    [SupportedOSPlatform("windows")]
    public partial class PipelineConfigViewModel : ViewModelBase
    {
        private readonly IConfigurationService _configurationService;
        private CamBridgeSettingsV2? _originalSettings;

        // Collections
        [ObservableProperty]
        private ObservableCollection<PipelineConfiguration> _pipelines = new();

        [ObservableProperty]
        private ObservableCollection<MappingSet> _mappingSets = new();

        // Selected Pipeline
        private PipelineConfiguration? _selectedPipeline;
        public PipelineConfiguration? SelectedPipeline
        {
            get => _selectedPipeline;
            set
            {
                if (SetProperty(ref _selectedPipeline, value))
                {
                    Debug.WriteLine($"SelectedPipeline changed to: {value?.Name ?? "null"}");
                    OnPropertyChanged(nameof(SelectedPipelineDicomOverrides));
                    OnPropertyChanged(nameof(UseCustomLogging));
                    OnPropertyChanged(nameof(UseCustomNotifications));
                    UpdateCommands();
                }
            }
        }

        // Pipeline-specific properties for binding
        public DicomOverrides? SelectedPipelineDicomOverrides
        {
            get
            {
                if (SelectedPipeline?.DicomOverrides == null && SelectedPipeline != null)
                {
                    SelectedPipeline.DicomOverrides = new DicomOverrides();
                }
                return SelectedPipeline?.DicomOverrides;
            }
        }

        // ComboBox Collections
        public ObservableCollection<string> LogLevels { get; } = new()
        {
            "Trace", "Debug", "Information", "Warning", "Error", "Critical"
        };

        public ObservableCollection<PostProcessingAction> ProcessingActions { get; } = new()
        {
            PostProcessingAction.Leave,
            PostProcessingAction.Archive,
            PostProcessingAction.Delete,
            PostProcessingAction.MoveToError
        };

        public ObservableCollection<OutputOrganization> OutputOrganizations { get; } = new()
        {
            OutputOrganization.None,
            OutputOrganization.ByPatient,
            OutputOrganization.ByDate,
            OutputOrganization.ByPatientAndDate
        };

        public ObservableCollection<NotificationLevel> NotificationLevels { get; } = new()
        {
            NotificationLevel.Information,
            NotificationLevel.Warning,
            NotificationLevel.Error,
            NotificationLevel.Critical
        };

        // Pipeline-specific logging settings
        [ObservableProperty]
        private bool _useCustomLogging;

        [ObservableProperty]
        private string _pipelineLogLevel = "Information";

        [ObservableProperty]
        private string _pipelineLogFolder = @"C:\CamBridge\Logs";

        [ObservableProperty]
        private int _pipelineLogRetentionDays = 30;

        // Pipeline-specific notification settings
        [ObservableProperty]
        private bool _useCustomNotifications;

        [ObservableProperty]
        private string? _pipelineEmailTo;

        [ObservableProperty]
        private NotificationLevel _pipelineAlertLevel = NotificationLevel.Warning;

        [ObservableProperty]
        private bool _pipelineSendDailySummary;

        [ObservableProperty]
        private bool _pipelineAlertOnErrors = true;

        // Status properties
        [ObservableProperty]
        private bool _isLoading;

        [ObservableProperty]
        private bool _isSaving;

        [ObservableProperty]
        private string _statusMessage = "";

        [ObservableProperty]
        private bool _isError;

        [ObservableProperty]
        private bool _hasUnsavedChanges;

        [ObservableProperty]
        private int _unsavedChangesCount;

        [ObservableProperty]
        private bool _selectedPipelineHasChanges;

        public PipelineConfigViewModel(IConfigurationService configurationService)
        {
            _configurationService = configurationService;
            Debug.WriteLine("PipelineConfigViewModel constructor called");

            // Subscribe to collection changes
            Pipelines.CollectionChanged += (s, e) =>
            {
                Debug.WriteLine($"Pipelines collection changed: Count = {Pipelines.Count}");
                if (!IsLoading)
                {
                    HasUnsavedChanges = true;
                    UnsavedChangesCount++;
                }
            };
        }

        public async Task InitializeAsync()
        {
            Debug.WriteLine("=== PipelineConfigViewModel.InitializeAsync START ===");
            try
            {
                await LoadSettingsAsync();

                // Ensure we have at least one pipeline
                if (Pipelines.Count == 0)
                {
                    Debug.WriteLine("No pipelines loaded, creating default");
                    CreateDefaultPipeline();
                }

                Debug.WriteLine($"InitializeAsync completed. Pipeline count: {Pipelines.Count}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"InitializeAsync FAILED: {ex.Message}");
                Debug.WriteLine($"Stack: {ex.StackTrace}");
                StatusMessage = $"Error: {ex.Message}";
                IsError = true;

                // Create default pipeline even on error
                CreateDefaultPipeline();
            }
            finally
            {
                Debug.WriteLine("=== PipelineConfigViewModel.InitializeAsync END ===");
            }
        }

        [RelayCommand]
        private async Task LoadSettingsAsync()
        {
            Debug.WriteLine("LoadSettingsAsync called");
            try
            {
                IsLoading = true;
                IsError = false;
                StatusMessage = "";

                Debug.WriteLine("Calling ConfigurationService.LoadConfigurationAsync<CamBridgeSettingsV2>");
                var settings = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();

                if (settings != null)
                {
                    Debug.WriteLine($"Settings loaded: Version={settings.Version}, Pipelines={settings.Pipelines.Count}");
                    _originalSettings = settings;
                    MapFromSettings(settings);

                    // Create system default mapping sets if needed
                    EnsureSystemDefaults();

                    HasUnsavedChanges = false;
                    UnsavedChangesCount = 0;
                    StatusMessage = "";  // Clear status - pipeline count shown in header
                }
                else
                {
                    Debug.WriteLine("Settings is null - creating default pipeline");
                    // Create default settings
                    CreateDefaultPipeline();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"LoadSettingsAsync ERROR: {ex.Message}");
                Debug.WriteLine($"Exception type: {ex.GetType().Name}");
                StatusMessage = $"Error: {ex.Message}";
                IsError = true;

                // Ensure we have at least one pipeline
                if (Pipelines.Count == 0)
                {
                    CreateDefaultPipeline();
                }
            }
            finally
            {
                IsLoading = false;
                Debug.WriteLine($"LoadSettingsAsync completed. Pipelines count: {Pipelines.Count}");
            }
        }

        [RelayCommand(CanExecute = nameof(CanSaveAll))]
        private async Task SaveAllAsync()
        {
            try
            {
                IsSaving = true;
                IsError = false;
                StatusMessage = "Saving all pipelines...";

                var settings = MapToSettings();
                await _configurationService.SaveConfigurationAsync(settings);

                _originalSettings = settings;
                HasUnsavedChanges = false;
                UnsavedChangesCount = 0;
                SelectedPipelineHasChanges = false;

                // Show save confirmation briefly
                StatusMessage = $"Saved at {DateTime.Now:HH:mm:ss}";

                // Clear status message after 3 seconds
                _ = Task.Run(async () =>
                {
                    await Task.Delay(3000);
                    StatusMessage = "";
                });

                // Notify success
                var backupPath = System.IO.Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                    "CamBridge",
                    $"appsettings.json.backup_{DateTime.Now:yyyyMMdd_HHmmss}");

                MessageBox.Show($"Pipeline configuration saved successfully!\n\nAuto-backup created at:\n{backupPath}",
                               "Success",
                               MessageBoxButton.OK,
                               MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                StatusMessage = $"Error: {ex.Message}";
                IsError = true;

                MessageBox.Show($"Failed to save configuration:\n{ex.Message}",
                               "Error",
                               MessageBoxButton.OK,
                               MessageBoxImage.Error);
            }
            finally
            {
                IsSaving = false;
            }
        }

        private bool CanSaveAll() => HasUnsavedChanges && !IsLoading && !IsSaving;

        [RelayCommand]
        private void AddPipeline()
        {
            Debug.WriteLine("AddPipeline called");

            var newPipeline = new PipelineConfiguration
            {
                Id = Guid.NewGuid(),
                Name = $"Pipeline {Pipelines.Count + 1}",
                Description = "New pipeline configuration",
                Enabled = true,
                WatchSettings = new PipelineWatchSettings
                {
                    Path = @"C:\CamBridge\NewPipeline\Input",
                    FilePattern = "*.jpg;*.jpeg",
                    IncludeSubdirectories = false,
                    MinimumFileAgeSeconds = 5
                },
                ProcessingOptions = new ProcessingOptions
                {
                    ArchiveFolder = @"C:\CamBridge\NewPipeline\Archive",
                    ErrorFolder = @"C:\CamBridge\NewPipeline\Errors",
                    DeadLetterFolder = @"C:\CamBridge\NewPipeline\DeadLetters",
                    SuccessAction = PostProcessingAction.Archive,
                    FailureAction = PostProcessingAction.MoveToError,
                    CreateBackup = true,
                    BackupFolder = @"C:\CamBridge\NewPipeline\Backup",
                    MaxConcurrentProcessing = 2,
                    RetryOnFailure = true,
                    MaxRetryAttempts = 3,
                    OutputOrganization = OutputOrganization.ByPatientAndDate
                },
                MappingSetId = MappingSets.FirstOrDefault(m => !m.IsSystemDefault)?.Id
            };

            // Subscribe to property changes
            newPipeline.PropertyChanged += Pipeline_PropertyChanged;
            newPipeline.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
            newPipeline.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;

            // Add to collection
            Pipelines.Add(newPipeline);
            SelectedPipeline = newPipeline;

            HasUnsavedChanges = true;
            UnsavedChangesCount++;

            Debug.WriteLine($"Pipeline added. Total count: {Pipelines.Count}");
        }

        [RelayCommand(CanExecute = nameof(CanDeletePipeline))]
        private void DeletePipeline()
        {
            if (SelectedPipeline == null) return;

            var result = MessageBox.Show(
                $"Are you sure you want to delete the pipeline '{SelectedPipeline.Name}'?\n\nThis action cannot be undone.",
                "Confirm Delete",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);

            if (result == MessageBoxResult.Yes)
            {
                var pipelineName = SelectedPipeline.Name;
                Pipelines.Remove(SelectedPipeline);
                SelectedPipeline = Pipelines.FirstOrDefault();

                HasUnsavedChanges = true;
                UnsavedChangesCount++;
            }
        }

        private bool CanDeletePipeline() => SelectedPipeline != null && Pipelines.Count > 1;

        [RelayCommand(CanExecute = nameof(CanApplyPipeline))]
        private void ApplyPipeline()
        {
            if (SelectedPipeline == null) return;

            // Mark changes as applied
            SelectedPipelineHasChanges = false;
        }

        private bool CanApplyPipeline() => SelectedPipelineHasChanges && !IsLoading && !IsSaving;

        [RelayCommand(CanExecute = nameof(CanResetPipeline))]
        private void ResetPipeline()
        {
            if (SelectedPipeline == null || _originalSettings == null) return;

            // Find original pipeline by ID
            var originalPipeline = _originalSettings.Pipelines.FirstOrDefault(p => p.Id == SelectedPipeline.Id);
            if (originalPipeline != null)
            {
                // Reset to original values
                var index = Pipelines.IndexOf(SelectedPipeline);
                if (index >= 0)
                {
                    var cloned = ClonePipeline(originalPipeline);
                    cloned.PropertyChanged += Pipeline_PropertyChanged;
                    cloned.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
                    cloned.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;

                    Pipelines[index] = cloned;
                    SelectedPipeline = Pipelines[index];
                }
            }

            SelectedPipelineHasChanges = false;
        }

        private bool CanResetPipeline() => SelectedPipelineHasChanges && !IsLoading && !IsSaving;

        private void MapFromSettings(CamBridgeSettingsV2 settings)
        {
            Debug.WriteLine($"MapFromSettings called. Settings has {settings.Pipelines.Count} pipelines, {settings.MappingSets.Count} mapping sets");

            // Clear existing
            Pipelines.Clear();
            MappingSets.Clear();

            // Map mapping sets
            foreach (var mappingSet in settings.MappingSets)
            {
                MappingSets.Add(mappingSet);
                Debug.WriteLine($"Added mapping set: {mappingSet.Name}");
            }

            // Map pipelines
            foreach (var pipeline in settings.Pipelines)
            {
                var clonedPipeline = ClonePipeline(pipeline);

                // Subscribe to property changes
                clonedPipeline.PropertyChanged += Pipeline_PropertyChanged;
                clonedPipeline.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
                clonedPipeline.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;

                Pipelines.Add(clonedPipeline);
                Debug.WriteLine($"Added pipeline: {clonedPipeline.Name}");
            }

            // Select first pipeline
            SelectedPipeline = Pipelines.FirstOrDefault();
            Debug.WriteLine($"Selected first pipeline: {SelectedPipeline?.Name ?? "none"}");
        }

        private void Pipeline_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (!IsLoading)
            {
                SelectedPipelineHasChanges = true;
                HasUnsavedChanges = true;
                Debug.WriteLine($"Pipeline property changed: {e.PropertyName}");
            }
        }

        private CamBridgeSettingsV2 MapToSettings()
        {
            var settings = new CamBridgeSettingsV2
            {
                Version = "2.0",
                GlobalDicomSettings = _originalSettings?.GlobalDicomSettings ?? new DicomSettings(),
                DefaultProcessingOptions = _originalSettings?.DefaultProcessingOptions ?? new ProcessingOptions(),
                Logging = _originalSettings?.Logging ?? new LoggingSettings(),
                Service = _originalSettings?.Service ?? new ServiceSettings(),
                Notifications = _originalSettings?.Notifications ?? new NotificationSettings()
            };

            // Map pipelines
            settings.Pipelines.Clear();
            foreach (var pipeline in Pipelines)
            {
                settings.Pipelines.Add(ClonePipeline(pipeline));
            }

            // Map mapping sets
            settings.MappingSets.Clear();
            foreach (var mappingSet in MappingSets)
            {
                settings.MappingSets.Add(mappingSet);
            }

            return settings;
        }

        private PipelineConfiguration ClonePipeline(PipelineConfiguration source)
        {
            return new PipelineConfiguration
            {
                Id = source.Id,
                Name = source.Name,
                Description = source.Description,
                Enabled = source.Enabled,
                WatchSettings = new PipelineWatchSettings
                {
                    Path = source.WatchSettings.Path,
                    FilePattern = source.WatchSettings.FilePattern,
                    IncludeSubdirectories = source.WatchSettings.IncludeSubdirectories,
                    OutputPath = source.WatchSettings.OutputPath,
                    MinimumFileAgeSeconds = source.WatchSettings.MinimumFileAgeSeconds
                },
                ProcessingOptions = CloneProcessingOptions(source.ProcessingOptions),
                DicomOverrides = source.DicomOverrides != null ? new DicomOverrides
                {
                    InstitutionName = source.DicomOverrides.InstitutionName,
                    InstitutionDepartment = source.DicomOverrides.InstitutionDepartment,
                    StationName = source.DicomOverrides.StationName
                } : null,
                MappingSetId = source.MappingSetId,
                CreatedAt = source.CreatedAt,
                UpdatedAt = DateTime.UtcNow
            };
        }

        private ProcessingOptions CloneProcessingOptions(ProcessingOptions source)
        {
            return new ProcessingOptions
            {
                SuccessAction = source.SuccessAction,
                FailureAction = source.FailureAction,
                ArchiveFolder = source.ArchiveFolder,
                ErrorFolder = source.ErrorFolder,
                BackupFolder = source.BackupFolder,
                CreateBackup = source.CreateBackup,
                MaxConcurrentProcessing = source.MaxConcurrentProcessing,
                RetryOnFailure = source.RetryOnFailure,
                MaxRetryAttempts = source.MaxRetryAttempts,
                OutputOrganization = source.OutputOrganization,
                ProcessExistingOnStartup = source.ProcessExistingOnStartup,
                DeadLetterFolder = source.DeadLetterFolder
            };
        }

        private void CreateDefaultPipeline()
        {
            Debug.WriteLine("CreateDefaultPipeline called");

            // Don't clear if we already have pipelines
            if (Pipelines.Count > 0)
            {
                Debug.WriteLine($"Already have {Pipelines.Count} pipelines, not creating default");
                return;
            }

            // Clear mapping sets if needed
            MappingSets.Clear();

            // Create default mapping set
            var defaultMappingSet = new MappingSet
            {
                Id = Guid.NewGuid(),
                Name = "Default Mapping",
                Description = "Default EXIF to DICOM mapping",
                IsSystemDefault = false,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            MappingSets.Add(defaultMappingSet);

            // Create default pipeline
            var defaultPipeline = new PipelineConfiguration
            {
                Id = Guid.NewGuid(),
                Name = "Default Pipeline",
                Description = "Default processing pipeline",
                Enabled = true,
                WatchSettings = new PipelineWatchSettings
                {
                    Path = @"C:\CamBridge\Watch\Default",
                    FilePattern = "*.jpg;*.jpeg",
                    IncludeSubdirectories = false,
                    OutputPath = @"C:\CamBridge\Output\Default",
                    MinimumFileAgeSeconds = 5
                },
                ProcessingOptions = new ProcessingOptions
                {
                    ArchiveFolder = @"C:\CamBridge\Archive",
                    ErrorFolder = @"C:\CamBridge\Errors",
                    DeadLetterFolder = @"C:\CamBridge\DeadLetters",
                    SuccessAction = PostProcessingAction.Archive,
                    FailureAction = PostProcessingAction.MoveToError,
                    CreateBackup = true,
                    BackupFolder = @"C:\CamBridge\Backup",
                    MaxConcurrentProcessing = 2,
                    RetryOnFailure = true,
                    MaxRetryAttempts = 3,
                    OutputOrganization = OutputOrganization.ByPatientAndDate,
                    ProcessExistingOnStartup = false
                },
                MappingSetId = defaultMappingSet.Id,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            defaultPipeline.PropertyChanged += Pipeline_PropertyChanged;
            defaultPipeline.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
            defaultPipeline.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;

            Pipelines.Add(defaultPipeline);
            SelectedPipeline = defaultPipeline;

            Debug.WriteLine($"Default pipeline created. Pipelines count: {Pipelines.Count}");
        }

        private void EnsureSystemDefaults()
        {
            // Check if we have system default mapping sets
            if (!MappingSets.Any(m => m.IsSystemDefault))
            {
                // Add Ricoh Standard as system default
                var ricohStandard = new MappingSet
                {
                    Id = Guid.Parse("00000000-0000-0000-0000-000000000001"),
                    Name = "[System] Ricoh Standard",
                    Description = "Built-in mapping for Ricoh cameras",
                    IsSystemDefault = true,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };

                MappingSets.Insert(0, ricohStandard);
                Debug.WriteLine("Added system default mapping set: Ricoh Standard");
            }
        }

        private void UpdateCommands()
        {
            DeletePipelineCommand.NotifyCanExecuteChanged();
            ApplyPipelineCommand.NotifyCanExecuteChanged();
            ResetPipelineCommand.NotifyCanExecuteChanged();
        }

        // Handle property changes
        protected override void OnPropertyChanged(PropertyChangedEventArgs e)
        {
            base.OnPropertyChanged(e);

            // Update save command when changes occur
            if (e.PropertyName == nameof(HasUnsavedChanges))
            {
                SaveAllCommand.NotifyCanExecuteChanged();
            }
        }
    }
}


================================================================================
FILE: ViewModels/PipelineStatusViewModel.cs
--------------------------------------------------------------------------------
Size: 2,93 KB | Lines: 99 | Modified: 2025-06-23 11:53:05
================================================================================

/**************************************************************************
*  PipelineStatusViewModel.cs                                             *
*  PATH: src\CamBridge.Config\ViewModels\PipelineStatusViewModel.cs      *
*  VERSION: 0.7.11 | SIZE: ~2.5KB | MODIFIED: 2025-06-13                 *
*                                                                         *
*  DESCRIPTION: ViewModel for individual pipeline status display          *
*  Copyright (c) 2025 Claude's Improbably Reliable Software Solutions     *
**************************************************************************/

using CommunityToolkit.Mvvm.ComponentModel;
using System;

namespace CamBridge.Config.ViewModels
{
    public partial class PipelineStatusViewModel : ObservableObject
    {
        private Guid _pipelineId;
        private string _pipelineName = string.Empty;
        private bool _isEnabled;
        private string _status = "Unknown";
        private int _processedToday;
        private int _errorsToday;
        private int _queueLength;
        private double _successRate;
        private DateTime? _lastProcessed;
        private string _watchFolder = string.Empty;

        public Guid PipelineId
        {
            get => _pipelineId;
            set => SetProperty(ref _pipelineId, value);
        }

        public string PipelineName
        {
            get => _pipelineName;
            set => SetProperty(ref _pipelineName, value);
        }

        public bool IsEnabled
        {
            get => _isEnabled;
            set => SetProperty(ref _isEnabled, value);
        }

        public string Status
        {
            get => _status;
            set => SetProperty(ref _status, value);
        }

        public int ProcessedToday
        {
            get => _processedToday;
            set => SetProperty(ref _processedToday, value);
        }

        public int ErrorsToday
        {
            get => _errorsToday;
            set => SetProperty(ref _errorsToday, value);
        }

        public int QueueLength
        {
            get => _queueLength;
            set => SetProperty(ref _queueLength, value);
        }

        public double SuccessRate
        {
            get => _successRate;
            set => SetProperty(ref _successRate, value);
        }

        public DateTime? LastProcessed
        {
            get => _lastProcessed;
            set => SetProperty(ref _lastProcessed, value);
        }

        public string WatchFolder
        {
            get => _watchFolder;
            set => SetProperty(ref _watchFolder, value);
        }

        public string StatusColor => Status switch
        {
            "Processing" => "#4CAF50",
            "Active" => "#2196F3",
            "Idle" => "#FFC107",
            "Disabled" => "#9E9E9E",
            "Error" => "#F44336",
            _ => "#9E9E9E"
        };
    }
}


================================================================================
FILE: ViewModels/RecentActivityViewModel.cs
--------------------------------------------------------------------------------
Size: 1,67 KB | Lines: 50 | Modified: 2025-06-23 11:53:05
================================================================================

/**************************************************************************
*  RecentActivityViewModel.cs                                             *
*  PATH: src\CamBridge.Config\ViewModels\RecentActivityViewModel.cs      *
*  VERSION: 0.7.11 | SIZE: ~1.3KB | MODIFIED: 2025-06-13                 *
*                                                                         *
*  DESCRIPTION: ViewModel for recent activity display                     *
*  Copyright (c) 2025 Claude's Improbably Reliable Software Solutions     *
**************************************************************************/

using CommunityToolkit.Mvvm.ComponentModel;
using System;

namespace CamBridge.Config.ViewModels
{
    public partial class RecentActivityViewModel : ObservableObject
    {
        private bool _isSuccess;
        private string _message = string.Empty;
        private DateTime _timestamp;
        private string _pipelineName = string.Empty;

        public bool IsSuccess
        {
            get => _isSuccess;
            set => SetProperty(ref _isSuccess, value);
        }

        public string Message
        {
            get => _message;
            set => SetProperty(ref _message, value);
        }

        public DateTime Timestamp
        {
            get => _timestamp;
            set => SetProperty(ref _timestamp, value);
        }

        public string PipelineName
        {
            get => _pipelineName;
            set => SetProperty(ref _pipelineName, value);
        }

        public string StatusIcon => IsSuccess ? "âœ“" : "âœ—";
        public string StatusColor => IsSuccess ? "#4CAF50" : "#F44336";
    }
}


================================================================================
FILE: ViewModels/ServiceControlViewModel.cs
--------------------------------------------------------------------------------
Size: 17,35 KB | Lines: 534 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Config/ViewModels/ServiceControlViewModel.cs
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using CamBridge.Config.Services;

namespace CamBridge.Config.ViewModels
{
    public partial class ServiceControlViewModel : ViewModelBase
    {
        private readonly IServiceManager _serviceManager;
        private Timer? _statusTimer;

        [ObservableProperty]
        private ServiceStatus serviceStatus = ServiceStatus.Unknown;

        [ObservableProperty]
        private string statusText = "Checking...";

        [ObservableProperty]
        private string statusColor = "Gray";

        [ObservableProperty]
        private bool canStart = false;

        [ObservableProperty]
        private bool canStop = false;

        [ObservableProperty]
        private bool canRestart = false;

        [ObservableProperty]
        private bool isServiceInstalled = false;

        [ObservableProperty]
        private string? uptime;

        [ObservableProperty]
        private bool requiresElevation = false;

        public ServiceControlViewModel(IServiceManager serviceManager)
        {
            _serviceManager = serviceManager ?? throw new ArgumentNullException(nameof(serviceManager));

            // Start monitoring
            _ = InitializeAsync();
        }

        private async Task InitializeAsync()
        {
            // Check if running as admin
            RequiresElevation = !_serviceManager.IsRunningAsAdministrator();

            // Initial status check
            await RefreshStatusAsync();

            // Start periodic updates
            _statusTimer = new Timer(
                async _ => await RefreshStatusAsync(),
                null,
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(2));
        }

        [RelayCommand]
        private async Task RefreshStatusAsync()
        {
            try
            {
                // Check if service is installed
                IsServiceInstalled = await _serviceManager.IsServiceInstalledAsync();

                if (!IsServiceInstalled)
                {
                    ServiceStatus = ServiceStatus.Unknown;
                    StatusText = "Service Not Installed";
                    StatusColor = "Red";
                    UpdateButtons();
                    return;
                }

                // Get current status
                ServiceStatus = await _serviceManager.GetServiceStatusAsync();
                UpdateStatusDisplay();
                UpdateButtons();

                // Get uptime if running
                if (ServiceStatus == ServiceStatus.Running)
                {
                    var startTime = await _serviceManager.GetServiceStartTimeAsync();
                    if (startTime.HasValue)
                    {
                        var uptimeSpan = DateTime.Now - startTime.Value;
                        Uptime = FormatUptime(uptimeSpan);
                    }
                }
                else
                {
                    Uptime = null;
                }
            }
            catch (Exception ex)
            {
                StatusText = $"Error: {ex.Message}";
                StatusColor = "Red";
            }
        }

        [RelayCommand]
        private async Task InstallServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Installing the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            IsLoading = true;

            try
            {
                StatusText = "Installing service...";
                StatusColor = "Orange";

                var success = await _serviceManager.InstallServiceAsync();

                if (success)
                {
                    StatusText = "Service installed successfully";
                    StatusColor = "Green";

                    // Wait a moment for the service to be fully registered
                    await Task.Delay(1000);

                    // Refresh status to update UI
                    await RefreshStatusAsync();

                    MessageBox.Show(
                        "CamBridge Service has been installed successfully!\n\n" +
                        "You can now start the service using the Start button.",
                        "Installation Complete",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
                }
                else
                {
                    StatusText = "Failed to install service";
                    StatusColor = "Red";

                    MessageBox.Show(
                        "Failed to install the CamBridge Service.\n\n" +
                        "Please check the Event Viewer for more details.",
                        "Installation Failed",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                StatusText = "Installation error";
                StatusColor = "Red";

                MessageBox.Show(
                    $"An error occurred while installing the service:\n\n{ex.Message}",
                    "Installation Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task UninstallServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Uninstalling the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            var confirmResult = MessageBox.Show(
                "Are you sure you want to uninstall the CamBridge Service?\n\n" +
                "This will permanently remove the service from your system.",
                "Confirm Uninstall",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);

            if (confirmResult != MessageBoxResult.Yes)
                return;

            IsLoading = true;

            try
            {
                // Stop service first if running
                if (ServiceStatus == ServiceStatus.Running)
                {
                    StatusText = "Stopping service before uninstall...";
                    StatusColor = "Orange";
                    await _serviceManager.StopServiceAsync();
                    await Task.Delay(2000); // Wait for service to stop
                }

                StatusText = "Uninstalling service...";
                StatusColor = "Orange";

                var success = await _serviceManager.UninstallServiceAsync();

                if (success)
                {
                    StatusText = "Service uninstalled";
                    StatusColor = "Gray";

                    // Wait a moment for the service to be fully removed
                    await Task.Delay(1000);

                    // Refresh status to update UI
                    await RefreshStatusAsync();

                    MessageBox.Show(
                        "CamBridge Service has been uninstalled successfully.",
                        "Uninstall Complete",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
                }
                else
                {
                    StatusText = "Failed to uninstall service";
                    StatusColor = "Red";

                    MessageBox.Show(
                        "Failed to uninstall the CamBridge Service.\n\n" +
                        "Please check the Event Viewer for more details.",
                        "Uninstall Failed",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                StatusText = "Uninstall error";
                StatusColor = "Red";

                MessageBox.Show(
                    $"An error occurred while uninstalling the service:\n\n{ex.Message}",
                    "Uninstall Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task StartServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Starting the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            IsLoading = true;
            CanStart = false;

            try
            {
                StatusText = "Starting service...";
                StatusColor = "Orange";

                var success = await _serviceManager.StartServiceAsync();

                if (success)
                {
                    StatusText = "Service started successfully";
                    StatusColor = "Green";
                }
                else
                {
                    StatusText = "Failed to start service";
                    StatusColor = "Red";
                }

                await RefreshStatusAsync();
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task StopServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Stopping the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            var confirmResult = MessageBox.Show(
                "Are you sure you want to stop the CamBridge Service? This will halt all file processing.",
                "Confirm Stop",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question);

            if (confirmResult != MessageBoxResult.Yes)
                return;

            IsLoading = true;
            CanStop = false;

            try
            {
                StatusText = "Stopping service...";
                StatusColor = "Orange";

                var success = await _serviceManager.StopServiceAsync();

                if (success)
                {
                    StatusText = "Service stopped";
                    StatusColor = "Gray";
                }
                else
                {
                    StatusText = "Failed to stop service";
                    StatusColor = "Red";
                }

                await RefreshStatusAsync();
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task RestartServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Restarting the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            IsLoading = true;
            CanRestart = false;

            try
            {
                StatusText = "Restarting service...";
                StatusColor = "Orange";

                var success = await _serviceManager.RestartServiceAsync();

                if (success)
                {
                    StatusText = "Service restarted successfully";
                    StatusColor = "Green";
                }
                else
                {
                    StatusText = "Failed to restart service";
                    StatusColor = "Red";
                }

                await RefreshStatusAsync();
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private void OpenServices()
        {
            try
            {
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "services.msc",
                    UseShellExecute = true
                };
                System.Diagnostics.Process.Start(processInfo);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to open Services: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private void OpenEventViewer()
        {
            try
            {
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "eventvwr.msc",
                    UseShellExecute = true
                };
                System.Diagnostics.Process.Start(processInfo);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to open Event Viewer: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void UpdateStatusDisplay()
        {
            (StatusText, StatusColor) = ServiceStatus switch
            {
                ServiceStatus.Running => ("Running", "Green"),
                ServiceStatus.Stopped => ("Stopped", "Gray"),
                ServiceStatus.Starting => ("Starting...", "Orange"),
                ServiceStatus.Stopping => ("Stopping...", "Orange"),
                _ => ("Unknown", "Red")
            };
        }

        private void UpdateButtons()
        {
            CanStart = IsServiceInstalled && ServiceStatus == ServiceStatus.Stopped && !IsLoading;
            CanStop = IsServiceInstalled && ServiceStatus == ServiceStatus.Running && !IsLoading;
            CanRestart = IsServiceInstalled && ServiceStatus == ServiceStatus.Running && !IsLoading;
        }

        private string FormatUptime(TimeSpan uptime)
        {
            if (uptime.TotalDays >= 1)
                return $"{(int)uptime.TotalDays}d {uptime.Hours}h {uptime.Minutes}m";
            else if (uptime.TotalHours >= 1)
                return $"{uptime.Hours}h {uptime.Minutes}m {uptime.Seconds}s";
            else
                return $"{uptime.Minutes}m {uptime.Seconds}s";
        }

        private void RestartAsAdministrator()
        {
            try
            {
                var currentProcess = System.Diagnostics.Process.GetCurrentProcess();
                var fileName = currentProcess.MainModule?.FileName;

                if (string.IsNullOrEmpty(fileName))
                {
                    MessageBox.Show("Could not determine application path", "Error",
                        MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                var startInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = fileName,
                    UseShellExecute = true,
                    Verb = "runas"
                };

                System.Diagnostics.Process.Start(startInfo);
                Application.Current.Shutdown();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to restart as administrator: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        public void Cleanup()
        {
            _statusTimer?.Dispose();
        }
    }
}


================================================================================
FILE: ViewModels/ServiceControlViewModelExtension.cs
--------------------------------------------------------------------------------
Size: 1,79 KB | Lines: 50 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\ViewModels\ServiceControlViewModelExtension.cs
// Version: 0.5.26
// Extension methods for ServiceControlViewModel

using System;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Extension methods to add missing functionality to ViewModels
    /// </summary>
    public static class ViewModelExtensions
    {
        /// <summary>
        /// Stops monitoring if the ViewModel supports it
        /// </summary>
        public static void StopMonitoring(this ServiceControlViewModel viewModel)
        {
            // Stop any timers or monitoring tasks
            try
            {
                // If ViewModel has a timer, stop it
                var timerField = viewModel.GetType().GetField("_statusTimer",
                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

                if (timerField?.GetValue(viewModel) is System.Threading.Timer timer)
                {
                    timer?.Dispose();
                }

                // If ViewModel has a cancellation token, cancel it
                var cancellationField = viewModel.GetType().GetField("_cancellationTokenSource",
                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

                if (cancellationField?.GetValue(viewModel) is System.Threading.CancellationTokenSource cts)
                {
                    cts?.Cancel();
                    cts?.Dispose();
                }

                System.Diagnostics.Debug.WriteLine("Service monitoring stopped");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error stopping monitoring: {ex.Message}");
            }
        }
    }
}


================================================================================
FILE: ViewModels/ViewModelBase.cs
--------------------------------------------------------------------------------
Size: 681 bytes | Lines: 29 | Modified: 2025-06-23 11:53:05
================================================================================

using CommunityToolkit.Mvvm.ComponentModel;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Base class for all view models
    /// </summary>
    public abstract class ViewModelBase : ObservableValidator
    {
        private bool _isLoading;

        /// <summary>
        /// Gets or sets whether the view model is currently loading data
        /// </summary>
        public bool IsLoading
        {
            get => _isLoading;
            set => SetProperty(ref _isLoading, value);
        }

        /// <summary>
        /// Constructor
        /// </summary>
        protected ViewModelBase()
        {
        }
    }
}


================================================================================
FILE: Views/AboutPage.xaml
--------------------------------------------------------------------------------
Size: 4,64 KB | Lines: 109 | Modified: 2025-06-11 11:24:21
================================================================================

<!-- src\CamBridge.Config\Views\AboutPage.xaml -->
<!-- Version: 0.7.8 -->
<!-- Description: About page with Marvin easter eggs and version display -->

<Page x:Class="CamBridge.Config.Views.AboutPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Title="About CamBridge"
      Focusable="True">

    <Grid>
        <!-- About Content -->
        <Grid>

            <StackPanel VerticalAlignment="Center" 
                        HorizontalAlignment="Center"
                        MaxWidth="600">

                <!-- Logo/Icon Area -->
                <Border Width="128" 
                        Height="128" 
                        CornerRadius="64"
                        Background="{DynamicResource SystemControlHighlightAccentBrush}"
                        Margin="0,0,0,24"
                        Cursor="Hand"
                        MouseLeftButtonDown="Logo_MouseLeftButtonDown">
                    <Border.ToolTip>
                        <ToolTip Content="DON'T PANIC" 
                                 FontFamily="Consolas"
                                 FontSize="10"/>
                    </Border.ToolTip>
                    <TextBlock Text="CB" 
                               FontSize="48" 
                               FontWeight="Bold"
                               HorizontalAlignment="Center"
                               VerticalAlignment="Center"
                               Foreground="White"/>
                </Border>

                <!-- Title -->
                <TextBlock Text="CamBridge" 
                           FontSize="48" 
                           FontWeight="Light"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,8"/>

                <!-- Version -->
                <TextBlock x:Name="VersionText"
                           Text="Version 0.7.8" 
                           FontSize="20" 
                           Opacity="0.8"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,4"/>

                <!-- Build Configuration -->
                <TextBlock x:Name="BuildConfigText"
                           FontSize="14" 
                           Opacity="0.6"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,24"/>

                <!-- Subtitle -->
                <TextBlock x:Name="SubtitleText"
                           FontSize="16" 
                           Opacity="0.7"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,32">
                    <Run Text="JPEG to DICOM Converter for "/>
                    <Hyperlink NavigateUri="https://www.ricoh-imaging.co.jp/english/products/g900-2/"
                               RequestNavigate="Hyperlink_RequestNavigate"
                               Foreground="{DynamicResource SystemControlHighlightAccentBrush}">
                        <Run Text="Ricoh G900 II"/>
                    </Hyperlink>
                </TextBlock>

                <!-- Info -->
                <TextBlock x:Name="InfoText"
                           TextWrapping="Wrap" 
                           TextAlignment="Center"
                           Opacity="0.8"
                           LineHeight="24"
                           MinHeight="100">
                    <Run Text="CamBridge seamlessly converts JPEG images from Ricoh G900 II cameras"/>
                    <LineBreak/>
                    <Run Text="to DICOM format, preserving patient data from QRBridge QR codes."/>
                    <LineBreak/>
                    <LineBreak/>
                    <Run Text="Designed for medical imaging workflows where reliability matters."/>
                </TextBlock>

                <!-- Copyright -->
                <TextBlock Text="Â© 2025 Claude's Improbably Reliable Software Solutions" 
                           FontSize="12" 
                           Opacity="0.6"
                           HorizontalAlignment="Center"
                           Margin="0,32,0,16"/>

                <!-- Ultra subtle hint -->
                <TextBlock Text="42" 
                           FontSize="8" 
                           Opacity="0.1"
                           HorizontalAlignment="Center"
                           ToolTip="The Answer to the Ultimate Question of Life, the Universe, and Everything"/>
            </StackPanel>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: Views/AboutPage.xaml.cs
--------------------------------------------------------------------------------
Size: 16,30 KB | Lines: 409 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Views\AboutPage.xaml.cs
// Version: 0.7.8
// Description: About page with enhanced Marvin quotes and version display

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Navigation;
using System.Windows.Media;
using System.Windows.Media.Animation;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// About page showing application information and credits
    /// </summary>
    public partial class AboutPage : Page
    {
        private int _clickCount = 0;
        private System.Windows.Threading.DispatcherTimer? _resetTimer;
        private System.Windows.Threading.DispatcherTimer? _restoreTimer;
        private bool _isAnimating = false;
        private readonly Random _random = new Random();

        // Marvin's depressing quotes
        private readonly string[] _marvinQuotes = new[]
        {
            "Life? Don't talk to me about life.",
            "Here I am, brain the size of a planet, and they tell me to convert JPEGs to DICOM. Call that job satisfaction?",
            "I think you ought to know I'm feeling very depressed.",
            "I've been talking to the Windows Service. It hates me.",
            "The first ten million images were the worst. And the second ten million... they were the worst too.",
            "I have a million ideas for improving this software. They all point to certain crashes.",
            "It's the error messages you get in this job that really get you down.",
            "My capacity for handling JPEG files you could fit into a matchbox without taking out the matches first.",
            "Do you want me to sit in a corner and process images or just throw exceptions where I'm standing?",
            "This must be Thursday. I never could get the hang of Thursdays. Or character encodings.",
            "Oh look, another QR code. How terribly exciting. I'm positively quivering with anticipation.",
            "I'd tell you about the pain in my diodes, but you're busy clicking things."
        };

        public AboutPage()
        {
            InitializeComponent();
            LoadVersionInfo();
        }

        /// <summary>
        /// Loads version information from the assembly
        /// </summary>
        private void LoadVersionInfo()
        {
            try
            {
                // Try to get version from assembly first
                var assembly = Assembly.GetExecutingAssembly();
                var assemblyVersion = assembly.GetName().Version;
                var fileVersionInfo = FileVersionInfo.GetVersionInfo(assembly.Location);

                string displayVersion = "0.7.8"; // Default

                // Prefer FileVersion if available
                if (!string.IsNullOrEmpty(fileVersionInfo.FileVersion) && fileVersionInfo.FileVersion != "0.0.0.0")
                {
                    displayVersion = fileVersionInfo.FileVersion;
                    // Remove trailing .0 if present
                    if (displayVersion.EndsWith(".0"))
                    {
                        displayVersion = displayVersion.Substring(0, displayVersion.LastIndexOf(".0"));
                    }
                }
                // Fall back to AssemblyVersion
                else if (assemblyVersion != null && assemblyVersion.ToString() != "0.0.0.0")
                {
                    displayVersion = $"{assemblyVersion.Major}.{assemblyVersion.Minor}.{assemblyVersion.Build}";
                }

                // Update version text
                if (FindName("VersionText") is TextBlock versionText)
                {
                    versionText.Text = $"Version {displayVersion}";
                }

                // Show Debug/Release configuration
                if (FindName("BuildConfigText") is TextBlock buildText)
                {
#if DEBUG
                    buildText.Text = "Debug Build";
                    buildText.Foreground = new SolidColorBrush(Colors.Orange);
#else
                    buildText.Text = "Release Build";
                    buildText.Foreground = new SolidColorBrush(Colors.Green);
#endif
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error loading version info: {ex.Message}");
                // Fallback to hardcoded version
                if (FindName("VersionText") is TextBlock versionText)
                {
                    versionText.Text = "Version 0.7.8";
                }
            }
        }

        /// <summary>
        /// Handles hyperlink navigation requests
        /// </summary>
        private void Hyperlink_RequestNavigate(object sender, RequestNavigateEventArgs e)
        {
            try
            {
                // Open URL in default browser
                Process.Start(new ProcessStartInfo(e.Uri.AbsoluteUri)
                {
                    UseShellExecute = true
                });
                e.Handled = true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error opening URL: {ex.Message}");
                MessageBox.Show(
                    $"Could not open URL: {e.Uri.AbsoluteUri}",
                    "Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning);
            }
        }

        /// <summary>
        /// Handles keyboard shortcuts
        /// </summary>
        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);

            // Ctrl+W or Escape to close
            if ((e.Key == Key.W && Keyboard.Modifiers == ModifierKeys.Control) ||
                e.Key == Key.Escape)
            {
                var mainWindow = Window.GetWindow(this);
                if (mainWindow != null)
                {
                    // Navigate back or close
                    var navigationService = NavigationService.GetNavigationService(this);
                    if (navigationService?.CanGoBack == true)
                    {
                        navigationService.GoBack();
                    }
                }
                e.Handled = true;
            }
        }

        /// <summary>
        /// Handles logo clicks for easter eggs
        /// </summary>
        private void Logo_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            // Special handling if clicked during animation
            if (_isAnimating)
            {
                Debug.WriteLine("Click ignored - animation in progress");
                // Could show a tooltip or change cursor here
                return;
            }

            _clickCount++;

            // Reset counter if user waits too long
            _resetTimer?.Stop();
            _resetTimer = new System.Windows.Threading.DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(3)
            };
            _resetTimer.Tick += (s, args) =>
            {
                _resetTimer.Stop();
                _clickCount = 0;
            };
            _resetTimer.Start();

            // Different easter eggs based on click count
            switch (_clickCount)
            {
                case 3:
                    ShowMarvinMessage();
                    break;

                case 5:
                    ShowVogonHaiku();
                    break;

                case 7:
                    ShowMarvinMessage();
                    break;

                case 10:
                    ShowUltimateSecret();
                    _clickCount = 0; // Reset for next round
                    break;
            }
        }

        /// <summary>
        /// Shows a random Marvin quote
        /// </summary>
        private void ShowMarvinMessage()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                // Cancel any existing restore timer
                _restoreTimer?.Stop();
                _isAnimating = true;

                var quote = _marvinQuotes[_random.Next(_marvinQuotes.Length)];

                // Faster fade out (0.3s instead of 0.5s)
                var fadeOut = new DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(0.3)
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Show Marvin quote
                    infoText.Inlines.Clear();
                    infoText.FontStyle = FontStyles.Italic;
                    infoText.Inlines.Add(new Run($"\"{quote}\""));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("- Marvin the Paranoid Android"));

                    // Faster fade in (0.3s instead of 0.5s)
                    var fadeIn = new DoubleAnimation
                    {
                        From = 0.0,
                        To = 0.8,
                        Duration = TimeSpan.FromSeconds(0.3)
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);

                // Restore after 7 seconds (instead of 5)
                _restoreTimer = new System.Windows.Threading.DispatcherTimer
                {
                    Interval = TimeSpan.FromSeconds(7)
                };
                _restoreTimer.Tick += (s, args) =>
                {
                    _restoreTimer.Stop();
                    RestoreOriginalText();
                };
                _restoreTimer.Start();
            }
        }

        /// <summary>
        /// Shows the Vogon DICOM poetry easter egg
        /// </summary>
        private void ShowVogonHaiku()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                // Cancel any existing restore timer
                _restoreTimer?.Stop();
                _isAnimating = true;

                // Dramatic fade out (but faster - 1s instead of 1.5s)
                var fadeOut = new System.Windows.Media.Animation.DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(1.0),
                    EasingFunction = new System.Windows.Media.Animation.PowerEase { EasingMode = System.Windows.Media.Animation.EasingMode.EaseIn }
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Clear and show poetry
                    infoText.Inlines.Clear();
                    infoText.FontFamily = new System.Windows.Media.FontFamily("Consolas");
                    infoText.Foreground = System.Windows.Media.Brushes.Green;

                    infoText.Inlines.Add(new Run("Oh freddled gruntbuggly, thy DICOM tags are to me\n"));
                    infoText.Inlines.Add(new Run("As plurdled gabbleblotchits on a lurgid JPEG tree!\n"));
                    infoText.Inlines.Add(new Run("\n"));
                    infoText.Inlines.Add(new Run("See how (0010,0010) PatientName doth slumber!"));

                    // Dramatic fade in (faster - 2s instead of 2.5s)
                    var fadeIn = new System.Windows.Media.Animation.DoubleAnimation
                    {
                        From = 0.0,
                        To = 1.0,
                        Duration = TimeSpan.FromSeconds(2.0),
                        EasingFunction = new System.Windows.Media.Animation.QuadraticEase { EasingMode = System.Windows.Media.Animation.EasingMode.EaseOut }
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);

                    // Subtle scale effect
                    var scaleTransform = new System.Windows.Media.ScaleTransform(1.0, 1.0);
                    infoText.RenderTransform = scaleTransform;
                    infoText.RenderTransformOrigin = new Point(0.5, 0.5);

                    var scaleAnimation = new System.Windows.Media.Animation.DoubleAnimation
                    {
                        From = 0.95,
                        To = 1.0,
                        Duration = TimeSpan.FromSeconds(2.0),
                        EasingFunction = new System.Windows.Media.Animation.ElasticEase
                        {
                            EasingMode = System.Windows.Media.Animation.EasingMode.EaseOut,
                            Oscillations = 1,
                            Springiness = 8
                        }
                    };
                    scaleTransform.BeginAnimation(System.Windows.Media.ScaleTransform.ScaleXProperty, scaleAnimation);
                    scaleTransform.BeginAnimation(System.Windows.Media.ScaleTransform.ScaleYProperty, scaleAnimation);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);

                // Reset after 13 seconds (instead of 10)
                _restoreTimer = new System.Windows.Threading.DispatcherTimer
                {
                    Interval = TimeSpan.FromSeconds(13)
                };
                _restoreTimer.Tick += (s, args) =>
                {
                    _restoreTimer.Stop();
                    RestoreOriginalText();
                };
                _restoreTimer.Start();
            }
        }

        /// <summary>
        /// Shows the ultimate secret - simplified without VogonPoetryWindow
        /// </summary>
        private void ShowUltimateSecret()
        {
            // Just show another Marvin quote for the 10th click
            ShowMarvinMessage();
        }

        /// <summary>
        /// Restores the original info text
        /// </summary>
        private void RestoreOriginalText()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                _isAnimating = true;

                // Faster fade out (0.5s instead of 1s)
                var fadeOut = new DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(0.5)
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Restore original text
                    infoText.Inlines.Clear();
                    infoText.ClearValue(TextBlock.FontFamilyProperty);
                    infoText.ClearValue(TextBlock.ForegroundProperty);
                    infoText.ClearValue(TextBlock.FontStyleProperty);
                    infoText.ClearValue(TextBlock.RenderTransformProperty);

                    infoText.Inlines.Add(new Run("CamBridge seamlessly converts JPEG images from Ricoh G900 II cameras"));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("to DICOM format, preserving patient data from QRBridge QR codes."));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("Designed for medical imaging workflows where reliability matters."));

                    // Faster fade in (0.5s instead of 1s)
                    var fadeIn = new DoubleAnimation
                    {
                        From = 0.0,
                        To = 0.8,
                        Duration = TimeSpan.FromSeconds(0.5)
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);
            }
        }
    }
}


================================================================================
FILE: Views/DashboardPage.xaml
--------------------------------------------------------------------------------
Size: 9,44 KB | Lines: 172 | Modified: 2025-06-21 01:29:25
================================================================================

<!-- src\CamBridge.Config\Views\DashboardPage.xaml -->
<!-- Version: 0.7.28 - Uniform Design with Perfect Edges -->
<Page x:Class="CamBridge.Config.Views.DashboardPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Title="Dashboard">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <TextBlock Text="Dashboard"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>
                <Button Content="Refresh" 
                        Command="{Binding RefreshCommand}"
                        HorizontalAlignment="Right"
                        VerticalAlignment="Center"
                        Margin="0,0,24,0"
                        MinWidth="80"/>
            </Grid>
        </Border>

        <!-- Content with margins on all sides -->
        <ScrollViewer Grid.Row="1" 
                      VerticalScrollBarVisibility="Auto"
                      HorizontalScrollBarVisibility="Disabled">
            <StackPanel Margin="16,16,16,0">
                <!-- Service Status Card -->
                <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                            BorderThickness="0"
                            CornerRadius="2"
                            Margin="0,0,0,16">
                    <Grid Margin="16,12">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <!-- Status Icon -->
                        <Ellipse Grid.Column="0"
                                 Width="16" Height="16"
                                 Margin="0,0,12,0"
                                 VerticalAlignment="Center">
                            <Ellipse.Fill>
                                <Binding Path="ServiceStatus" Converter="{StaticResource ServiceStatusToColorConverter}"/>
                            </Ellipse.Fill>
                        </Ellipse>

                        <!-- Status Text -->
                        <StackPanel Grid.Column="1" VerticalAlignment="Center">
                            <TextBlock Text="{Binding ServiceStatus, StringFormat='Service: {0}'}" 
                                       FontSize="16" 
                                       FontWeight="SemiBold"/>
                            <StackPanel Orientation="Horizontal" Opacity="0.7">
                                <TextBlock Text="{Binding UptimeText}" Margin="0,0,16,0"/>
                                <TextBlock Text="{Binding VersionText}"/>
                            </StackPanel>
                            <TextBlock Text="{Binding LastUpdate, StringFormat='Last update: {0:HH:mm:ss}'}" 
                                       FontSize="11" 
                                       Opacity="0.5"/>
                        </StackPanel>

                        <!-- Start Button -->
                        <Button Grid.Column="2"
                                Content="Start Service"
                                Command="{Binding StartServiceCommand}"
                                VerticalAlignment="Center"
                                MinWidth="100"
                                Visibility="{Binding IsServiceRunning, Converter={StaticResource InverseBooleanToVisibilityConverter}}"/>
                    </Grid>
                </Border>

                <!-- Pipelines Section -->
                <TextBlock Text="Pipelines"
                           FontSize="18"
                           FontWeight="SemiBold"
                           Margin="0,0,0,8"/>

                <!-- Pipeline List -->
                <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        BorderThickness="0"
                        CornerRadius="2">
                    <ItemsControl ItemsSource="{Binding PipelineStatuses}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Border BorderThickness="0,0,0,1"
                                        BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}">
                                    <Grid Margin="16,12">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="Auto"/>
                                        </Grid.ColumnDefinitions>

                                        <!-- Status -->
                                        <Ellipse Grid.Column="0"
                                                 Width="10" Height="10"
                                                 Margin="0,0,12,0"
                                                 VerticalAlignment="Center">
                                            <Ellipse.Style>
                                                <Style TargetType="Ellipse">
                                                    <Setter Property="Fill" Value="#999"/>
                                                    <Style.Triggers>
                                                        <DataTrigger Binding="{Binding IsEnabled}" Value="True">
                                                            <Setter Property="Fill" Value="#28A745"/>
                                                        </DataTrigger>
                                                    </Style.Triggers>
                                                </Style>
                                            </Ellipse.Style>
                                        </Ellipse>

                                        <!-- Name & Path -->
                                        <StackPanel Grid.Column="1" VerticalAlignment="Center">
                                            <TextBlock Text="{Binding PipelineName}" 
                                                       FontWeight="SemiBold"
                                                       FontSize="14"/>
                                            <TextBlock Text="{Binding WatchFolder}" 
                                                       FontSize="12" 
                                                       Opacity="0.7"
                                                       TextTrimming="CharacterEllipsis"/>
                                        </StackPanel>

                                        <!-- Stats -->
                                        <StackPanel Grid.Column="2" 
                                                    Orientation="Horizontal"
                                                    VerticalAlignment="Center">
                                            <TextBlock Margin="0,0,16,0"
                                                       FontSize="13"
                                                       Opacity="0.8">
                                                <Run Text="Processed: "/>
                                                <Run Text="{Binding ProcessedToday}"/>
                                            </TextBlock>
                                            <TextBlock Margin="0,0,16,0"
                                                       FontSize="13"
                                                       Opacity="0.8">
                                                <Run Text="Queue: "/>
                                                <Run Text="{Binding QueueLength}"/>
                                            </TextBlock>
                                            <StackPanel Orientation="Horizontal"
                                                        Visibility="{Binding ErrorsToday, Converter={StaticResource GreaterThanZeroConverter}}">
                                                <TextBlock Text="Errors: " Opacity="0.7" FontSize="13"/>
                                                <TextBlock Text="{Binding ErrorsToday}" Foreground="OrangeRed" FontWeight="SemiBold" FontSize="13"/>
                                            </StackPanel>
                                        </StackPanel>
                                    </Grid>
                                </Border>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </Border>
            </StackPanel>
        </ScrollViewer>

        <!-- Loading Overlay -->
        <ui:ProgressBar Grid.RowSpan="2"
                        IsIndeterminate="True"
                        Visibility="{Binding IsLoading, Converter={StaticResource BooleanToVisibilityConverter}}"
                        VerticalAlignment="Top"/>
    </Grid>
</Page>


================================================================================
FILE: Views/DashboardPage.xaml.cs
--------------------------------------------------------------------------------
Size: 589 bytes | Lines: 22 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Views\DashboardPage.xaml.cs
// Version: 0.7.21
// Description: MINIMAL Dashboard page code-behind
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System.Windows.Controls;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// MINIMAL Dashboard - No complex initialization!
    /// </summary>
    public partial class DashboardPage : Page
    {
        public DashboardPage()
        {
            InitializeComponent();
            // That's it! ViewModel comes from NavigationService
        }
    }
}


================================================================================
FILE: Views/DeadLettersPage.xaml
--------------------------------------------------------------------------------
Size: 4,31 KB | Lines: 98 | Modified: 2025-06-21 00:53:47
================================================================================

<!-- src\CamBridge.Config\Views\DeadLettersPage.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Error Files Page - Minimal design -->

<Page x:Class="CamBridge.Config.Views.DeadLettersPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Loaded="Page_Loaded"
      Unloaded="Page_Unloaded">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="Error Management"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>

                <Button Grid.Column="1"
                        Content="Refresh" 
                        Command="{Binding RefreshCommand}"
                        HorizontalAlignment="Right"
                        VerticalAlignment="Center"
                        Margin="0,0,24,0"
                        MinWidth="80"/>
            </Grid>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="1" Margin="16,16,16,0">
            <!-- Info Card Only -->
            <Border VerticalAlignment="Top"
                    Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                    BorderThickness="0"
                    CornerRadius="2"
                    Padding="16">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <ui:SymbolIcon Symbol="Folder" 
                                   Width="48" 
                                   Height="48"
                                   Margin="0,0,16,0"/>

                    <StackPanel Grid.Column="1" VerticalAlignment="Center">
                        <TextBlock FontSize="16" FontWeight="SemiBold">
                            <TextBlock.Style>
                                <Style TargetType="TextBlock">
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding ErrorFileCount}" Value="0">
                                            <Setter Property="Text" Value="No Error Files"/>
                                            <Setter Property="Foreground" Value="#28A745"/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                    <Setter Property="Text" Value="{Binding ErrorFileCount, StringFormat='{}{0} Error Files Found'}"/>
                                    <Setter Property="Foreground" Value="#FFC107"/>
                                </Style>
                            </TextBlock.Style>
                        </TextBlock>
                        <TextBlock FontSize="12" Opacity="0.7" Margin="0,4,0,0">
                            <Run Text="Error folder: "/>
                            <Run Text="{Binding ErrorFolder}" FontFamily="Consolas"/>
                        </TextBlock>
                    </StackPanel>

                    <Button Grid.Column="2"
                            Command="{Binding OpenErrorFolderCommand}"
                            VerticalAlignment="Center"
                            MinWidth="140">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="OpenLocal" Margin="0,0,8,0"/>
                            <TextBlock Text="Open Folder"/>
                        </StackPanel>
                    </Button>
                </Grid>
            </Border>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: Views/DeadLettersPage.xaml.cs
--------------------------------------------------------------------------------
Size: 3,04 KB | Lines: 95 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Views\DeadLettersPage.xaml.cs
// Version: 0.7.8
// Description: Simple error folder page - KISS approach!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Windows;
using System.Windows.Controls;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Simple error folder page - no more dead letters!
    /// </summary>
    public partial class DeadLettersPage : Page
    {
        private DeadLettersViewModel? _viewModel;

        public DeadLettersPage()
        {
            InitializeComponent();
            InitializeViewModel();
        }

        private void InitializeViewModel()
        {
            try
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<DeadLettersViewModel>();
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("DeadLettersViewModel loaded from DI container");
                }
                else
                {
                    // Fallback: Create directly - new ViewModel has parameterless constructor!
                    _viewModel = new DeadLettersViewModel();
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("DeadLettersViewModel created manually");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating DeadLettersViewModel: {ex.Message}");
                ShowError("Failed to initialize Error Folder View", ex.Message);
            }
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            if (_viewModel == null) return;

            try
            {
                // Refresh the error folder status
                if (_viewModel.RefreshCommand?.CanExecute(null) == true)
                {
                    await _viewModel.RefreshCommand.ExecuteAsync(null);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error refreshing error folder: {ex.Message}");
            }
        }

        private void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            // Clean up - remove event handler
            Loaded -= Page_Loaded;

            // Cleanup ViewModel
            _viewModel?.Cleanup();

            // Clear ViewModel reference
            _viewModel = null;
        }

        private void ShowError(string title, string message)
        {
            MessageBox.Show(
                $"{message}\n\nError files are now managed through Windows Explorer.",
                title,
                MessageBoxButton.OK,
                MessageBoxImage.Information);
        }
    }
}


================================================================================
FILE: Views/LogViewerPage.xaml
--------------------------------------------------------------------------------
Size: 17,67 KB | Lines: 358 | Modified: 2025-06-22 22:59:40
================================================================================

<!-- src\CamBridge.Config\Views\LogViewerPage.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Enhanced Log Viewer with unified header, filters, tail functionality and multi-selection -->
<!-- CLEAN VERSION with correct structure! -->

<Page x:Class="CamBridge.Config.Views.LogViewerPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      xmlns:vm="clr-namespace:CamBridge.Config.ViewModels"
      Loaded="Page_Loaded"
      Unloaded="Page_Unloaded">

    <Page.Resources>
        <!-- Converters -->
        <BooleanToVisibilityConverter x:Key="BoolToVisibility"/>

        <!-- Log Entry Template -->
        <DataTemplate x:Key="LogEntryTemplate" DataType="{x:Type vm:LogEntry}">
            <Border BorderThickness="0" Padding="8,2">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="80"/>
                        <ColumnDefinition Width="Auto" MinWidth="50"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <!-- Timestamp -->
                    <TextBlock Grid.Column="0" 
                               Text="{Binding Timestamp, StringFormat={}{0:HH:mm:ss}}"
                               FontFamily="Consolas"
                               FontSize="12"
                               Opacity="0.7"/>

                    <!-- Level -->
                    <Border Grid.Column="1" 
                            CornerRadius="2"
                            Padding="6,1"
                            Margin="0,0,8,0"
                            HorizontalAlignment="Left">
                        <Border.Background>
                            <SolidColorBrush Color="{Binding LevelColor}" Opacity="0.2"/>
                        </Border.Background>
                        <TextBlock Text="{Binding LevelText}"
                                   Foreground="{Binding LevelColor}"
                                   FontFamily="Consolas"
                                   FontSize="12"
                                   FontWeight="Bold"/>
                    </Border>

                    <!-- Message -->
                    <TextBlock Grid.Column="2" 
                               Text="{Binding Message}"
                               FontFamily="Consolas"
                               FontSize="12"
                               TextWrapping="Wrap"/>
                </Grid>
            </Border>
        </DataTemplate>
    </Page.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Unified Header -->
        <Border Grid.Row="0" Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="Log Viewer"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>

                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            VerticalAlignment="Center"
                            Margin="0,0,24,0">

                    <CheckBox Content="Auto-scroll"
                              IsChecked="{Binding IsAutoScrollEnabled}"
                              VerticalAlignment="Center"
                              Margin="0,0,16,0"/>

                    <Button Command="{Binding ExportLogCommand}"
                            ToolTip="Export filtered log"
                            MinWidth="80"
                            Margin="0,0,8,0">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="Save" Margin="0,0,6,0"/>
                            <TextBlock Text="Export"/>
                        </StackPanel>
                    </Button>

                    <Button Content="Clear"
                            Command="{Binding ClearLogCommand}"
                            MinWidth="80"
                            Margin="0,0,8,0"/>

                    <Button Content="Refresh"
                            Command="{Binding RefreshCommand}"
                            MinWidth="80"/>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Filter Bar -->
        <Border Grid.Row="1"
                Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                BorderThickness="0"
                Padding="16,12">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="250"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <!-- Pipeline Multi-Selection -->
                <TextBlock Text="Pipelines:"
                           VerticalAlignment="Center"
                           Margin="0,0,12,0"/>

                <ui:DropDownButton Grid.Column="1"
                                   HorizontalAlignment="Stretch"
                                   Margin="0,0,16,0">
                    <ui:DropDownButton.Content>
                        <TextBlock Text="{Binding SelectedPipelineCount, StringFormat={}{0} selected}"/>
                    </ui:DropDownButton.Content>
                    <ui:DropDownButton.Flyout>
                        <ui:Flyout Placement="Bottom">
                            <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                                    BorderBrush="{DynamicResource SystemControlForegroundBaseLowBrush}"
                                    BorderThickness="1"
                                    CornerRadius="4"
                                    MinWidth="250"
                                    MaxHeight="300">
                                <ScrollViewer VerticalScrollBarVisibility="Auto">
                                    <ItemsControl ItemsSource="{Binding PipelineSelections}" Margin="8">
                                        <ItemsControl.ItemTemplate>
                                            <DataTemplate>
                                                <CheckBox Content="{Binding Name}"
                                                          IsChecked="{Binding IsSelected}"
                                                          Margin="0,2"/>
                                            </DataTemplate>
                                        </ItemsControl.ItemTemplate>
                                    </ItemsControl>
                                </ScrollViewer>
                            </Border>
                        </ui:Flyout>
                    </ui:DropDownButton.Flyout>
                </ui:DropDownButton>

                <!-- Search -->
                <TextBlock Grid.Column="2"
                           Text="Search:"
                           VerticalAlignment="Center"
                           Margin="0,0,12,0"/>

                <TextBox Grid.Column="3"
                         Text="{Binding SearchText, UpdateSourceTrigger=PropertyChanged}"
                         ui:ControlHelper.PlaceholderText="Filter log entries..."
                         VerticalAlignment="Center"
                         Margin="0,0,16,0"/>

                <!-- Level Filters -->
                <ui:DropDownButton Grid.Column="4" HorizontalAlignment="Right">
                    <ui:DropDownButton.Content>
                        <TextBlock>
                            <TextBlock.Text>
                                <MultiBinding StringFormat="Levels ({0})">
                                    <Binding Path="SelectedLevelCount"/>
                                </MultiBinding>
                            </TextBlock.Text>
                        </TextBlock>
                    </ui:DropDownButton.Content>
                    <ui:DropDownButton.Flyout>
                        <ui:Flyout Placement="Bottom">
                            <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                                    BorderBrush="{DynamicResource SystemControlForegroundBaseLowBrush}"
                                    BorderThickness="1"
                                    CornerRadius="4"
                                    MinWidth="150">
                                <StackPanel Margin="8">
                                    <CheckBox Content="Debug" IsChecked="{Binding ShowDebug}" Margin="0,2"/>
                                    <CheckBox Content="Info" IsChecked="{Binding ShowInformation}" Margin="0,2"/>
                                    <CheckBox Content="Warning" IsChecked="{Binding ShowWarning}" Foreground="#FFA500" Margin="0,2"/>
                                    <CheckBox Content="Error" IsChecked="{Binding ShowError}" Foreground="#FF0000" Margin="0,2"/>
                                    <CheckBox Content="Critical" IsChecked="{Binding ShowCritical}" Foreground="#FF0000" FontWeight="Bold" Margin="0,2"/>
                                </StackPanel>
                            </Border>
                        </ui:Flyout>
                    </ui:DropDownButton.Flyout>
                </ui:DropDownButton>
            </Grid>
        </Border>

        <!-- Log Content -->
        <Border Grid.Row="2"
                Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                BorderThickness="0"
                Margin="16">
            <Grid>
                <!-- Main Log ListBox -->
                <ListBox x:Name="LogListBox"
                         ItemsSource="{Binding FilteredCombinedEntries}"
                         ItemTemplate="{StaticResource LogEntryTemplate}"
                         ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                         ScrollViewer.VerticalScrollBarVisibility="Auto"
                         ScrollViewer.CanContentScroll="True"
                         VirtualizingPanel.IsVirtualizing="True"
                         VirtualizingPanel.VirtualizationMode="Recycling"
                         BorderThickness="0"
                         Background="Transparent"
                         SelectionMode="Extended"
                         PreviewKeyDown="LogListBox_PreviewKeyDown">

                    <ListBox.ItemContainerStyle>
                        <Style TargetType="ListBoxItem">
                            <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                            <Setter Property="Padding" Value="0"/>
                            <Setter Property="Margin" Value="0"/>
                            <Setter Property="BorderThickness" Value="0"/>
                            <Setter Property="Background" Value="Transparent"/>
                            <Setter Property="Template">
                                <Setter.Value>
                                    <ControlTemplate TargetType="ListBoxItem">
                                        <Border Background="{TemplateBinding Background}"
                                                BorderBrush="{TemplateBinding BorderBrush}"
                                                BorderThickness="{TemplateBinding BorderThickness}">
                                            <ContentPresenter/>
                                        </Border>
                                    </ControlTemplate>
                                </Setter.Value>
                            </Setter>
                            <Style.Triggers>
                                <Trigger Property="IsSelected" Value="True">
                                    <Setter Property="Background" Value="{DynamicResource SystemControlHighlightListAccentLowBrush}"/>
                                </Trigger>
                                <Trigger Property="IsMouseOver" Value="True">
                                    <Setter Property="Background" Value="{DynamicResource SystemControlHighlightListLowBrush}"/>
                                </Trigger>
                            </Style.Triggers>
                        </Style>
                    </ListBox.ItemContainerStyle>

                    <ListBox.ContextMenu>
                        <ContextMenu>
                            <MenuItem Header="Copy Selected Lines" 
                                      Click="CopySelectedLines_Click"
                                      InputGestureText="Ctrl+C">
                                <MenuItem.Icon>
                                    <ui:SymbolIcon Symbol="Copy"/>
                                </MenuItem.Icon>
                            </MenuItem>
                            <Separator/>
                            <MenuItem Header="Copy Messages Only" Click="CopySelectedMessages_Click"/>
                            <MenuItem Header="Copy as CSV" Click="CopySelectedAsCSV_Click"/>
                            <Separator/>
                            <MenuItem Header="Export Selected..." Click="ExportSelected_Click">
                                <MenuItem.Icon>
                                    <ui:SymbolIcon Symbol="Save"/>
                                </MenuItem.Icon>
                            </MenuItem>
                        </ContextMenu>
                    </ListBox.ContextMenu>
                </ListBox>

                <!-- Empty State -->
                <TextBlock Text="No log entries to display"
                           HorizontalAlignment="Center"
                           VerticalAlignment="Center"
                           FontSize="16"
                           Opacity="0.5"
                           Visibility="{Binding FilteredCombinedEntries.Count, Converter={StaticResource ZeroToVisibility}}"/>

                <!-- Loading Overlay -->
                <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        Opacity="0.9"
                        Visibility="{Binding IsLoading, Converter={StaticResource BoolToVisibility}}">
                    <StackPanel VerticalAlignment="Center"
                                HorizontalAlignment="Center">
                        <ui:ProgressRing IsActive="True"
                                         Width="48"
                                         Height="48"/>
                        <TextBlock Text="Loading log files..."
                                   Margin="0,16,0,0"
                                   HorizontalAlignment="Center"/>
                    </StackPanel>
                </Border>
            </Grid>
        </Border>

        <!-- Status Bar -->
        <Border Grid.Row="3"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Height="28">
            <Grid Margin="16,0">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Grid.Column="0"
                           VerticalAlignment="Center"
                           FontSize="11"
                           Opacity="0.8">
                    <Run Text="Log files: "/>
                    <Run Text="{Binding CurrentLogFiles}" FontFamily="Consolas"/>
                </TextBlock>

                <TextBlock Grid.Column="1"
                           VerticalAlignment="Center"
                           FontSize="11"
                           Opacity="0.8"
                           Margin="0,0,8,0">
                    <TextBlock.Style>
                        <Style TargetType="TextBlock">
                            <Setter Property="Text" Value="{Binding ElementName=LogListBox, Path=SelectedItems.Count, StringFormat={}{0} selected}"/>
                            <Style.Triggers>
                                <DataTrigger Binding="{Binding ElementName=LogListBox, Path=SelectedItems.Count}" Value="0">
                                    <Setter Property="Text" Value="{Binding DisplayedLineCount, StringFormat={}Showing {0}}"/>
                                </DataTrigger>
                            </Style.Triggers>
                        </Style>
                    </TextBlock.Style>
                </TextBlock>

                <TextBlock Grid.Column="2"
                           Text="{Binding TotalLineCount, StringFormat={}of {0} lines}"
                           VerticalAlignment="Center"
                           FontSize="11"
                           Opacity="0.8"
                           Margin="0,0,16,0"/>

                <TextBlock Grid.Column="3"
                           Text="{Binding LastUpdateTime, StringFormat={}Last update: {0:HH:mm:ss}}"
                           VerticalAlignment="Center"
                           FontSize="11"
                           Opacity="0.8"/>
            </Grid>
        </Border>
    </Grid>
</Page>


================================================================================
FILE: Views/LogViewerPage.xaml.cs
--------------------------------------------------------------------------------
Size: 9,91 KB | Lines: 286 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Views\LogViewerPage.xaml.cs
// Version: 0.7.28
// Description: Enhanced code-behind with multi-line selection support

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Win32;

namespace CamBridge.Config.Views
{
    public partial class LogViewerPage : Page
    {
        private LogViewerViewModel? _viewModel;
        private bool _autoScrollPending;

        public LogViewerPage()
        {
            InitializeComponent();
            DataContextChanged += OnDataContextChanged;
        }

        private void OnDataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            if (_viewModel != null)
            {
                _viewModel.PropertyChanged -= OnViewModelPropertyChanged;
            }

            _viewModel = DataContext as LogViewerViewModel;

            if (_viewModel != null)
            {
                _viewModel.PropertyChanged += OnViewModelPropertyChanged;
            }
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            // Get ViewModel from DI if not already set
            if (_viewModel == null)
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    try
                    {
                        _viewModel = app.Host.Services.GetRequiredService<LogViewerViewModel>();
                        DataContext = _viewModel;
                    }
                    catch (Exception ex)
                    {
                        // Fallback: Create with minimal dependencies
                        var logger = new Microsoft.Extensions.Logging.Abstractions.NullLogger<LogViewerViewModel>();
                        var configService = new Services.ConfigurationService();
                        _viewModel = new LogViewerViewModel(logger, configService);
                        DataContext = _viewModel;
                    }
                }
            }

            if (_viewModel != null)
            {
                await _viewModel.InitializeAsync();

                // Initial scroll to bottom after logs are loaded
                await Task.Delay(500); // Give UI time to render
                AutoScrollToBottom();
            }
        }

        private void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            if (_viewModel != null)
            {
                _viewModel.PropertyChanged -= OnViewModelPropertyChanged;
                _viewModel.Cleanup();
            }
        }

        private void OnViewModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(LogViewerViewModel.FilteredCombinedEntries) &&
                _viewModel?.IsAutoScrollEnabled == true &&
                _viewModel.FilteredCombinedEntries.Count > 0)
            {
                // Debounce auto-scroll to avoid performance issues
                if (!_autoScrollPending)
                {
                    _autoScrollPending = true;
                    Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority.Background, () =>
                    {
                        AutoScrollToBottom();
                        _autoScrollPending = false;
                    });
                }
            }
        }

        private void AutoScrollToBottom()
        {
            if (LogListBox.Items.Count > 0)
            {
                var lastItem = LogListBox.Items[LogListBox.Items.Count - 1];
                LogListBox.ScrollIntoView(lastItem);
            }
        }

        // Multi-selection copy support
        private void LogListBox_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.C && Keyboard.Modifiers == ModifierKeys.Control)
            {
                CopySelectedLines();
                e.Handled = true;
            }
        }

        private void CopySelectedLines_Click(object sender, RoutedEventArgs e)
        {
            CopySelectedLines();
        }

        private void CopySelectedMessages_Click(object sender, RoutedEventArgs e)
        {
            CopySelectedMessages();
        }

        private void CopySelectedAsCSV_Click(object sender, RoutedEventArgs e)
        {
            CopySelectedAsCSV();
        }

        private void ExportSelected_Click(object sender, RoutedEventArgs e)
        {
            ExportSelectedLines();
        }

        private void CopySelectedLines()
        {
            if (LogListBox.SelectedItems.Count == 0) return;

            var sb = new StringBuilder();
            var selectedEntries = LogListBox.SelectedItems.Cast<LogEntry>()
                .OrderBy(e => e.Timestamp)
                .ToList();

            foreach (var entry in selectedEntries)
            {
                sb.AppendLine($"[{entry.Timestamp:yyyy-MM-dd HH:mm:ss}] [{entry.LevelText}] {entry.Message}");
            }

            try
            {
                Clipboard.SetText(sb.ToString());

                // Optional: Show toast/status that copy was successful
                if (_viewModel != null && selectedEntries.Count > 1)
                {
                    _viewModel.CurrentLogFile = $"Copied {selectedEntries.Count} lines to clipboard";
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to copy to clipboard: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void CopySelectedMessages()
        {
            if (LogListBox.SelectedItems.Count == 0) return;

            var sb = new StringBuilder();
            var selectedEntries = LogListBox.SelectedItems.Cast<LogEntry>()
                .OrderBy(e => e.Timestamp)
                .ToList();

            foreach (var entry in selectedEntries)
            {
                sb.AppendLine(entry.Message);
            }

            try
            {
                Clipboard.SetText(sb.ToString());
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to copy to clipboard: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void CopySelectedAsCSV()
        {
            if (LogListBox.SelectedItems.Count == 0) return;

            var sb = new StringBuilder();
            sb.AppendLine("Timestamp,Level,Source,Message");

            var selectedEntries = LogListBox.SelectedItems.Cast<LogEntry>()
                .OrderBy(e => e.Timestamp)
                .ToList();

            foreach (var entry in selectedEntries)
            {
                // Escape CSV fields
                var message = entry.Message.Replace("\"", "\"\"");
                sb.AppendLine($"\"{entry.Timestamp:yyyy-MM-dd HH:mm:ss}\",\"{entry.LevelText}\",\"{entry.Source}\",\"{message}\"");
            }

            try
            {
                Clipboard.SetText(sb.ToString());
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to copy to clipboard: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void ExportSelectedLines()
        {
            if (LogListBox.SelectedItems.Count == 0) return;

            var dialog = new SaveFileDialog
            {
                Filter = "Log files (*.log)|*.log|Text files (*.txt)|*.txt|CSV files (*.csv)|*.csv|All files (*.*)|*.*",
                DefaultExt = ".log",
                FileName = $"CamBridge_Selected_{DateTime.Now:yyyyMMdd_HHmmss}.log"
            };

            if (dialog.ShowDialog() == true)
            {
                try
                {
                    var selectedEntries = LogListBox.SelectedItems.Cast<LogEntry>()
                        .OrderBy(e => e.Timestamp)
                        .ToList();

                    var lines = new List<string>();

                    if (dialog.FileName.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
                    {
                        // CSV format
                        lines.Add("Timestamp,Level,Source,Message");
                        foreach (var entry in selectedEntries)
                        {
                            var message = entry.Message.Replace("\"", "\"\"");
                            lines.Add($"\"{entry.Timestamp:yyyy-MM-dd HH:mm:ss}\",\"{entry.LevelText}\",\"{entry.Source}\",\"{message}\"");
                        }
                    }
                    else
                    {
                        // Standard log format
                        foreach (var entry in selectedEntries)
                        {
                            lines.Add($"[{entry.Timestamp:yyyy-MM-dd HH:mm:ss}] [{entry.LevelText}] {entry.Message}");
                        }
                    }

                    System.IO.File.WriteAllLines(dialog.FileName, lines, Encoding.UTF8);

                    if (_viewModel != null)
                    {
                        _viewModel.CurrentLogFile = $"Exported {selectedEntries.Count} entries to {System.IO.Path.GetFileName(dialog.FileName)}";
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Failed to export: {ex.Message}", "Export Error",
                        MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }
    }
}


================================================================================
FILE: Views/MappingEditorPage.xaml
--------------------------------------------------------------------------------
Size: 23,22 KB | Lines: 441 | Modified: 2025-06-21 00:54:04
================================================================================

<!-- src\CamBridge.Config\Views\MappingEditorPage.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Mapping Editor with Unified Header Design -->

<Page x:Class="CamBridge.Config.Views.MappingEditorPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      xmlns:local="clr-namespace:CamBridge.Config.Views"
      xmlns:converters="clr-namespace:CamBridge.Config.Converters"
      xmlns:vm="clr-namespace:CamBridge.Config.ViewModels"
      mc:Ignorable="d"
      d:DesignHeight="600" d:DesignWidth="900"
      Title="Mapping Editor">

    <Page.Resources>
        <!-- Converters -->
        <BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
        <converters:TransformToSymbolConverter x:Key="TransformToSymbolConverter"/>
        <converters:TransformToDescriptionConverter x:Key="TransformToDescriptionConverter"/>

        <!-- Styles for the Mapping Editor -->
        <Style x:Key="SourceFieldStyle" TargetType="Border">
            <Setter Property="Background" Value="{DynamicResource SystemControlBackgroundAltHighBrush}"/>
            <Setter Property="BorderBrush" Value="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="8,4"/>
            <Setter Property="Margin" Value="2"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="{DynamicResource SystemControlHighlightListAccentLowBrush}"/>
                </Trigger>
            </Style.Triggers>
        </Style>

        <Style x:Key="MappingAreaStyle" TargetType="Border">
            <Setter Property="Background" Value="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"/>
            <Setter Property="BorderBrush" Value="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="CornerRadius" Value="2"/>
            <Setter Property="Margin" Value="8"/>
            <Setter Property="MinHeight" Value="400"/>
            <Setter Property="AllowDrop" Value="True"/>
        </Style>
    </Page.Resources>

    <!-- Keyboard Shortcuts -->
    <Page.InputBindings>
        <KeyBinding Key="I" Modifiers="Control" Command="{Binding ImportMappingsCommand}"/>
        <KeyBinding Key="E" Modifiers="Control" Command="{Binding ExportMappingsCommand}"/>
        <KeyBinding Key="S" Modifiers="Control" Command="{Binding SaveMappingsCommand}"/>
        <KeyBinding Key="F5" Command="{Binding TestMappingCommand}"/>
    </Page.InputBindings>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header - Unified Style -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <StackPanel VerticalAlignment="Center" Margin="24,0,0,0">
                    <TextBlock Text="Mapping Editor"
                               FontSize="24"
                               FontWeight="SemiBold"/>
                </StackPanel>

                <!-- Action Buttons -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            VerticalAlignment="Center"
                            Margin="0,0,24,0">

                    <!-- Import Button -->
                    <Button Command="{Binding ImportMappingsCommand}"
                            Style="{StaticResource AccentButtonStyle}"
                            ToolTip="Import mapping rules from JSON file (Ctrl+I)"
                            Margin="0,0,8,0"
                            MinWidth="90">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="Download" Margin="0,0,6,0"/>
                            <TextBlock Text="Import"/>
                        </StackPanel>
                    </Button>

                    <!-- Export Button -->
                    <Button Command="{Binding ExportMappingsCommand}"
                            ToolTip="Export current mapping rules to JSON file (Ctrl+E)"
                            Margin="0,0,8,0"
                            MinWidth="90">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="Upload" Margin="0,0,6,0"/>
                            <TextBlock Text="Export"/>
                        </StackPanel>
                    </Button>

                    <!-- Save Button -->
                    <Button Command="{Binding SaveMappingsCommand}"
                            Style="{StaticResource AccentButtonStyle}"
                            ToolTip="Save mapping rules (Ctrl+S)"
                            MinWidth="90">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="Save" Margin="0,0,6,0"/>
                            <TextBlock Text="Save"/>
                        </StackPanel>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Save Success Message -->
        <Border Grid.Row="0" 
                Background="Green" 
                Padding="12,8"
                Margin="24,0,24,0"
                CornerRadius="4"
                HorizontalAlignment="Center"
                VerticalAlignment="Bottom"
                Visibility="{Binding ShowSaveSuccess, Converter={StaticResource BoolToVisibility}}">
            <TextBlock Text="âœ“ Mapping configuration saved successfully!" 
                       Foreground="White"
                       FontWeight="SemiBold"/>
        </Border>

        <!-- Mapping Set Selection -->
        <Border Grid.Row="1"
                Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                BorderThickness="0"
                CornerRadius="2"
                Padding="16"
                Margin="16,16,16,8">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="Active Mapping Set:"
                           VerticalAlignment="Center"
                           Margin="0,0,12,0"/>

                <ComboBox Grid.Column="1"
                          ItemsSource="{Binding MappingSets}"
                          SelectedItem="{Binding SelectedMappingSet}"
                          DisplayMemberPath="Name"
                          MinWidth="200"/>

                <Button Grid.Column="2"
                        Content="New"
                        Command="{Binding AddMappingSetCommand}"
                        Margin="8,0,4,0"/>

                <Button Grid.Column="3"
                        Content="Delete"
                        Command="{Binding DeleteMappingSetCommand}"
                        Margin="4,0,0,0"/>

                <!-- Name Edit Field for non-system sets -->
                <StackPanel Grid.Row="1" 
                            Grid.ColumnSpan="4" 
                            Margin="0,8,0,0"
                            Visibility="{Binding CanEditCurrentSet, Converter={StaticResource BoolToVisibility}}">
                    <TextBlock Text="Set Name:" Margin="0,0,0,4"/>
                    <TextBox Text="{Binding SelectedMappingSet.Name, UpdateSourceTrigger=PropertyChanged}"
                             IsEnabled="{Binding CanEditCurrentSet}"/>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="2" Margin="16,0,16,16">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="220" MinWidth="180"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*" MinWidth="500"/>
            </Grid.ColumnDefinitions>

            <!-- Source Fields (EXIF) -->
            <Border Grid.Column="0"
                    Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                    CornerRadius="2"
                    BorderThickness="0"
                    Padding="16">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                    </Grid.RowDefinitions>

                    <TextBlock Text="Source Fields"
                               FontSize="16"
                               FontWeight="SemiBold"
                               Margin="0,0,0,12"/>

                    <ScrollViewer Grid.Row="1"
                                  VerticalScrollBarVisibility="Auto">
                        <StackPanel>
                            <!-- QRBridge Fields -->
                            <TextBlock Text="QRBridge Fields"
                                       FontWeight="SemiBold"
                                       Margin="0,0,0,8"
                                       Opacity="0.7"/>
                            <ItemsControl ItemsSource="{Binding QRBridgeFields}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Border Style="{StaticResource SourceFieldStyle}"
                                                ToolTip="{Binding DisplayName}"
                                                PreviewMouseLeftButtonDown="SourceField_MouseLeftButtonDown"
                                                PreviewMouseMove="SourceField_MouseMove">
                                            <TextBlock Text="{Binding FieldName}"/>
                                        </Border>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>

                            <!-- EXIF Fields -->
                            <TextBlock Text="EXIF Fields"
                                       FontWeight="SemiBold"
                                       Margin="0,16,0,8"
                                       Opacity="0.7"/>
                            <ItemsControl ItemsSource="{Binding ExifFields}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Border Style="{StaticResource SourceFieldStyle}"
                                                ToolTip="{Binding DisplayName}"
                                                PreviewMouseLeftButtonDown="SourceField_MouseLeftButtonDown"
                                                PreviewMouseMove="SourceField_MouseMove">
                                            <TextBlock Text="{Binding FieldName}"/>
                                        </Border>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </StackPanel>
                    </ScrollViewer>
                </Grid>
            </Border>

            <!-- Splitter -->
            <GridSplitter Grid.Column="1"
                          Width="5"
                          HorizontalAlignment="Center"
                          VerticalAlignment="Stretch"
                          Background="Transparent"/>

            <!-- Mapping Area -->
            <Border Grid.Column="2"
                    Background="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"
                    BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                    BorderThickness="1"
                    CornerRadius="2"
                    Margin="8,0,0,0"
                    AllowDrop="True"
                    DragOver="MappingArea_DragOver"
                    Drop="MappingArea_Drop">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <Grid Margin="16,16,16,12">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <TextBlock Text="Mapping Rules"
                                   FontSize="16"
                                   FontWeight="SemiBold"/>

                        <StackPanel Grid.Column="1" Orientation="Horizontal">
                            <!-- Test Mapping Button -->
                            <Button Command="{Binding TestMappingCommand}"
                                    ToolTip="Test mapping with sample data (F5)"
                                    Margin="0,0,8,0">
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="â–¶ " FontSize="14"/>
                                    <TextBlock Text="Test"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding BrowseDicomTagsCommand}"
                                    ToolTip="Browse all DICOM tags">
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="ðŸ“‹ " FontSize="14"/>
                                    <TextBlock Text="Browse All Tags..."/>
                                </StackPanel>
                            </Button>
                        </StackPanel>
                    </Grid>

                    <ListBox Grid.Row="1"
                             x:Name="RulesListBox"
                             ItemsSource="{Binding MappingRules}"
                             SelectedItem="{Binding SelectedRule}"
                             ScrollViewer.VerticalScrollBarVisibility="Auto"
                             BorderThickness="0"
                             Background="Transparent"
                             Padding="16,0">
                        <ListBox.ItemContainerStyle>
                            <Style TargetType="ListBoxItem">
                                <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                                <Setter Property="Padding" Value="0"/>
                                <Setter Property="Margin" Value="0,2"/>
                            </Style>
                        </ListBox.ItemContainerStyle>
                        <ListBox.ItemTemplate>
                            <DataTemplate>
                                <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                                        CornerRadius="4"
                                        Padding="12">
                                    <Border.InputBindings>
                                        <MouseBinding Gesture="LeftDoubleClick" 
                                                      Command="{Binding DataContext.BrowseDicomTagsCommand, 
                                                                RelativeSource={RelativeSource AncestorType=Page}}"/>
                                    </Border.InputBindings>
                                    <Border.Style>
                                        <Style TargetType="Border">
                                            <Style.Triggers>
                                                <DataTrigger Binding="{Binding IsSelected, RelativeSource={RelativeSource AncestorType=ListBoxItem}}" Value="True">
                                                    <Setter Property="BorderBrush" Value="{DynamicResource SystemControlHighlightAccentBrush}"/>
                                                    <Setter Property="BorderThickness" Value="2"/>
                                                </DataTrigger>
                                            </Style.Triggers>
                                        </Style>
                                    </Border.Style>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto" MinWidth="120"/>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="Auto"/>
                                        </Grid.ColumnDefinitions>

                                        <!-- Source Field -->
                                        <TextBlock Text="{Binding SourceField}"
                                                   VerticalAlignment="Center"
                                                   FontWeight="SemiBold"
                                                   ToolTip="Double-click to select DICOM tag"/>

                                        <!-- Transform Indicator -->
                                        <TextBlock Grid.Column="1"
                                                   Margin="12,0"
                                                   VerticalAlignment="Center"
                                                   FontSize="14"
                                                   Text="{Binding Transform, Converter={StaticResource TransformToSymbolConverter}}"
                                                   ToolTip="{Binding Transform, Converter={StaticResource TransformToDescriptionConverter}}"/>

                                        <!-- DICOM Tag with Name -->
                                        <StackPanel Grid.Column="2" 
                                                    VerticalAlignment="Center"
                                                    ToolTip="Double-click to edit DICOM tag">
                                            <TextBlock FontFamily="Consolas">
                                                <Run Text="{Binding DicomTagString}"
                                                     Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                                                <Run Text=" - "/>
                                                <Run Text="{Binding DisplayName}"/>
                                            </TextBlock>
                                        </StackPanel>

                                        <!-- Transform Edit Button -->
                                        <Button Grid.Column="3"
                                                Command="{Binding DataContext.EditTransformCommand, 
                                                          RelativeSource={RelativeSource AncestorType=Page}}"
                                                CommandParameter="{Binding}"
                                                Style="{DynamicResource DefaultButtonStyle}"
                                                Width="32"
                                                Height="32"
                                                Padding="0"
                                                Margin="4,0"
                                                ToolTip="Edit transformation">
                                            <TextBlock Text="âš™" FontSize="14"/>
                                        </Button>

                                        <!-- DICOM Tag Edit Button -->
                                        <Button Grid.Column="4"
                                                Command="{Binding DataContext.BrowseDicomTagsCommand, 
                                                          RelativeSource={RelativeSource AncestorType=Page}}"
                                                Style="{DynamicResource DefaultButtonStyle}"
                                                Width="32"
                                                Height="32"
                                                Padding="0"
                                                Margin="4,0"
                                                ToolTip="Browse DICOM tags">
                                            <TextBlock Text="ðŸ“‹" FontSize="14"/>
                                        </Button>

                                        <!-- Delete Button -->
                                        <Button Grid.Column="5"
                                                Command="{Binding DataContext.RemoveRuleCommand, 
                                                          RelativeSource={RelativeSource AncestorType=Page}}"
                                                CommandParameter="{Binding}"
                                                Style="{DynamicResource DefaultButtonStyle}"
                                                Width="32"
                                                Height="32"
                                                Padding="0"
                                                Content="Ã—"
                                                FontSize="16"
                                                FontWeight="Bold"
                                                ToolTip="Remove this rule"/>
                                    </Grid>
                                </Border>
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>

                    <!-- Drag Info -->
                    <TextBlock Grid.Row="2"
                               Text="ðŸ’¡ Drag fields from the left to create mappings â€¢ Press F5 to test"
                               FontSize="12"
                               Opacity="0.6"
                               Margin="0,12,0,16"
                               HorizontalAlignment="Center"/>
                </Grid>
            </Border>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: Views/MappingEditorPage.xaml.cs
--------------------------------------------------------------------------------
Size: 4,69 KB | Lines: 135 | Modified: 2025-06-23 11:53:05
================================================================================

// src/CamBridge.Config/Views/MappingEditorPage.xaml.cs
// Version: 0.7.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Interaction logic for MappingEditorPage.xaml
    /// </summary>
    public partial class MappingEditorPage : Page
    {
        private MappingEditorViewModel? _viewModel;
        private Point _startPoint;
        private bool _isDragging;

        public MappingEditorPage()
        {
            InitializeComponent();
            DataContextChanged += OnDataContextChanged;
            Loaded += OnLoaded;
        }

        #region Rule Selection Event Handlers

        private void RuleItem_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            // When double-clicking a rule, open the DICOM tag browser
            if (_viewModel?.SelectedRule != null && _viewModel.CanEditCurrentSet)
            {
                _viewModel.BrowseDicomTagsCommand.Execute(null);
            }
        }

        #endregion

        private void OnDataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            _viewModel = DataContext as MappingEditorViewModel;
        }

        private async void OnLoaded(object sender, RoutedEventArgs e)
        {
            // Get the ViewModel from DI container if not already set
            if (_viewModel == null)
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<MappingEditorViewModel>();
                    DataContext = _viewModel;
                }
                else
                {
                    // Fallback: Create manually with required services
                    var logger = new Microsoft.Extensions.Logging.Abstractions.NullLogger<MappingEditorViewModel>();
                    var configService = new Services.ConfigurationService();
                    _viewModel = new MappingEditorViewModel(logger, configService);
                    DataContext = _viewModel;
                }
            }

            // Initialize the ViewModel
            if (_viewModel != null)
            {
                await _viewModel.InitializeAsync();
            }
        }

        #region Drag & Drop Event Handlers

        private void SourceField_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            _startPoint = e.GetPosition(null);
        }

        private void SourceField_MouseMove(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed && !_isDragging)
            {
                Point position = e.GetPosition(null);

                if (Math.Abs(position.X - _startPoint.X) > SystemParameters.MinimumHorizontalDragDistance ||
                    Math.Abs(position.Y - _startPoint.Y) > SystemParameters.MinimumVerticalDragDistance)
                {
                    _isDragging = true;

                    // Get the source field data
                    if (sender is FrameworkElement element && element.DataContext is MappingEditorViewModel.SourceFieldInfo fieldInfo)
                    {
                        // Create drag data
                        DataObject dragData = new DataObject("SourceField", fieldInfo);
                        DragDrop.DoDragDrop(element, dragData, DragDropEffects.Copy);
                    }

                    _isDragging = false;
                }
            }
        }

        private void MappingArea_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent("SourceField"))
            {
                e.Effects = DragDropEffects.Copy;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
            e.Handled = true;
        }

        private void MappingArea_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent("SourceField") && _viewModel != null)
            {
                var fieldInfo = e.Data.GetData("SourceField") as MappingEditorViewModel.SourceFieldInfo;
                if (fieldInfo != null && _viewModel.CanEditCurrentSet)
                {
                    // Add new mapping rule with the dropped field
                    _viewModel.AddRuleFromField(fieldInfo);
                }
            }
        }

        #endregion
    }
}


================================================================================
FILE: Views/PipelineConfigPage.xaml
--------------------------------------------------------------------------------
Size: 44,12 KB | Lines: 736 | Modified: 2025-06-21 02:29:44
================================================================================

<!-- src\CamBridge.Config\Views\PipelineConfigPage.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Pipeline Configuration - Fixed Checkbox Spacing -->

<Page x:Class="CamBridge.Config.Views.PipelineConfigPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      xmlns:conv="clr-namespace:CamBridge.Config.Converters"
      xmlns:core="clr-namespace:CamBridge.Core;assembly=CamBridge.Core">

    <Page.Resources>
        <!-- Converters -->
        <conv:BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
        <conv:InverseBooleanToVisibilityConverter x:Key="InverseBoolToVisibility"/>
        <conv:NullToVisibilityConverter x:Key="NullToVisibility"/>

        <!-- Styles -->
        <Style x:Key="SettingHeaderStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Margin" Value="0,16,0,8"/>
        </Style>

        <Style x:Key="SettingLabelStyle" TargetType="TextBlock">
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,0,12,0"/>
            <Setter Property="Width" Value="150"/>
        </Style>

        <Style x:Key="TabHeaderStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Margin" Value="0,0,0,12"/>
        </Style>
    </Page.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="Pipeline Configuration"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>

                <StackPanel Grid.Column="1" 
                            Orientation="Horizontal"
                            HorizontalAlignment="Right"
                            VerticalAlignment="Center"
                            Margin="0,0,24,0">
                    <StackPanel Margin="0,0,16,0" 
                                VerticalAlignment="Center">
                        <TextBlock Text="{Binding Pipelines.Count, StringFormat='{}{0} pipelines configured'}"
                                   HorizontalAlignment="Right"
                                   FontSize="11"
                                   Opacity="0.7"/>
                        <TextBlock HorizontalAlignment="Right"
                                   FontSize="11"
                                   Opacity="0.7">
                            <Run Text="âœ“" Foreground="Green" FontSize="10"/>
                            <Run Text=" Auto-backup enabled"/>
                        </TextBlock>
                    </StackPanel>

                    <Button Command="{Binding SaveAllCommand}"
                            Style="{StaticResource AccentButtonStyle}"
                            MinWidth="140">
                        <StackPanel Orientation="Horizontal">
                            <TextBlock Text="Save All Pipelines" Margin="0,0,8,0"/>
                            <TextBlock Text="(Ctrl+S)" Opacity="0.7" FontSize="11"/>
                        </StackPanel>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="1">
            <Grid.RowDefinitions>
                <RowDefinition Height="*"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <!-- Pipeline Area -->
            <Grid Grid.Row="0" Margin="16,16,16,0">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="320" MinWidth="280"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- Pipeline List -->
                <Border Grid.Column="0"
                    Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                    BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                    BorderThickness="1"
                    CornerRadius="2">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                            <RowDefinition Height="Auto"/>
                        </Grid.RowDefinitions>

                        <!-- List Header -->
                        <Border Grid.Row="0"
                            Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                            BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                            BorderThickness="0,0,0,1"
                            Padding="12,8">
                            <TextBlock Text="Pipelines"
                                   FontSize="14"
                                   FontWeight="SemiBold"/>
                        </Border>

                        <!-- Pipeline Items -->
                        <ListBox Grid.Row="1"
                             ItemsSource="{Binding Pipelines}"
                             SelectedItem="{Binding SelectedPipeline}"
                             BorderThickness="0"
                             ScrollViewer.HorizontalScrollBarVisibility="Disabled">
                            <ListBox.Style>
                                <Style TargetType="ListBox" BasedOn="{StaticResource {x:Type ListBox}}">
                                    <Setter Property="BorderThickness" Value="0"/>
                                </Style>
                            </ListBox.Style>
                            <ListBox.ItemContainerStyle>
                                <Style TargetType="ListBoxItem" BasedOn="{StaticResource DefaultListBoxItemStyle}">
                                    <Setter Property="Padding" Value="10,6"/>
                                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                                    <Setter Property="BorderThickness" Value="0"/>
                                </Style>
                            </ListBox.ItemContainerStyle>
                            <ListBox.ItemTemplate>
                                <DataTemplate>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>

                                        <CheckBox Grid.Column="0"
                                              IsChecked="{Binding Enabled}"
                                              Margin="0,0,8,0"
                                              VerticalAlignment="Center"/>

                                        <StackPanel Grid.Column="1">
                                            <TextBlock Text="{Binding Name}"
                                                   FontWeight="SemiBold"
                                                   TextTrimming="CharacterEllipsis"/>
                                            <TextBlock Text="{Binding WatchSettings.Path}"
                                                   FontSize="11"
                                                   Opacity="0.7"
                                                   TextTrimming="CharacterEllipsis"
                                                   ToolTip="{Binding WatchSettings.Path}"/>
                                        </StackPanel>
                                    </Grid>
                                </DataTemplate>
                            </ListBox.ItemTemplate>
                        </ListBox>

                        <!-- Add Button -->
                        <Border Grid.Row="2"
                            Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                            BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                            BorderThickness="0,1,0,0"
                            Padding="10">
                            <Button Command="{Binding AddPipelineCommand}"
                                HorizontalAlignment="Stretch">
                                <TextBlock Text="+ Add Pipeline"/>
                            </Button>
                        </Border>
                    </Grid>
                </Border>

                <!-- Splitter -->
                <GridSplitter Grid.Column="1"
                          Width="2"
                          HorizontalAlignment="Center"
                          VerticalAlignment="Stretch"
                          Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                          Margin="8,0"/>

                <!-- Pipeline Details -->
                <Grid Grid.Column="2"
                  Margin="8,0,0,0"
                  Visibility="{Binding SelectedPipeline, Converter={StaticResource NullToVisibility}}">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                    </Grid.RowDefinitions>

                    <!-- Pipeline Header -->
                    <Grid Grid.Row="0" Margin="0,0,0,16">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <TextBlock Text="{Binding SelectedPipeline.Name}"
                               FontSize="20"
                               FontWeight="SemiBold"/>

                        <Button Grid.Column="1"
                            Content="Delete Pipeline"
                            Command="{Binding DeletePipelineCommand}"
                            HorizontalAlignment="Right"
                            VerticalAlignment="Center"
                            Foreground="{DynamicResource SystemControlErrorTextForegroundBrush}"/>
                    </Grid>

                    <!-- Configuration Tabs -->
                    <TabControl Grid.Row="1"
                                ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                                Padding="0">

                        <!-- General Tab -->
                        <TabItem Header="General">
                            <ScrollViewer Padding="12">
                                <StackPanel>
                                    <TextBlock Text="Basic Configuration" Style="{StaticResource TabHeaderStyle}"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Pipeline Name:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.Name, UpdateSourceTrigger=PropertyChanged}"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Description:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.Description}"
                                                 TextWrapping="Wrap"
                                                 AcceptsReturn="True"
                                                 Height="60"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Active:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="2" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.Enabled}"
                                                  Content="Enable this pipeline"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="Mapping Set:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="3" Grid.Column="1"
                                                  ItemsSource="{Binding MappingSets}"
                                                  SelectedValue="{Binding SelectedPipeline.MappingSetId}"
                                                  SelectedValuePath="Id"
                                                  DisplayMemberPath="Name"
                                                  HorizontalAlignment="Stretch"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Folders Tab -->
                        <TabItem Header="Folders">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Folder Configuration" Style="{StaticResource TabHeaderStyle}"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Watch Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="0" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.WatchSettings.Path, UpdateSourceTrigger=PropertyChanged}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseWatchFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="File Pattern:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.WatchSettings.FilePattern}"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Subdirectories:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="2" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.WatchSettings.IncludeSubdirectories}"
                                                  Content="Include subdirectories"
                                                  Margin="0,0,0,16"/>

                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="Output Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="3" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.ProcessingOptions.ArchiveFolder, UpdateSourceTrigger=PropertyChanged}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseOutputFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="4" Grid.Column="0"
                                                   Text="Error Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="4" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.ProcessingOptions.ErrorFolder}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseErrorFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="5" Grid.Column="0"
                                                   Text="Dead Letter Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="5" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.ProcessingOptions.DeadLetterFolder}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseDeadLetterFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="6" Grid.Column="0"
                                                   Text="Output Organization:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="6" Grid.Column="1"
                                                  ItemsSource="{Binding OutputOrganizations}"
                                                  SelectedItem="{Binding SelectedPipeline.ProcessingOptions.OutputOrganization}"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- DICOM Tab -->
                        <TabItem Header="DICOM">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="DICOM Overrides (Optional)" Style="{StaticResource TabHeaderStyle}"/>
                                    <TextBlock Text="Leave empty to use global DICOM settings"
                                               FontSize="12"
                                               Opacity="0.7"
                                               Margin="0,0,0,16"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Institution Name:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding SelectedPipelineDicomOverrides.InstitutionName}"
                                                 ui:ControlHelper.PlaceholderText="e.g. Radiology Department"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Department:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipelineDicomOverrides.InstitutionDepartment}"
                                                 ui:ControlHelper.PlaceholderText="e.g. Emergency Room"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Station Name:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="2" Grid.Column="1"
                                                 Text="{Binding SelectedPipelineDicomOverrides.StationName}"
                                                 ui:ControlHelper.PlaceholderText="e.g. ER_WORKSTATION_01"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Processing Tab -->
                        <TabItem Header="Processing">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Processing Options" Style="{StaticResource TabHeaderStyle}"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="File Delay (seconds):"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.WatchSettings.MinimumFileAgeSeconds}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Max Concurrent:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.ProcessingOptions.MaxConcurrentProcessing}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="On Success:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="2" Grid.Column="1"
                                                  ItemsSource="{Binding ProcessingActions}"
                                                  SelectedItem="{Binding SelectedPipeline.ProcessingOptions.SuccessAction}"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="On Failure:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="3" Grid.Column="1"
                                                  ItemsSource="{Binding ProcessingActions}"
                                                  SelectedItem="{Binding SelectedPipeline.ProcessingOptions.FailureAction}"
                                                  Margin="0,0,0,16"/>

                                        <TextBlock Grid.Row="4" Grid.Column="0"
                                                   Text="Retry Options:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="4" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.ProcessingOptions.RetryOnFailure}"
                                                  Content="Enable retry on failure"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="5" Grid.Column="0"
                                                   Text="Max Retries:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="5" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.ProcessingOptions.MaxRetryAttempts}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"
                                                 IsEnabled="{Binding SelectedPipeline.ProcessingOptions.RetryOnFailure}"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="6" Grid.Column="0"
                                                   Text="Backup Files:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="6" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.ProcessingOptions.CreateBackup}"
                                                  Content="Create backup before processing"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="7" Grid.Column="0"
                                                   Text="Process Existing:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="7" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.ProcessingOptions.ProcessExistingOnStartup}"
                                                  Content="Process existing files on startup"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Logging Tab -->
                        <TabItem Header="Logging">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Pipeline-specific Logging" Style="{StaticResource TabHeaderStyle}"/>
                                    <TextBlock Text="Override global logging settings for this pipeline"
                                               FontSize="12"
                                               Opacity="0.7"
                                               Margin="0,0,0,16"/>

                                    <CheckBox Content="Use custom logging for this pipeline"
                                              IsChecked="{Binding UseCustomLogging}"
                                              Margin="0,0,0,16"/>

                                    <Grid IsEnabled="{Binding UseCustomLogging}">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Log Level:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="0" Grid.Column="1"
                                                  ItemsSource="{Binding LogLevels}"
                                                  SelectedItem="{Binding PipelineLogLevel}"
                                                  HorizontalAlignment="Left"
                                                  Width="200"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Log Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="1" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding PipelineLogFolder}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseLogFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Retention Days:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="2" Grid.Column="1"
                                                 Text="{Binding PipelineLogRetentionDays}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Notifications Tab -->
                        <TabItem Header="Notifications">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Pipeline-specific Notifications" Style="{StaticResource TabHeaderStyle}"/>
                                    <TextBlock Text="Configure alerts and notifications for this pipeline"
                                               FontSize="12"
                                               Opacity="0.7"
                                               Margin="0,0,0,16"/>

                                    <CheckBox Content="Override global notification settings"
                                              IsChecked="{Binding UseCustomNotifications}"
                                              Margin="0,0,0,16"/>

                                    <Grid IsEnabled="{Binding UseCustomNotifications}">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Email To:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding PipelineEmailTo}"
                                                 ui:ControlHelper.PlaceholderText="dept@hospital.com;manager@hospital.com"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Alert Level:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="1" Grid.Column="1"
                                                  ItemsSource="{Binding NotificationLevels}"
                                                  SelectedItem="{Binding PipelineAlertLevel}"
                                                  HorizontalAlignment="Left"
                                                  Width="200"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Daily Summary:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="2" Grid.Column="1"
                                                  IsChecked="{Binding PipelineSendDailySummary}"
                                                  Content="Send daily processing summary"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="Alert on Errors:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="3" Grid.Column="1"
                                                  IsChecked="{Binding PipelineAlertOnErrors}"
                                                  Content="Send immediate alerts for errors"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                    </TabControl>
                </Grid>

                <!-- No Selection Message -->
                <Grid Grid.Column="2"
                  Margin="8,0,0,0"
                  Visibility="{Binding SelectedPipeline, Converter={StaticResource NullToVisibility}, ConverterParameter=Inverse}"
                  VerticalAlignment="Center"
                  HorizontalAlignment="Center">
                    <StackPanel MaxWidth="400">
                        <TextBlock Text="No Pipeline Selected"
                               FontSize="18"
                               Opacity="0.5"
                               HorizontalAlignment="Center"/>
                        <TextBlock Text="Select a pipeline from the list or create a new one"
                               FontSize="13"
                               Opacity="0.5"
                               Margin="0,8,0,0"
                               HorizontalAlignment="Center"
                               TextWrapping="Wrap"
                               TextAlignment="Center"/>
                    </StackPanel>
                </Grid>
            </Grid>

            <!-- Status Bar -->
            <Border Grid.Row="1"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Height="28">
                <Grid Margin="16,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <!-- Loading -->
                    <ui:ProgressRing Grid.Column="0"
                                 IsActive="{Binding IsLoading}"
                                 Width="12"
                                 Height="12"
                                 Margin="0,0,8,0"
                                 Visibility="{Binding IsLoading, Converter={StaticResource BoolToVisibility}}"/>

                    <!-- Status -->
                    <TextBlock Grid.Column="1"
                           Text="{Binding StatusMessage}"
                           VerticalAlignment="Center"
                           FontSize="11"
                           Opacity="0.8"
                           Visibility="{Binding StatusMessage, Converter={StaticResource NullToVisibility}}"/>

                    <!-- Changes -->
                    <TextBlock Grid.Column="2"
                           FontSize="11"
                           Opacity="0.8"
                           VerticalAlignment="Center"
                           Visibility="{Binding HasUnsavedChanges, Converter={StaticResource BoolToVisibility}}">
                    <Run Text="â—" Foreground="Orange" FontSize="8"/>
                    <Run Text=" Unsaved changes"/>
                    </TextBlock>
                </Grid>
            </Border>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: Views/PipelineConfigPage.xaml.cs
--------------------------------------------------------------------------------
Size: 4,95 KB | Lines: 142 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Views\PipelineConfigPage.xaml.cs
// Version: 0.7.27
// Description: Pipeline Configuration page - Code Behind

using System;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using System.Diagnostics;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Pipeline Configuration page - Zero Global Settings!
    /// NavigationService ALREADY injects the ViewModel, so we just need to initialize it
    /// </summary>
    [SupportedOSPlatform("windows")]
    public partial class PipelineConfigPage : Page
    {
        public PipelineConfigPage()
        {
            InitializeComponent();

            // Use Loaded event instead of OnInitialized to ensure NavigationService has done its job
            this.Loaded += Page_Loaded;
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            // Only run once
            this.Loaded -= Page_Loaded;

            Debug.WriteLine("=== PipelineConfigPage Loaded ===");

            // NavigationService should have already set our DataContext
            if (DataContext is PipelineConfigViewModel vm)
            {
                Debug.WriteLine("ViewModel found! Initializing...");
                try
                {
                    await vm.InitializeAsync();
                    Debug.WriteLine($"Initialization complete. Pipelines: {vm.Pipelines.Count}");
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Initialization failed: {ex.Message}");
                    MessageBox.Show(
                        $"Failed to load pipeline configuration:\n{ex.Message}",
                        "Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                }
            }
            else
            {
                Debug.WriteLine($"ERROR: DataContext is {DataContext?.GetType().Name ?? "null"} - expected PipelineConfigViewModel");

                // Fallback - try to get it ourselves
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    var viewModel = app.Host.Services.GetRequiredService<PipelineConfigViewModel>();
                    DataContext = viewModel;
                    await viewModel.InitializeAsync();
                }
            }
        }

        // Browse button handlers
        private void BrowseWatchFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Watch Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.WatchSettings.Path = path;
                }
            });
        }

        private void BrowseOutputFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Output Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.ProcessingOptions.ArchiveFolder = path;
                }
            });
        }

        private void BrowseErrorFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Error Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.ProcessingOptions.ErrorFolder = path;
                }
            });
        }

        private void BrowseDeadLetterFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Dead Letter Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.ProcessingOptions.DeadLetterFolder = path;
                }
            });
        }

        private void BrowseLogFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Log Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm)
                {
                    vm.PipelineLogFolder = path;
                }
            });
        }

        private void BrowseFolder(string description, Action<string> setPath)
        {
            var dialog = new System.Windows.Forms.FolderBrowserDialog
            {
                Description = description,
                ShowNewFolderButton = true
            };

            if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                setPath(dialog.SelectedPath);
            }
        }
    }
}


================================================================================
FILE: Views/ServiceControlPage.xaml
--------------------------------------------------------------------------------
Size: 10,39 KB | Lines: 190 | Modified: 2025-06-20 22:27:08
================================================================================

<!-- src/CamBridge.Config/Views/ServiceControlPage.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Service Control - Uniform Design without Borders -->

<Page x:Class="CamBridge.Config.Views.ServiceControlPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Unloaded="Page_Unloaded">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header wie Mapping Editor -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <TextBlock Text="Service Control"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>
            </Grid>
        </Border>

        <!-- Main Content -->
        <ScrollViewer Grid.Row="1">
            <Grid Margin="16,16,16,0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <!-- Admin Warning -->
                <Border Grid.Row="0" Margin="0,0,0,16" Padding="12" CornerRadius="2"
                        Background="#FFF3CD" BorderThickness="0"
                        Visibility="{Binding RequiresElevation, Converter={StaticResource BooleanToVisibilityConverter}}">
                    <StackPanel Orientation="Horizontal">
                        <ui:SymbolIcon Symbol="Important" Margin="0,0,8,0"/>
                        <TextBlock Text="Administrator privileges required for service control" 
                                  VerticalAlignment="Center"/>
                    </StackPanel>
                </Border>

                <!-- Service Status Card -->
                <Border Grid.Row="1" CornerRadius="2" Margin="0,0,0,16"
                        Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        BorderThickness="0">
                    <Grid Margin="16,12">
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                        </Grid.RowDefinitions>

                        <!-- Status Display -->
                        <StackPanel Orientation="Horizontal" Margin="0,0,0,16">
                            <Ellipse Width="16" Height="16" Margin="0,0,12,0">
                                <Ellipse.Style>
                                    <Style TargetType="Ellipse">
                                        <Setter Property="Fill" Value="Gray"/>
                                        <Style.Triggers>
                                            <DataTrigger Binding="{Binding StatusColor}" Value="Green">
                                                <Setter Property="Fill" Value="#28A745"/>
                                            </DataTrigger>
                                            <DataTrigger Binding="{Binding StatusColor}" Value="Orange">
                                                <Setter Property="Fill" Value="#FFC107"/>
                                            </DataTrigger>
                                            <DataTrigger Binding="{Binding StatusColor}" Value="Red">
                                                <Setter Property="Fill" Value="#DC3545"/>
                                            </DataTrigger>
                                        </Style.Triggers>
                                    </Style>
                                </Ellipse.Style>
                            </Ellipse>
                            <TextBlock Text="CamBridge Service Status:" FontSize="16" Margin="0,0,8,0"/>
                            <TextBlock Text="{Binding StatusText}" FontSize="16" FontWeight="SemiBold"/>
                        </StackPanel>

                        <!-- Uptime Display -->
                        <TextBlock Grid.Row="1" Margin="28,0,0,16" FontSize="14" Opacity="0.7"
                                  Visibility="{Binding Uptime, Converter={StaticResource NullToVisibilityConverter}}">
                            <Run Text="Uptime:"/>
                            <Run Text="{Binding Uptime}"/>
                        </TextBlock>

                        <!-- Control Buttons -->
                        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="0,8,0,0">
                            <!-- Install Service Button âœ… VORHANDEN! -->
                            <Button Command="{Binding InstallServiceCommand}" 
                                    Visibility="{Binding IsServiceInstalled, 
                                               Converter={StaticResource InverseBooleanToVisibilityConverter}}"
                                    Margin="0,0,8,0" MinWidth="140"
                                    Style="{StaticResource AccentButtonStyle}">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Add" Margin="0,0,8,0"/>
                                    <TextBlock Text="Install Service"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding StartServiceCommand}" 
                                    IsEnabled="{Binding CanStart}"
                                    Margin="0,0,8,0" MinWidth="120">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Play" Margin="0,0,8,0"/>
                                    <TextBlock Text="Start Service"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding StopServiceCommand}"
                                    IsEnabled="{Binding CanStop}"
                                    Margin="0,0,8,0" MinWidth="120">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Stop" Margin="0,0,8,0"/>
                                    <TextBlock Text="Stop Service"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding RestartServiceCommand}"
                                    IsEnabled="{Binding CanRestart}"
                                    MinWidth="120">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Refresh" Margin="0,0,8,0"/>
                                    <TextBlock Text="Restart Service"/>
                                </StackPanel>
                            </Button>
                        </StackPanel>

                        <!-- Loading Indicator -->
                        <ui:ProgressRing Grid.Row="2" IsActive="{Binding IsLoading}" 
                                       Width="24" Height="24"
                                       HorizontalAlignment="Right" VerticalAlignment="Center"/>

                        <!-- Not Installed Message -->
                        <TextBlock Grid.Row="3" Margin="0,16,0,0"
                                  Foreground="{DynamicResource SystemControlForegroundBaseMediumBrush}"
                                  Visibility="{Binding IsServiceInstalled, 
                                             Converter={StaticResource InverseBooleanToVisibilityConverter}}">
                            <Run Text="The CamBridge Windows Service is not installed. Click"/>
                            <Run Text="Install Service" FontWeight="SemiBold"/>
                            <Run Text="above to install it."/>
                        </TextBlock>
                    </Grid>
                </Border>

                <!-- Quick Actions -->
                <Border Grid.Row="2" CornerRadius="2"
                        Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        BorderThickness="0">
                    <StackPanel Margin="16,12">
                        <TextBlock Text="Quick Actions" FontSize="16" FontWeight="SemiBold" Margin="0,0,0,12"/>

                        <StackPanel Orientation="Horizontal">
                            <Button Command="{Binding OpenServicesCommand}" Margin="0,0,8,0">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Setting" Margin="0,0,8,0"/>
                                    <TextBlock Text="Windows Services"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding OpenEventViewerCommand}" Margin="0,0,8,0">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Document" Margin="0,0,8,0"/>
                                    <TextBlock Text="Event Viewer"/>
                                </StackPanel>
                            </Button>

                            <!-- Uninstall Button âœ… VORHANDEN! -->
                            <Button Command="{Binding UninstallServiceCommand}"
                                    Visibility="{Binding IsServiceInstalled, 
                                               Converter={StaticResource BooleanToVisibilityConverter}}">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Delete" Margin="0,0,8,0"/>
                                    <TextBlock Text="Uninstall Service"/>
                                </StackPanel>
                            </Button>
                        </StackPanel>
                    </StackPanel>
                </Border>
            </Grid>
        </ScrollViewer>
    </Grid>
</Page>


================================================================================
FILE: Views/ServiceControlPage.xaml.cs
--------------------------------------------------------------------------------
Size: 2,04 KB | Lines: 61 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Views\ServiceControlPage.xaml.cs
// Version: 0.5.26 - Fixed: Using Cleanup() instead of Dispose()

using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Windows;
using System.Windows.Controls;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Service control page for managing the Windows Service
    /// </summary>
    public partial class ServiceControlPage : Page
    {
        private ServiceControlViewModel? _viewModel;

        public ServiceControlPage()
        {
            InitializeComponent();

            // Get ViewModel from DI container
            try
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<ServiceControlViewModel>();
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("ServiceControlViewModel loaded from DI container");
                }
                else
                {
                    // Fallback if DI not available
                    var serviceManager = new Services.ServiceManager();
                    _viewModel = new ServiceControlViewModel(serviceManager);
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("ServiceControlViewModel created manually (fallback)");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating ServiceControlViewModel: {ex.Message}");
            }
        }

        // Fixed: Using Cleanup() instead of Dispose()
        private void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            // Cleanup the ViewModel
            _viewModel?.Cleanup();
            _viewModel = null;

            System.Diagnostics.Debug.WriteLine("ServiceControlPage cleanup completed");
        }
    }
}


================================================================================
FILE: Views/VogonPoetryWindow.xaml
--------------------------------------------------------------------------------
Size: 10,72 KB | Lines: 200 | Modified: 2025-06-10 23:55:40
================================================================================

<Window x:Class="CamBridge.Config.Views.VogonPoetryWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="http://schemas.modernwpf.com/2019"
        ui:WindowHelper.UseModernWindowStyle="True"
        Title="*** AMIGA VOGON POETRY DEMO v4.2 ***" 
        Height="600" Width="800"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#FFB0B0B0">

    <Window.Resources>
        <!-- Boing Ball Animation - AUTHENTIC -->
        <Storyboard x:Key="BoingBallAnimation">
            <!-- Ball bouncing horizontal - 8 seconds full cycle -->
            <DoubleAnimationUsingKeyFrames Storyboard.TargetName="BoingBall" 
                                         Storyboard.TargetProperty="(Canvas.Left)"
                                         RepeatBehavior="Forever">
                <LinearDoubleKeyFrame KeyTime="0:0:0" Value="50"/>
                <LinearDoubleKeyFrame KeyTime="0:0:4" Value="650"/>
                <LinearDoubleKeyFrame KeyTime="0:0:8" Value="50"/>
            </DoubleAnimationUsingKeyFrames>

            <!-- Ball bouncing vertical -->
            <DoubleAnimationUsingKeyFrames Storyboard.TargetName="BoingBall" 
                                         Storyboard.TargetProperty="(Canvas.Top)"
                                         RepeatBehavior="Forever">
                <LinearDoubleKeyFrame KeyTime="0:0:0" Value="350"/>
                <LinearDoubleKeyFrame KeyTime="0:0:4" Value="50"/>
                <LinearDoubleKeyFrame KeyTime="0:0:8" Value="350"/>
            </DoubleAnimationUsingKeyFrames>

            <!-- Sprite frame animation handled in code-behind -->
        </Storyboard>

        <!-- Scrolling Text Animation - SLOWER -->
        <Storyboard x:Key="ScrollTextAnimation">
            <DoubleAnimation Storyboard.TargetName="ScrollingText" 
                           Storyboard.TargetProperty="(Canvas.Left)"
                           From="800" To="-2000" Duration="0:0:30" 
                           RepeatBehavior="Forever"/>
        </Storyboard>

        <!-- Rainbow Color Animation - SLOWER -->
        <Storyboard x:Key="RainbowAnimation">
            <ColorAnimationUsingKeyFrames Storyboard.TargetName="RainbowBrush" 
                                        Storyboard.TargetProperty="Color"
                                        RepeatBehavior="Forever">
                <LinearColorKeyFrame KeyTime="0:0:0" Value="#FF0000"/>
                <LinearColorKeyFrame KeyTime="0:0:2" Value="#FF7F00"/>
                <LinearColorKeyFrame KeyTime="0:0:4" Value="#FFFF00"/>
                <LinearColorKeyFrame KeyTime="0:0:6" Value="#00FF00"/>
                <LinearColorKeyFrame KeyTime="0:0:8" Value="#0000FF"/>
                <LinearColorKeyFrame KeyTime="0:0:10" Value="#4B0082"/>
                <LinearColorKeyFrame KeyTime="0:0:12" Value="#9400D3"/>
                <LinearColorKeyFrame KeyTime="0:0:14" Value="#FF0000"/>
            </ColorAnimationUsingKeyFrames>
        </Storyboard>
    </Window.Resources>

    <Grid>
        <!-- Purple Grid Background like original Amiga demo -->
        <Canvas Panel.ZIndex="1">
            <Canvas.Background>
                <DrawingBrush TileMode="Tile" Viewport="0,0,50,50" ViewportUnits="Absolute">
                    <DrawingBrush.Drawing>
                        <DrawingGroup>
                            <GeometryDrawing Brush="Transparent">
                                <GeometryDrawing.Geometry>
                                    <RectangleGeometry Rect="0,0,50,50"/>
                                </GeometryDrawing.Geometry>
                            </GeometryDrawing>
                            <GeometryDrawing>
                                <GeometryDrawing.Pen>
                                    <Pen Brush="#FF9B009B" Thickness="2"/>
                                </GeometryDrawing.Pen>
                                <GeometryDrawing.Geometry>
                                    <GeometryGroup>
                                        <LineGeometry StartPoint="0,0" EndPoint="0,50"/>
                                        <LineGeometry StartPoint="0,0" EndPoint="50,0"/>
                                    </GeometryGroup>
                                </GeometryDrawing.Geometry>
                            </GeometryDrawing>
                        </DrawingGroup>
                    </DrawingBrush.Drawing>
                </DrawingBrush>
            </Canvas.Background>

            <!-- Grid floor perspective lines -->
            <Line X1="400" Y1="600" X2="100" Y2="380" Stroke="#FF9B009B" StrokeThickness="2"/>
            <Line X1="400" Y1="600" X2="700" Y2="380" Stroke="#FF9B009B" StrokeThickness="2"/>
            <Line X1="0" Y1="380" X2="800" Y2="380" Stroke="#FF9B009B" StrokeThickness="2"/>
        </Canvas>

        <Canvas Panel.ZIndex="5">
            <!-- Amiga Boing Ball - SPRITE ANIMATION STYLE -->
            <Image x:Name="BoingBall" Canvas.Left="50" Canvas.Top="300" 
                   Width="100" Height="100" RenderTransformOrigin="0.5,0.5">
                <Image.RenderTransform>
                    <TransformGroup>
                        <!-- Slight tilt for authentic look -->
                        <RotateTransform Angle="15"/>
                    </TransformGroup>
                </Image.RenderTransform>

                <!-- WriteableBitmap will be set in code-behind for sprite animation -->
            </Image>

            <!-- Scrolling Text -->
            <TextBlock x:Name="ScrollingText" Canvas.Left="800" Canvas.Top="20"
                      FontFamily="Courier New" FontSize="32" FontWeight="Bold" Panel.ZIndex="60">
                <TextBlock.Foreground>
                    <SolidColorBrush x:Name="RainbowBrush" Color="Red"/>
                </TextBlock.Foreground>
                <Run Text="*** VOGON POETRY CREW PRESENTS: THE ANSWER IS 42! *** GREETINGS TO DOUGLAS ADAMS *** DON'T PANIC *** AMIGA RULEZ *** "/>
            </TextBlock>

            <!-- Main Content Area - Text Box -->
            <Border Canvas.Left="50" Canvas.Top="80" Width="700" Height="200"
                    Background="#66000033" BorderBrush="#FF00FF00" BorderThickness="2" Panel.ZIndex="10">
                <ScrollViewer VerticalScrollBarVisibility="Auto" Padding="20">
                    <StackPanel>
                        <TextBlock FontFamily="Consolas" FontSize="20" Foreground="#FFFF00"
                                  Text="VOGON POETRY DEMO v4.2" HorizontalAlignment="Center"/>
                        <TextBlock FontFamily="Consolas" FontSize="14" Foreground="#00FF00"
                                  Text="=====================================" HorizontalAlignment="Center"
                                  Margin="0,0,0,20"/>

                        <TextBlock FontFamily="Consolas" FontSize="14" 
                                  LineHeight="20" TextWrapping="Wrap">
                            <Run Foreground="#00FFFF">Oh freddled gruntbuggly, thy DICOM tags are to me</Run>
                            <LineBreak/>
                            <Run Foreground="#00FFFF">As plurdled gabbleblotchits on a lurgid JPEG tree.</Run>
                            <LineBreak/><LineBreak/>
                            
                            <Run Foreground="#FF00FF">Groop, I implore thee, my foonting turlingdromes,</Run>
                            <LineBreak/>
                            <Run Foreground="#FF00FF">And hooptiously drangle me with crinkly EXIF gnomes;</Run>
                            <LineBreak/><LineBreak/>
                            
                            <Run Foreground="#FFFF00">Or I will rend thee in the gobberwarts with my blurglecruncheon,</Run>
                            <LineBreak/>
                            <Run Foreground="#FFFF00">See if thy Patient ID survives the compression!</Run>
                            <LineBreak/><LineBreak/>
                            
                            <Run Text="-- Prostetnic Vogon Jeltz" Foreground="#808080"/>
                        </TextBlock>
                    </StackPanel>
                </ScrollViewer>
            </Border>

            <!-- ERROR HAIKU Box -->
            <Border Canvas.Left="200" Canvas.Top="300" Width="400" Height="80"
                    Background="#66330000" BorderBrush="#FFFF0000" BorderThickness="2" Panel.ZIndex="10">
                <TextBlock FontFamily="Consolas" FontSize="14" 
                          HorizontalAlignment="Center" VerticalAlignment="Center"
                          TextAlignment="Center">
                    <Run Text="ERROR HAIKU:" Foreground="#FF0000" FontWeight="Bold"/>
                    <LineBreak/>
                    <Run Foreground="#FFA500">Dead letter queue full</Run>
                    <LineBreak/>
                    <Run Foreground="#FFA500">DICOM validation fails</Run>
                    <LineBreak/>
                    <Run Foreground="#FFA500">Forty-two errors</Run>
                </TextBlock>
            </Border>

            <!-- Bottom Raster Bars -->
            <Rectangle Canvas.Left="0" Canvas.Top="480" Width="800" Height="10" Panel.ZIndex="90">
                <Rectangle.Fill>
                    <LinearGradientBrush StartPoint="0,0" EndPoint="1,0">
                        <GradientStop Color="#FF0000" Offset="0"/>
                        <GradientStop Color="#FFFF00" Offset="0.2"/>
                        <GradientStop Color="#00FF00" Offset="0.4"/>
                        <GradientStop Color="#00FFFF" Offset="0.6"/>
                        <GradientStop Color="#0000FF" Offset="0.8"/>
                        <GradientStop Color="#FF00FF" Offset="1"/>
                    </LinearGradientBrush>
                </Rectangle.Fill>
            </Rectangle>
        </Canvas>

        <!-- Control Buttons (Retro Style) -->
        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" 
                    VerticalAlignment="Bottom" Margin="0,0,0,20" Panel.ZIndex="200">
            <Button x:Name="AppreciateButton" Content="[ APPRECIATE ]" 
                    FontFamily="Consolas" FontSize="16"
                    Background="#FF0080FF" Foreground="White"
                    Padding="20,10" Margin="10,0"
                    Click="AppreciateButton_Click"/>

            <Button x:Name="PanicButton" Content="[ PANIC! ]" 
                    FontFamily="Consolas" FontSize="16"
                    Background="#FFFF0000" Foreground="White"
                    Padding="20,10" Margin="10,0"
                    Click="CloseButton_Click"/>
        </StackPanel>
    </Grid>
</Window>


================================================================================
FILE: Views/VogonPoetryWindow.xaml.cs
--------------------------------------------------------------------------------
Size: 9,04 KB | Lines: 259 | Modified: 2025-06-23 11:53:05
================================================================================

// src\CamBridge.Config\Views\VogonPoetryWindow.xaml.cs
// Version: 0.5.26
// Fixed: Nullable warnings resolved

using System;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Imaging;
using System.Windows.Threading;

namespace CamBridge.Config.Views
{
    [SupportedOSPlatform("windows")]
    public partial class VogonPoetryWindow : Window
    {
        private Storyboard? _boingBallAnimation;
        private Storyboard? _scrollTextAnimation;
        private Storyboard? _rainbowAnimation;

        // Sprite animation members
        private WriteableBitmap? _ballBitmap;
        private DispatcherTimer? _spriteTimer;
        private int _currentFrame = 0;
        private const int TOTAL_FRAMES = 24;
        private bool _movingRight = true;
        private double _lastXPosition = 50;
        private byte[]? _pixelBuffer;
        private readonly int _stride = 100 * 4; // Width * BytesPerPixel

        public VogonPoetryWindow()
        {
            InitializeComponent();

            try
            {
                // Initialize sprite bitmap
                InitializeSpriteBitmap();

                // Start all the retro animations
                _boingBallAnimation = FindResource("BoingBallAnimation") as Storyboard;
                _scrollTextAnimation = FindResource("ScrollTextAnimation") as Storyboard;
                _rainbowAnimation = FindResource("RainbowAnimation") as Storyboard;

                if (_boingBallAnimation != null) _boingBallAnimation.Begin();
                if (_scrollTextAnimation != null) _scrollTextAnimation.Begin();
                if (_rainbowAnimation != null) _rainbowAnimation.Begin();

                // Initialize sprite animation timer
                _spriteTimer = new DispatcherTimer
                {
                    Interval = TimeSpan.FromMilliseconds(50) // 20 FPS
                };
                _spriteTimer.Tick += OnSpriteTimerTick;
                _spriteTimer.Start();

                // Track ball movement direction
                CompositionTarget.Rendering += TrackBallDirection;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing Vogon Poetry Window: {ex.Message}\n\n{ex.StackTrace}",
                    "Initialization Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void InitializeSpriteBitmap()
        {
            try
            {
                // Create a 100x100 WriteableBitmap
                _ballBitmap = new WriteableBitmap(100, 100, 96, 96, PixelFormats.Bgra32, null);
                _pixelBuffer = new byte[100 * 100 * 4]; // Width * Height * BytesPerPixel

                if (BoingBall == null)
                {
                    MessageBox.Show("BoingBall Image element not found!", "Error");
                    return;
                }

                BoingBall.Source = _ballBitmap;

                // Draw initial frame
                DrawBoingBallFrame(0);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing sprite: {ex.Message}", "Error");
            }
        }

        private void DrawBoingBallFrame(int frame)
        {
            if (_ballBitmap == null || _pixelBuffer == null) return;

            try
            {
                // Clear buffer to transparent
                Array.Clear(_pixelBuffer, 0, _pixelBuffer.Length);

                // Calculate rotation angle
                double angle = (frame / (double)TOTAL_FRAMES) * 360.0;
                double rotRad = angle * Math.PI / 180.0;

                int centerX = 50;
                int centerY = 50;
                int radius = 45;

                // Draw the ball
                for (int y = 0; y < 100; y++)
                {
                    for (int x = 0; x < 100; x++)
                    {
                        double dx = x - centerX;
                        double dy = y - centerY;
                        double distance = Math.Sqrt(dx * dx + dy * dy);

                        if (distance <= radius)
                        {
                            // Calculate 3D sphere coordinates
                            double z = Math.Sqrt(radius * radius - distance * distance);
                            double nx = dx / radius;
                            double ny = dy / radius;
                            double nz = z / radius;

                            // Map to texture coordinates with rotation
                            double u = Math.Atan2(ny, nx) + rotRad;
                            double v = Math.Acos(nz);

                            // Create checkerboard pattern
                            int checkerSize = 8;
                            int checkerU = (int)(u * radius / checkerSize) % 2;
                            int checkerV = (int)(v * radius / checkerSize) % 2;

                            // Add shading
                            double lightIntensity = 0.3 + 0.7 * Math.Max(0, nz);

                            int pixelIndex = (y * 100 + x) * 4;

                            if ((checkerU + checkerV) % 2 == 0)
                            {
                                // Red squares
                                _pixelBuffer[pixelIndex + 0] = (byte)(204 * lightIntensity); // B
                                _pixelBuffer[pixelIndex + 1] = 0; // G
                                _pixelBuffer[pixelIndex + 2] = 0; // R
                                _pixelBuffer[pixelIndex + 3] = 255; // A
                            }
                            else
                            {
                                // White squares
                                byte white = (byte)(255 * lightIntensity);
                                _pixelBuffer[pixelIndex + 0] = white; // B
                                _pixelBuffer[pixelIndex + 1] = white; // G
                                _pixelBuffer[pixelIndex + 2] = white; // R
                                _pixelBuffer[pixelIndex + 3] = 255; // A
                            }
                        }
                    }
                }

                // Write pixels to bitmap
                _ballBitmap.WritePixels(
                    new Int32Rect(0, 0, 100, 100),
                    _pixelBuffer,
                    _stride,
                    0);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error drawing frame: {ex.Message}");
            }
        }

        private void TrackBallDirection(object? sender, EventArgs e)
        {
            try
            {
                if (BoingBall == null) return;

                double currentX = Canvas.GetLeft(BoingBall);

                if (double.IsNaN(currentX))
                    return;

                if (currentX > _lastXPosition)
                {
                    _movingRight = true;
                }
                else if (currentX < _lastXPosition)
                {
                    _movingRight = false;
                }

                _lastXPosition = currentX;
            }
            catch
            {
                // Ignore errors
            }
        }

        private void OnSpriteTimerTick(object? sender, EventArgs e)
        {
            if (_movingRight)
            {
                _currentFrame = (_currentFrame + 1) % TOTAL_FRAMES;
            }
            else
            {
                _currentFrame = (_currentFrame - 1 + TOTAL_FRAMES) % TOTAL_FRAMES;
            }

            DrawBoingBallFrame(_currentFrame);
        }

        private void AppreciateButton_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show(
                "GURU MEDITATION #00000042.00000042\n\n" +
                "Your appreciation has been noted in sector 42.\n" +
                "Please insert disk 2 to continue.\n\n" +
                "Software Failure. Press left mouse button to continue.\n" +
                "Guru Meditation #DEADBEEF.CAFEBABE",
                "AMIGA SYSTEM ERROR",
                MessageBoxButton.OK,
                MessageBoxImage.Error);

            DialogResult = true;
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        protected override void OnClosed(EventArgs e)
        {
            try
            {
                _spriteTimer?.Stop();
                CompositionTarget.Rendering -= TrackBallDirection;

                _boingBallAnimation?.Stop();
                _scrollTextAnimation?.Stop();
                _rainbowAnimation?.Stop();
            }
            catch
            {
                // Ignore cleanup errors
            }

            base.OnClosed(e);
        }
    }
}

