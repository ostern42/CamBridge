# CamBridge Sources - CONFIG
# Generated: 2025-07-01 14:22:48
# Version: 0.7.11
# Purpose: Complete source code for project knowledge
# Token-efficient access to all implementations


================================================================================
FILE: src\CamBridge.Config\App.xaml.cs
================================================================================

// src\CamBridge.Config\App.xaml.cs
// Version: 0.8.5
// Description: Application entry point with refactored ViewModels and DicomStoreService
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Threading;
using CamBridge.Config.Services;
using CamBridge.Config.ViewModels;
using CamBridge.Config.Views;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace CamBridge.Config
{
    /// <summary>
    /// Main application class
    /// </summary>
    public partial class App : Application
    {
        private IHost? _host;

        /// <summary>
        /// Gets the current host instance
        /// </summary>
        public IHost? Host => _host;

        /// <summary>
        /// Gets the current service provider
        /// </summary>
        public static IServiceProvider Services { get; private set; } = null!;

        /// <summary>
        /// Application startup
        /// </summary>
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // Setup global exception handlers
            AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;
            DispatcherUnhandledException += OnDispatcherUnhandledException;

            try
            {
                ConfigureHost();
            }
            catch (Exception ex)
            {
                LogException("Host configuration failed", ex);
                MessageBox.Show(
                    $"Failed to start application: {ex.Message}",
                    "Startup Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
                Shutdown(1);
            }
        }

        /// <summary>
        /// Configure the dependency injection host
        /// </summary>
        private void ConfigureHost()
        {
            // Verify config file exists - Added in v0.5.32
            var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            var configPath = System.IO.Path.Combine(appDataPath, "CamBridge", "appsettings.json");

            if (!System.IO.File.Exists(configPath))
            {
                // Also check ProgramData (where Service saves config)
                var programDataPath = System.IO.Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                    "CamBridge",
                    "appsettings.json");

                if (System.IO.File.Exists(programDataPath))
                {
                    configPath = programDataPath;
                }
                else
                {
                    MessageBox.Show(
                        $"Configuration file not found.\nExpected at: {configPath}\n\nPlease run the service first to create initial configuration.",
                        "Configuration Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                }
            }

            _host = Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder()
                .ConfigureServices((context, services) =>
                {
                    // Configuration
                    var configuration = context.Configuration;

                    // Core Services
                    services.AddSingleton<INavigationService, NavigationService>();
                    services.AddSingleton<IServiceManager, ServiceManager>();
                    services.AddSingleton<IConfigurationService, ConfigurationService>();

                    // NEW: Pipeline Settings Service (Session 95)
                    services.AddSingleton<IPipelineSettingsService, PipelineSettingsService>();

                    // HttpClient for API calls - FIXED PORT!
                    services.AddHttpClient<IApiService, HttpApiService>(client =>
                    {
                        // CRITICAL: Use port 5111, not 5050!
                        client.BaseAddress = new Uri("http://localhost:5111/");
                        client.Timeout = TimeSpan.FromSeconds(5);
                    });

                    // Infrastructure Services
                    // CRITICAL: DicomStoreService was missing! This is why Test Connection never worked!
                    services.AddSingleton<DicomStoreService>(); // NEW - Session 95 discovery!

                    // ViewModels - Updated with refactored ViewModels
                    services.AddTransient<MainViewModel>();
                    services.AddTransient<DashboardViewModel>();
                    services.AddTransient<ServiceControlViewModel>();

                    // NEW: PacsConfigViewModel (Session 95)
                    services.AddTransient<PacsConfigViewModel>();

                    // UPDATED: PipelineConfigViewModel with new dependencies
                    services.AddTransient<PipelineConfigViewModel>(provider =>
                        new PipelineConfigViewModel(
                            provider.GetRequiredService<IConfigurationService>(),
                            provider.GetRequiredService<IPipelineSettingsService>(),
                            provider.GetRequiredService<PacsConfigViewModel>()));

                    services.AddTransient<DeadLettersViewModel>();
                    services.AddTransient<MappingEditorViewModel>();
                    services.AddTransient<LogViewerViewModel>();

                    // Views - Registration for pages
                    services.AddTransient<LogViewerPage>();

                    // Logging
                    services.AddLogging(configure =>
                    {
                        configure.AddDebug();
                        configure.SetMinimumLevel(LogLevel.Debug);
                    });
                })
                .Build();

            Services = _host.Services;

            // Create and show main window
            var mainWindow = new MainWindow();
            mainWindow.Show();
        }

        /// <summary>
        /// Application exit cleanup
        /// </summary>
        protected override void OnExit(ExitEventArgs e)
        {
            _host?.Dispose();
            base.OnExit(e);
        }

        /// <summary>
        /// Handle unhandled exceptions
        /// </summary>
        private void OnUnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            LogException("Unhandled exception", e.ExceptionObject as Exception);

            MessageBox.Show(
                "An unexpected error occurred. The application will now close.",
                "Fatal Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }

        /// <summary>
        /// Handle dispatcher unhandled exceptions
        /// </summary>
        private void OnDispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            LogException("Dispatcher exception", e.Exception);

            // Show error to user
            MessageBox.Show(
                $"An error occurred: {e.Exception.Message}",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Warning);

            // Mark as handled to prevent crash
            e.Handled = true;
        }

        /// <summary>
        /// Logs an exception
        /// </summary>
        private void LogException(string context, Exception? exception)
        {
            if (exception == null) return;

            try
            {
                var logger = Services?.GetService<ILogger<App>>();
                logger?.LogError(exception, "{Context}", context);
            }
            catch
            {
                // Fallback to debug output if logging fails
                System.Diagnostics.Debug.WriteLine($"{context}: {exception}");
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\MainWindow.xaml.cs
================================================================================

// src\CamBridge.Config\MainWindow.xaml.cs
// Version: 0.7.23
// Description: Main window code-behind with navigation history fix

using System;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using ModernWpf.Controls;
using CamBridge.Config.Services;
using CamBridge.Config.ViewModels;
using CamBridge.Config.Views;

namespace CamBridge.Config
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private readonly INavigationService _navigationService;
        private readonly MainViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();

            // Set version dynamically from assembly
            var version = Assembly.GetExecutingAssembly()
                .GetCustomAttribute<AssemblyInformationalVersionAttribute>()
                ?.InformationalVersion ?? "Unknown";

            Title = $"CamBridge Configuration v{version}";

            // Get services from DI
            var app = (App)App.Current;
            _navigationService = app.Host!.Services.GetRequiredService<INavigationService>();
            _viewModel = app.Host!.Services.GetRequiredService<MainViewModel>();

            DataContext = _viewModel;

            // Initialize navigation
            if (_navigationService is NavigationService navService)
            {
                navService.SetFrame(ContentFrame);
            }

            // Clear navigation journal to prevent history
            ContentFrame.NavigationService.RemoveBackEntry();

            // Navigate to dashboard on startup
            NavView.SelectedItem = NavView.MenuItems[0];
        }

        private void NavigationView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
        {
            if (args.SelectedItem is NavigationViewItem item)
            {
                var tag = item.Tag?.ToString();
                if (!string.IsNullOrEmpty(tag))
                {
                    _navigationService.NavigateTo(tag);

                    // Clear navigation history after each navigation
                    // This prevents the dropdown from appearing
                    while (ContentFrame.NavigationService.CanGoBack)
                    {
                        ContentFrame.NavigationService.RemoveBackEntry();
                    }
                }
            }
        }

        protected override void OnClosed(EventArgs e)
        {
            base.OnClosed(e);

            // Clean shutdown
            Application.Current.Shutdown();
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Converters\ValueConverters.cs
================================================================================

// src/CamBridge.Config/Converters/ValueConverters.cs
// Version: 0.8.5
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Media;
using CamBridge.Config.ViewModels;
using CamBridge.Core;

namespace CamBridge.Config.Converters
{
    /// <summary>
    /// Converts integer to Visibility based on comparison with parameter
    /// NEW in v0.7.28 for LogViewerPage
    /// </summary>
    public class IntToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            int intValue = 0;
            int compareValue = 0;

            // Convert value
            if (value != null)
            {
                try
                {
                    intValue = System.Convert.ToInt32(value);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Convert parameter
            if (parameter != null)
            {
                try
                {
                    compareValue = System.Convert.ToInt32(parameter);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Show when value equals compareValue
            return intValue == compareValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean values to Visibility
    /// </summary>
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = value is bool b && b;
            bool invert = parameter as string == "Inverse";

            if (invert)
                return boolValue ? Visibility.Collapsed : Visibility.Visible;
            else
                return boolValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Inverts boolean to visibility conversion
    /// </summary>
    public class InverseBooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = value is bool b && b;
            return boolValue ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts numeric values greater than zero to true
    /// </summary>
    public class GreaterThanZeroConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null) return false;

            try
            {
                double numValue = System.Convert.ToDouble(value);
                return numValue > 0;
            }
            catch
            {
                return false;
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts null values to Visibility
    /// </summary>
    public class NullToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool isNull = value == null;
            bool invert = parameter as string == "Inverse";

            if (invert)
                return isNull ? Visibility.Visible : Visibility.Collapsed;
            else
                return isNull ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts zero values to Visibility
    /// </summary>
    public class ZeroToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool isZero = false;

            if (value != null)
            {
                try
                {
                    double numValue = System.Convert.ToDouble(value);
                    isZero = Math.Abs(numValue) < 0.0001; // Floating point comparison
                }
                catch
                {
                    // If conversion fails, treat as non-zero
                }
            }

            bool invert = parameter as string == "Inverse";

            if (invert)
                return isZero ? Visibility.Collapsed : Visibility.Visible;
            else
                return isZero ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts error count to color brush
    /// </summary>
    public class ErrorCountToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            int errorCount = 0;

            if (value != null)
            {
                try
                {
                    errorCount = System.Convert.ToInt32(value);
                }
                catch
                {
                    // Default to 0 if conversion fails
                }
            }

            // Return red color if errors exist, otherwise default
            if (errorCount > 0)
            {
                return new SolidColorBrush(Color.FromRgb(255, 107, 107)); // Light red
            }

            return DependencyProperty.UnsetValue; // Use default style
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean values to inverse boolean
    /// </summary>
    public class InverseBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return !(value is bool b && b);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return !(value is bool b && b);
        }
    }

    /// <summary>
    /// Converts empty string to visibility
    /// </summary>
    public class EmptyStringToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            string? str = value as string;
            bool isEmpty = string.IsNullOrWhiteSpace(str);
            bool invert = parameter as string == "Inverse";

            if (invert)
                return isEmpty ? Visibility.Visible : Visibility.Collapsed;
            else
                return isEmpty ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts service status to color
    /// UPDATED in v0.8.5 for proper status colors (Session 95)
    /// FIXED: Added "online" and "offline" mappings
    /// </summary>
    public class ServiceStatusToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            string status = value as string ?? "";

            return status.ToLower() switch
            {
                "running" => new SolidColorBrush(Color.FromRgb(76, 175, 80)),      // Green #4CAF50
                "online" => new SolidColorBrush(Color.FromRgb(76, 175, 80)),       // Green #4CAF50 (same as running)
                "stopped" => new SolidColorBrush(Color.FromRgb(255, 193, 7)),      // Yellow #FFC107 (was Red)
                "offline" => new SolidColorBrush(Color.FromRgb(255, 193, 7)),      // Yellow #FFC107 (same as stopped)
                "paused" => new SolidColorBrush(Color.FromRgb(255, 152, 0)),       // Orange #FF9800
                "startpending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)), // Orange #FF9800
                "stoppending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)),  // Orange #FF9800
                "continuepending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)), // Orange
                "pausepending" => new SolidColorBrush(Color.FromRgb(255, 152, 0)),    // Orange
                "error" => new SolidColorBrush(Color.FromRgb(244, 67, 54)),        // Red #F44336
                "notinstalled" => new SolidColorBrush(Color.FromRgb(244, 67, 54)), // Red #F44336
                _ => new SolidColorBrush(Color.FromRgb(158, 158, 158))             // Gray #9E9E9E
            };
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts seconds to milliseconds
    /// </summary>
    public class SecondsToMillisecondsConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double seconds)
                return seconds * 1000;
            if (value is int intSeconds)
                return intSeconds * 1000;
            return 0;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is double milliseconds)
                return milliseconds / 1000;
            if (value is int intMilliseconds)
                return intMilliseconds / 1000;
            return 0;
        }
    }

    /// <summary>
    /// Converts enum value to boolean based on parameter
    /// </summary>
    public class EnumToBooleanConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null || parameter == null)
                return false;

            string enumValue = value.ToString();
            string targetValue = parameter.ToString();

            return enumValue.Equals(targetValue, StringComparison.InvariantCultureIgnoreCase);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isChecked && isChecked)
            {
                if (parameter != null && targetType.IsEnum)
                {
                    return Enum.Parse(targetType, parameter.ToString());
                }
            }

            return Binding.DoNothing;
        }
    }

    /// <summary>
    /// Converter for file selection dialogs
    /// </summary>
    public class FileSelectConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // Simply pass through the value
            return value;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // Simply pass through the value
            return value;
        }
    }

    /// <summary>
    /// Multi-value boolean OR converter
    /// </summary>
    public class MultiBooleanOrConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length == 0)
                return false;

            foreach (var value in values)
            {
                if (value is bool b && b)
                    return true;
            }

            return false;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts enum types to collection for ComboBox binding
    /// </summary>
    public class EnumToCollectionConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return Enum.GetValues(parameter as Type ?? value?.GetType() ?? typeof(object));
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts file size to human-readable format
    /// </summary>
    public class FileSizeConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value == null) return "0 B";

            long bytes = System.Convert.ToInt64(value);
            string[] sizes = { "B", "KB", "MB", "GB", "TB" };
            int order = 0;
            double size = bytes;

            while (size >= 1024 && order < sizes.Length - 1)
            {
                order++;
                size /= 1024;
            }

            return $"{size:0.##} {sizes[order]}";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts TimeSpan to readable string
    /// </summary>
    public class TimeSpanToStringConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is TimeSpan timeSpan)
            {
                if (timeSpan.TotalDays >= 1)
                    return $"{(int)timeSpan.TotalDays}d {timeSpan.Hours}h {timeSpan.Minutes}m";
                else if (timeSpan.TotalHours >= 1)
                    return $"{(int)timeSpan.TotalHours}h {timeSpan.Minutes}m";
                else
                    return $"{timeSpan.Minutes}m {timeSpan.Seconds}s";
            }
            return "0s";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Multi-value boolean AND converter
    /// </summary>
    public class MultiBooleanAndConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length == 0)
                return false;

            foreach (var value in values)
            {
                if (!(value is bool b) || !b)
                    return false;
            }

            return true;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Null and boolean AND converter
    /// </summary>
    public class NullBooleanAndConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null || values.Length < 2)
                return false;

            // First value should not be null, second should be true
            return values[0] != null && values[1] is bool b && b;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts boolean to color (Green for true, Red for false)
    /// NEW in v0.7.21 for Dashboard minimal
    /// </summary>
    public class BoolToColorConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool isTrue)
            {
                return new SolidColorBrush(isTrue ? Colors.Green : Colors.Red);
            }
            return new SolidColorBrush(Colors.Gray);
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts Transform enum to a visual symbol for display
    /// NEW in v0.7.25 for Mapping Editor Redesign
    /// </summary>
    public class TransformToSymbolConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is ValueTransform transform)
            {
                return transform switch
                {
                    ValueTransform.None => "â†’",
                    ValueTransform.DateToDicom => "ðŸ“…â†’",
                    ValueTransform.TimeToDicom => "â°â†’",
                    ValueTransform.DateTimeToDicom => "ðŸ“…â°â†’",
                    ValueTransform.MapGender => "â™‚â™€â†’",
                    ValueTransform.RemovePrefix => "âœ‚â†’",
                    ValueTransform.ExtractDate => "ðŸ“…â†",
                    ValueTransform.ExtractTime => "â°â†",
                    ValueTransform.ToUpperCase => "Aâ†’",
                    ValueTransform.ToLowerCase => "aâ†’",
                    ValueTransform.Trim => "âŽµâ†’",
                    _ => "â†’"
                };
            }
            return "â†’";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts Transform enum to a descriptive text
    /// NEW in v0.7.25 for Mapping Editor Redesign
    /// </summary>
    public class TransformToDescriptionConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is ValueTransform transform)
            {
                return transform switch
                {
                    ValueTransform.None => "Direct mapping",
                    ValueTransform.DateToDicom => "Convert date to DICOM format (YYYYMMDD)",
                    ValueTransform.TimeToDicom => "Convert time to DICOM format (HHMMSS)",
                    ValueTransform.DateTimeToDicom => "Convert datetime to DICOM format",
                    ValueTransform.MapGender => "Map gender values (M/F/O)",
                    ValueTransform.RemovePrefix => "Remove prefix from value",
                    ValueTransform.ExtractDate => "Extract date from datetime",
                    ValueTransform.ExtractTime => "Extract time from datetime",
                    ValueTransform.ToUpperCase => "Convert to uppercase",
                    ValueTransform.ToLowerCase => "Convert to lowercase",
                    ValueTransform.Trim => "Remove leading/trailing spaces",
                    _ => "Unknown transformation"
                };
            }
            return "No transformation";
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Combines stage entries and ungrouped entries into a flat list for compact tree view
    /// </summary>
    public class CombineStagesConverter : IMultiValueConverter
    {
        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values.Length != 2) return null;

            var stages = values[0] as ObservableCollection<StageGroup>;
            var ungrouped = values[1] as ObservableCollection<LogEntry>;

            var combined = new List<LogEntry>();

            // Add all entries from stages (flattened)
            if (stages != null)
            {
                foreach (var stage in stages.OrderBy(s => s.StartTime))
                {
                    combined.AddRange(stage.Entries);
                }
            }

            // Add ungrouped entries
            if (ungrouped != null)
            {
                combined.AddRange(ungrouped);
            }

            // Sort by timestamp
            return combined.OrderBy(e => e.Timestamp).ToList();
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// Converts color string to SolidColorBrush with opacity
    /// </summary>
    public class ColorToBrushConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is string colorString)
            {
                try
                {
                    var color = (Color)ColorConverter.ConvertFromString(colorString);
                    // Add slight transparency for background
                    color.A = 30; // Very light background
                    return new SolidColorBrush(color);
                }
                catch
                {
                    return Brushes.Transparent;
                }
            }
            return Brushes.Transparent;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Dialogs\DicomTagBrowserDialog.xaml.cs
================================================================================

// src/CamBridge.Config/Dialogs/DicomTagBrowserDialog.xaml.cs
// Version: 0.7.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Enhanced with NEMA-compliant descriptions

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using ModernWpf.Controls;
// Use alias to avoid conflicts
using CoreDicomTag = CamBridge.Core.ValueObjects.DicomTag;

namespace CamBridge.Config.Dialogs
{
    /// <summary>
    /// Dialog for browsing and selecting DICOM tags with search functionality
    /// </summary>
    [SupportedOSPlatform("windows")]
    public partial class DicomTagBrowserDialog : Window, INotifyPropertyChanged
    {
        #region Properties

        private string? _searchText;
        public string? SearchText
        {
            get => _searchText;
            set
            {
                if (_searchText != value)
                {
                    _searchText = value;
                    OnPropertyChanged();
                    UpdateFilter();
                }
            }
        }

        public CoreDicomTag? SelectedTag { get; private set; }

        private CollectionViewSource _tagsViewSource = null!;
        public ICollectionView TagsView => _tagsViewSource.View;

        private List<DicomTagInfo> _allTags = null!;

        #endregion

        public DicomTagBrowserDialog()
        {
            InitializeComponent();
            DataContext = this;

            // Initialize collections before use
            _allTags = new List<DicomTagInfo>();
            _tagsViewSource = new CollectionViewSource();

            LoadDicomTags();
            SearchBox.Focus();
        }

        #region Initialization

        private void LoadDicomTags()
        {
            // Clear and reinitialize
            _allTags.Clear();

            // Patient Module - NEMA PS3.3 Table C.7-1
            AddTag("Patient", CoreDicomTag.PatientModule.PatientName, "Patient's Name", "PN",
                "Primary identifier - Format: Family^Given^Middle^Prefix^Suffix");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientID, "Patient ID", "LO",
                "Primary hospital/institution identification number");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientBirthDate, "Patient's Birth Date", "DA",
                "Format: YYYYMMDD (e.g., 19850315 for March 15, 1985)");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientSex, "Patient's Sex", "CS",
                "M=Male, F=Female, O=Other (fixed enumeration)");
            AddTag("Patient", CoreDicomTag.PatientModule.OtherPatientIDs, "Other Patient IDs", "LO",
                "Additional identifiers from other systems");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientComments, "Patient Comments", "LT",
                "Additional information about the patient");

            // Study Module - NEMA PS3.3 Table C.7-3
            AddTag("Study", CoreDicomTag.StudyModule.StudyInstanceUID, "Study Instance UID", "UI",
                "Unique identifier for the study - automatically generated");
            AddTag("Study", CoreDicomTag.StudyModule.StudyDate, "Study Date", "DA",
                "Date the study started - Format: YYYYMMDD");
            AddTag("Study", CoreDicomTag.StudyModule.StudyTime, "Study Time", "TM",
                "Time the study started - Format: HHMMSS.FFFFFF");
            AddTag("Study", CoreDicomTag.StudyModule.StudyID, "Study ID", "SH",
                "Institution-generated study identifier");
            AddTag("Study", CoreDicomTag.StudyModule.AccessionNumber, "Accession Number", "SH",
                "RIS/HIS generated number that identifies the order");
            AddTag("Study", CoreDicomTag.StudyModule.StudyDescription, "Study Description", "LO",
                "Institution-generated description or classification of the study");
            AddTag("Study", CoreDicomTag.StudyModule.ReferringPhysicianName, "Referring Physician's Name", "PN",
                "Name of the physician who requested the study");

            // Series Module - NEMA PS3.3 Table C.7-5a
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesInstanceUID, "Series Instance UID", "UI",
                "Unique identifier for the series - automatically generated");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesNumber, "Series Number", "IS",
                "A number that identifies this series (e.g., 1, 2, 3...)");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesDate, "Series Date", "DA",
                "Date the series started");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesTime, "Series Time", "TM",
                "Time the series started");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesDescription, "Series Description", "LO",
                "Description of the series (e.g., 'Chest PA', 'Lateral View')");
            AddTag("Series", CoreDicomTag.SeriesModule.Modality, "Modality", "CS",
                "Type of equipment (e.g., XA=X-Ray Angiography, OT=Other)");

            // General Image Module - NEMA PS3.3 Table C.7-9
            AddTag("Image", CoreDicomTag.InstanceModule.SOPInstanceUID, "SOP Instance UID", "UI",
                "Unique identifier for this image - automatically generated");
            AddTag("Image", CoreDicomTag.InstanceModule.InstanceNumber, "Instance Number", "IS",
                "A number that identifies this image (1, 2, 3...)");
            AddTag("Image", CoreDicomTag.InstanceModule.ContentDate, "Content Date", "DA",
                "The date the image pixel data creation started");
            AddTag("Image", CoreDicomTag.InstanceModule.ContentTime, "Content Time", "TM",
                "The time the image pixel data creation started");
            AddTag("Image", CoreDicomTag.InstanceModule.AcquisitionDateTime, "Acquisition DateTime", "DT",
                "Date and time the acquisition started - Format: YYYYMMDDHHMMSS.FFFFFF");

            // General Equipment Module - NEMA PS3.3 Table C.7-8
            AddTag("Equipment", CoreDicomTag.EquipmentModule.Manufacturer, "Manufacturer", "LO",
                "Manufacturer of the equipment (e.g., 'RICOH')");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.InstitutionName, "Institution Name", "LO",
                "Institution where the equipment is located");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.StationName, "Station Name", "SH",
                "User-defined name identifying the machine");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.ManufacturerModelName, "Manufacturer's Model Name", "LO",
                "Manufacturer's model name (e.g., 'G900 II')");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.SoftwareVersions, "Software Versions", "LO",
                "Manufacturer's software version (e.g., 'CamBridge 0.7.25')");

            // Additional commonly used tags
            AddTag("General", new CoreDicomTag(0x0008, 0x0005), "Specific Character Set", "CS",
                "Character encoding (e.g., 'ISO_IR 100' for Latin-1)");
            AddTag("General", new CoreDicomTag(0x0008, 0x0016), "SOP Class UID", "UI",
                "Identifies the DICOM IOD (e.g., Secondary Capture)");
            AddTag("General", new CoreDicomTag(0x0008, 0x0064), "Conversion Type", "CS",
                "Describes the conversion (e.g., 'WSD' = Workstation)");
            AddTag("General", new CoreDicomTag(0x0020, 0x0013), "Instance Number", "IS",
                "Number that identifies this instance");
            AddTag("General", new CoreDicomTag(0x0028, 0x0002), "Samples per Pixel", "US",
                "Number of samples per pixel (1=grayscale, 3=color)");
            AddTag("General", new CoreDicomTag(0x0028, 0x0004), "Photometric Interpretation", "CS",
                "Color space (e.g., 'RGB', 'YBR_FULL_422')");

            // Setup CollectionViewSource with grouping
            _tagsViewSource = new CollectionViewSource { Source = _allTags };
            _tagsViewSource.GroupDescriptions.Add(new PropertyGroupDescription("Module"));
            _tagsViewSource.SortDescriptions.Add(new SortDescription("Module", ListSortDirection.Ascending));
            _tagsViewSource.SortDescriptions.Add(new SortDescription("TagString", ListSortDirection.Ascending));

            // Notify UI
            OnPropertyChanged(nameof(TagsView));
        }

        private void AddTag(string module, CoreDicomTag tag, string name, string vr, string description)
        {
            _allTags.Add(new DicomTagInfo
            {
                Module = module,
                Tag = tag,
                Name = name,
                VR = vr,
                VRDescription = GetVRDescription(vr),
                TagString = tag.ToString(),
                Description = description,
                DisplayText = $"{tag} - {name} ({vr})"
            });
        }

        private string GetVRDescription(string vr)
        {
            return vr switch
            {
                "CS" => "Code String - max 16 chars",
                "DA" => "Date - YYYYMMDD",
                "DT" => "DateTime - YYYYMMDDHHMMSS.FFFFFF",
                "IS" => "Integer String - max 12 chars",
                "LO" => "Long String - max 64 chars",
                "LT" => "Long Text - max 10240 chars",
                "PN" => "Person Name - 5 components with ^",
                "SH" => "Short String - max 16 chars",
                "TM" => "Time - HHMMSS.FFFFFF",
                "UI" => "Unique Identifier - max 64 chars",
                "US" => "Unsigned Short - 2 bytes",
                _ => vr
            };
        }

        #endregion

        #region Search and Filter

        private void UpdateFilter()
        {
            if (TagsView == null) return;

            if (string.IsNullOrWhiteSpace(SearchText))
            {
                TagsView.Filter = null;
            }
            else
            {
                TagsView.Filter = obj =>
                {
                    if (obj is DicomTagInfo tagInfo)
                    {
                        var searchLower = SearchText.ToLower();
                        return tagInfo.Name.ToLower().Contains(searchLower) ||
                               tagInfo.TagString.Contains(searchLower) ||
                               tagInfo.Module.ToLower().Contains(searchLower) ||
                               tagInfo.VR.ToLower().Contains(searchLower) ||
                               tagInfo.Description.ToLower().Contains(searchLower);
                    }
                    return false;
                };
            }

            // Select first item if any
            TagsView.MoveCurrentToFirst();
        }

        #endregion

        #region Event Handlers

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            if (TagsListView.SelectedItem is DicomTagInfo tagInfo)
            {
                SelectedTag = tagInfo.Tag;
                DialogResult = true;
            }
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        private void TagsListView_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (TagsListView.SelectedItem != null)
            {
                OkButton_Click(sender, e);
            }
        }

        private void SearchBox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Down && TagsListView.Items.Count > 0)
            {
                TagsListView.Focus();
                TagsListView.SelectedIndex = 0;
            }
        }

        private void Window_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Escape)
            {
                DialogResult = false;
            }
            else if (e.Key == Key.Enter && TagsListView.SelectedItem != null)
            {
                OkButton_Click(sender, e);
            }
        }

        #endregion

        #region INotifyPropertyChanged

        public event PropertyChangedEventHandler? PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion

        #region Inner Classes

        /// <summary>
        /// DICOM tag information for display
        /// </summary>
        public class DicomTagInfo
        {
            public string Module { get; set; } = string.Empty;
            public CoreDicomTag Tag { get; set; } = null!;
            public string Name { get; set; } = string.Empty;
            public string VR { get; set; } = string.Empty;
            public string VRDescription { get; set; } = string.Empty;
            public string TagString { get; set; } = string.Empty;
            public string Description { get; set; } = string.Empty;
            public string DisplayText { get; set; } = string.Empty;
        }

        #endregion
    }
}


================================================================================
FILE: src\CamBridge.Config\Dialogs\TransformEditorDialog.xaml.cs
================================================================================

// src/CamBridge.Config/Dialogs/TransformEditorDialog.xaml.cs
// Version: 0.7.26
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.ValueObjects;
using ModernWpf.Controls;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace CamBridge.Config.Dialogs
{
    /// <summary>
    /// Enhanced dialog for editing mapping rule transformations with encoding preview
    /// </summary>
    public partial class TransformEditorDialog : ContentDialog, INotifyPropertyChanged
    {
        private ValueTransform _selectedTransform;
        private string _sourceField = "";
        private string _dicomTag = "";
        private string _dicomTagName = "";
        private string _previewInput = "";
        private string _previewOutput = "";
        private string _previewOutputSpecialChars = "";
        private string _previewOutputHex = "";
        private bool _showPreview = true;
        private bool _showNormalView = true;
        private bool _showSpecialCharsView = false;
        private bool _showHexView = false;
        private string _inputEncoding = "UTF-8";
        private string _outputEncoding = "ISO_IR 100";
        private bool _showEncodingWarning = false;
        private string _encodingWarning = "";
        private bool _showDicomInfo = false;
        private string _dicomInfo = "";

        public TransformEditorDialog()
        {
            InitializeComponent();
            DataContext = this;
            InitializeTransforms();
        }

        #region Properties

        public ObservableCollection<ValueTransform> AvailableTransforms { get; } = new();

        public ValueTransform SelectedTransform
        {
            get => _selectedTransform;
            set
            {
                if (_selectedTransform != value)
                {
                    _selectedTransform = value;
                    OnPropertyChanged();

                    // Update preview input based on new transform
                    UpdatePreviewInputForTransform();

                    UpdatePreview();
                    UpdateShowPreview();
                    UpdateDicomInfo();
                }
            }
        }

        public string SourceField
        {
            get => _sourceField;
            set
            {
                _sourceField = value;
                OnPropertyChanged();
            }
        }

        public string DicomTag
        {
            get => _dicomTag;
            set
            {
                _dicomTag = value;
                OnPropertyChanged();
                UpdateDicomInfo();
            }
        }

        public string DicomTagName
        {
            get => _dicomTagName;
            set
            {
                _dicomTagName = value;
                OnPropertyChanged();
            }
        }

        public string PreviewInput
        {
            get => _previewInput;
            set
            {
                _previewInput = value;
                OnPropertyChanged();
                DetectInputEncoding();
                UpdatePreview();
            }
        }

        public string PreviewOutput
        {
            get => _previewOutput;
            set
            {
                _previewOutput = value;
                OnPropertyChanged();
            }
        }

        public string PreviewOutputSpecialChars
        {
            get => _previewOutputSpecialChars;
            set
            {
                _previewOutputSpecialChars = value;
                OnPropertyChanged();
            }
        }

        public string PreviewOutputHex
        {
            get => _previewOutputHex;
            set
            {
                _previewOutputHex = value;
                OnPropertyChanged();
            }
        }

        public bool ShowPreview
        {
            get => _showPreview;
            set
            {
                _showPreview = value;
                OnPropertyChanged();
            }
        }

        public bool ShowNormalView
        {
            get => _showNormalView;
            set
            {
                _showNormalView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowSpecialCharsView = false;
                    ShowHexView = false;
                }
            }
        }

        public bool ShowSpecialCharsView
        {
            get => _showSpecialCharsView;
            set
            {
                _showSpecialCharsView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowNormalView = false;
                    ShowHexView = false;
                }
            }
        }

        public bool ShowHexView
        {
            get => _showHexView;
            set
            {
                _showHexView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowNormalView = false;
                    ShowSpecialCharsView = false;
                }
            }
        }

        public string InputEncoding
        {
            get => _inputEncoding;
            set
            {
                _inputEncoding = value;
                OnPropertyChanged();
            }
        }

        public string OutputEncoding
        {
            get => _outputEncoding;
            set
            {
                _outputEncoding = value;
                OnPropertyChanged();
            }
        }

        public bool ShowEncodingWarning
        {
            get => _showEncodingWarning;
            set
            {
                _showEncodingWarning = value;
                OnPropertyChanged();
            }
        }

        public string EncodingWarning
        {
            get => _encodingWarning;
            set
            {
                _encodingWarning = value;
                OnPropertyChanged();
            }
        }

        public bool ShowDicomInfo
        {
            get => _showDicomInfo;
            set
            {
                _showDicomInfo = value;
                OnPropertyChanged();
            }
        }

        public string DicomInfo
        {
            get => _dicomInfo;
            set
            {
                _dicomInfo = value;
                OnPropertyChanged();
            }
        }

        #endregion

        #region Methods

        private void UpdatePreviewInputForTransform()
        {
            // Update preview input when transform changes to provide appropriate test data
            PreviewInput = SelectedTransform switch
            {
                ValueTransform.DateToDicom => "1985-03-15",
                ValueTransform.ExtractDate => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.ExtractTime => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.DateTimeToDicom => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.TimeToDicom => "14:30:45",
                ValueTransform.MapGender => "M",
                ValueTransform.ToUpperCase => "test text",
                ValueTransform.ToLowerCase => "TEST TEXT",
                ValueTransform.Trim => "  trimmed text  ",
                ValueTransform.RemovePrefix => "PREFIX_Value",
                ValueTransform.None => SourceField switch
                {
                    "birthdate" => "1985-03-15",
                    "gender" => "M",
                    "DateTimeOriginal" => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                    "name" => "Schmidt, Maria",
                    "examid" => "EX002",
                    "comment" => "RÃ¶ntgen Thorax",
                    _ => "Sample Text"
                },
                _ => PreviewInput // Keep existing input
            };
        }

        private void InitializeTransforms()
        {
            // Add all available transforms
            foreach (ValueTransform transform in Enum.GetValues(typeof(ValueTransform)))
            {
                AvailableTransforms.Add(transform);
            }
        }

        private void DetectInputEncoding()
        {
            if (string.IsNullOrEmpty(PreviewInput))
            {
                InputEncoding = "UTF-8";
                return;
            }

            // Check for common encoding indicators
            bool hasUmlauts = PreviewInput.Any(c => "Ã¤Ã¶Ã¼Ã„Ã–ÃœÃŸ".Contains(c));
            bool hasExtendedAscii = PreviewInput.Any(c => c > 127);

            if (hasExtendedAscii && !hasUmlauts)
            {
                InputEncoding = "Windows-1252";
            }
            else if (hasUmlauts)
            {
                InputEncoding = "UTF-8";
            }
            else
            {
                InputEncoding = "ASCII";
            }
        }

        private void UpdatePreview()
        {
            if (string.IsNullOrEmpty(PreviewInput))
            {
                PreviewOutput = "";
                PreviewOutputSpecialChars = "";
                PreviewOutputHex = "";
                ShowEncodingWarning = false;
                return;
            }

            try
            {
                // Create a temporary rule to apply the transform
                var tempRule = new MappingRule
                {
                    Transform = SelectedTransform.ToString()
                };

                PreviewOutput = tempRule.ApplyTransform(PreviewInput) ?? "";

                // Create special chars view
                PreviewOutputSpecialChars = CreateSpecialCharsView(PreviewOutput);

                // Create hex view
                PreviewOutputHex = CreateHexView(PreviewOutput);

                // Check for encoding issues
                CheckEncodingIssues();
            }
            catch (Exception ex)
            {
                PreviewOutput = $"Error: {ex.Message}";
                PreviewOutputSpecialChars = PreviewOutput;
                PreviewOutputHex = "";
            }
        }

        private string CreateSpecialCharsView(string input)
        {
            if (string.IsNullOrEmpty(input)) return "";

            return input
                .Replace("\r", "[CR]")
                .Replace("\n", "[LF]")
                .Replace("\t", "[TAB]")
                .Replace("\0", "[NULL]")
                .Replace("\x1B", "[ESC]");
        }

        private string CreateHexView(string input)
        {
            if (string.IsNullOrEmpty(input)) return "";

            var sb = new StringBuilder();
            var bytes = Encoding.UTF8.GetBytes(input);

            for (int i = 0; i < bytes.Length; i++)
            {
                if (i > 0 && i % 16 == 0)
                {
                    sb.AppendLine();
                }
                else if (i > 0)
                {
                    sb.Append(" ");
                }

                sb.AppendFormat("{0:X2}", bytes[i]);
            }

            return sb.ToString();
        }

        private void CheckEncodingIssues()
        {
            ShowEncodingWarning = false;

            // Check for problematic characters
            if (PreviewOutput.Contains('?') && !PreviewInput.Contains('?'))
            {
                ShowEncodingWarning = true;
                EncodingWarning = "âš  Character encoding issue detected - some characters may be lost in DICOM conversion";
            }
            else if (PreviewOutput.Any(c => c > 255))
            {
                ShowEncodingWarning = true;
                EncodingWarning = "âš  Output contains Unicode characters that may not be supported in DICOM ISO_IR 100";
            }
        }

        private void UpdateShowPreview()
        {
            // Hide preview for certain transforms that don't need it
            ShowPreview = SelectedTransform != ValueTransform.None;
        }

        private void UpdateDicomInfo()
        {
            ShowDicomInfo = false;

            // Show DICOM-specific info for certain tags/transforms
            if (DicomTag == "(0010,0010)" && SelectedTransform == ValueTransform.None)
            {
                ShowDicomInfo = true;
                DicomInfo = "Patient Name: Max 64 chars, format: Last^First^Middle^Prefix^Suffix";
            }
            else if (DicomTag == "(0010,0030)" && SelectedTransform == ValueTransform.DateToDicom)
            {
                ShowDicomInfo = true;
                DicomInfo = "Birth Date: DICOM format YYYYMMDD, no separators";
            }
            else if (DicomTag == "(0010,0040)" && SelectedTransform == ValueTransform.MapGender)
            {
                ShowDicomInfo = true;
                DicomInfo = "Patient Sex: Valid values are M, F, O (Other)";
            }
        }

        public void SetMapping(string sourceField, string dicomTag, ValueTransform currentTransform)
        {
            SourceField = sourceField;
            DicomTag = dicomTag;
            SelectedTransform = currentTransform;

            // Look up DICOM tag name
            DicomTagName = GetDicomTagNameByString(dicomTag);

            // Set appropriate preview input based on transform type
            PreviewInput = currentTransform switch
            {
                ValueTransform.DateToDicom => "1985-03-15",
                ValueTransform.ExtractDate => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.ExtractTime => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.DateTimeToDicom => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.TimeToDicom => "14:30:45",
                ValueTransform.MapGender => "M",
                ValueTransform.ToUpperCase => "test text",
                ValueTransform.ToLowerCase => "TEST TEXT",
                ValueTransform.Trim => "  trimmed text  ",
                ValueTransform.RemovePrefix => "PREFIX_Value",
                _ => sourceField switch
                {
                    "birthdate" => "1985-03-15",
                    "gender" => "M",
                    "DateTimeOriginal" => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                    "name" => "Schmidt, Maria",
                    "examid" => "EX002",
                    "comment" => "RÃ¶ntgen Thorax\r\nAP-Aufnahme",
                    _ => "Sample Text"
                }
            };
        }

        private string GetDicomTagNameByString(string tagString)
        {
            // Direct tag name lookup by string
            return tagString switch
            {
                "(0010,0010)" => "Patient's Name",
                "(0010,0020)" => "Patient ID",
                "(0010,0030)" => "Patient's Birth Date",
                "(0010,0040)" => "Patient's Sex",
                "(0020,0010)" => "Study ID",
                "(0008,1030)" => "Study Description",
                "(0008,0020)" => "Study Date",
                "(0008,0030)" => "Study Time",
                "(0008,0070)" => "Manufacturer",
                "(0008,1090)" => "Manufacturer's Model Name",
                "(0018,1020)" => "Software Versions",
                "(0008,002A)" => "Acquisition DateTime",
                "(0010,4000)" => "Patient Comments",
                "(0008,0050)" => "Accession Number",
                _ => "Custom Tag"
            };
        }

        private string GetDicomTagName(Core.ValueObjects.DicomTag tag)
        {
            return GetDicomTagNameByString(tag.ToString());
        }

        #endregion

        #region INotifyPropertyChanged

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion
    }
}


================================================================================
FILE: src\CamBridge.Config\Extensions\MappingConfigurationExtensions.cs
================================================================================

// File: src/CamBridge.Config/Extensions/MappingConfigurationExtensions.cs
// Version: 0.5.24
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-04
// Status: Development/Local

using System.Threading.Tasks;
using CamBridge.Core.Interfaces;
using CamBridge.Infrastructure.Services;

namespace CamBridge.Config.Extensions
{
    /// <summary>
    /// Extension methods for MappingConfigurationLoader to provide UI-expected methods
    /// </summary>
    public static class MappingConfigurationExtensions
    {
        /// <summary>
        /// Load configuration from file (UI-expected method name)
        /// </summary>
        public static async Task<IMappingConfiguration> LoadFromFileAsync(
            this MappingConfigurationLoader loader,
            string filePath)
        {
            await loader.LoadConfigurationAsync(filePath);
            return loader;
        }

        /// <summary>
        /// Save configuration to file (UI-expected method name)
        /// </summary>
        public static async Task SaveToFileAsync(
            this MappingConfigurationLoader loader,
            IMappingConfiguration config,
            string filePath)
        {
            // The loader itself implements IMappingConfiguration
            // So we just save its current rules
            await loader.SaveConfigurationAsync(loader.GetMappingRules(), filePath);
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Extensions\MappingRuleExtensions.cs
================================================================================

// File: src/CamBridge.Config/Extensions/MappingRuleExtensions.cs
// Version: 0.6.2
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-07
// Status: Development/Local

using System;
using CamBridge.Core;

namespace CamBridge.Config.Extensions
{
    /// <summary>
    /// Extension methods for MappingRule to support UI-specific functionality
    /// </summary>
    public static class MappingRuleExtensions
    {
        // HINWEIS: Die ApplyTransform Methode ist jetzt direkt in MappingRule.cs implementiert!
        // Diese Klasse kÃ¶nnte gelÃ¶scht werden, oder wir behalten sie fÃ¼r andere UI-spezifische Extensions

        /// <summary>
        /// Gets a display-friendly description of the transform
        /// </summary>
        public static string GetTransformDescription(this MappingRule rule)
        {
            return rule.TransformEnum switch
            {
                ValueTransform.None => "No transformation",
                ValueTransform.DateToDicom => "Convert date to DICOM format (YYYYMMDD)",
                ValueTransform.TimeToDicom => "Convert time to DICOM format (HHMMSS)",
                ValueTransform.DateTimeToDicom => "Convert datetime to DICOM format",
                ValueTransform.MapGender => "Map gender to DICOM values (M/F/O)",
                ValueTransform.RemovePrefix => "Remove prefix from value",
                ValueTransform.ExtractDate => "Extract date from datetime",
                ValueTransform.ExtractTime => "Extract time from datetime",
                ValueTransform.ToUpperCase => "Convert to uppercase",
                ValueTransform.ToLowerCase => "Convert to lowercase",
                ValueTransform.Trim => "Remove leading/trailing spaces",
                _ => "Unknown transformation"
            };
        }

        /// <summary>
        /// Validates if the rule is properly configured
        /// </summary>
        public static bool IsValid(this MappingRule rule)
        {
            if (string.IsNullOrWhiteSpace(rule.SourceField))
                return false;

            if (string.IsNullOrWhiteSpace(rule.DicomTag))
                return false;

            // Validate DICOM tag format (XXXX,XXXX)
            if (!System.Text.RegularExpressions.Regex.IsMatch(rule.DicomTag, @"^\([0-9A-Fa-f]{4},[0-9A-Fa-f]{4}\)$"))
                return false;

            return true;
        }

        /// <summary>
        /// Gets a UI-friendly display name for the rule
        /// </summary>
        public static string GetDisplayName(this MappingRule rule)
        {
            if (!string.IsNullOrWhiteSpace(rule.Description))
                return rule.Description;

            if (!string.IsNullOrWhiteSpace(rule.Name))
                return rule.Name;

            return $"{rule.SourceType}.{rule.SourceField} â†’ {rule.DicomTag}";
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Helpers\PasswordBoxHelper.cs
================================================================================

// src\CamBridge.Config\Helpers\PasswordBoxHelper.cs
// Version: 0.5.26
// Helper for binding PasswordBox (which doesn't support direct binding)

using System.Windows;
using System.Windows.Controls;

namespace CamBridge.Config.Helpers
{
    /// <summary>
    /// Helper class to enable binding on PasswordBox
    /// </summary>
    public static class PasswordBoxHelper
    {
        public static readonly DependencyProperty BoundPasswordProperty =
            DependencyProperty.RegisterAttached("BoundPassword", typeof(string), typeof(PasswordBoxHelper),
                new PropertyMetadata(string.Empty, OnBoundPasswordChanged));

        public static readonly DependencyProperty BindPasswordProperty =
            DependencyProperty.RegisterAttached("BindPassword", typeof(bool), typeof(PasswordBoxHelper),
                new PropertyMetadata(false, OnBindPasswordChanged));

        private static readonly DependencyProperty UpdatingPasswordProperty =
            DependencyProperty.RegisterAttached("UpdatingPassword", typeof(bool), typeof(PasswordBoxHelper),
                new PropertyMetadata(false));

        public static void SetBindPassword(DependencyObject dp, bool value)
        {
            dp.SetValue(BindPasswordProperty, value);
        }

        public static bool GetBindPassword(DependencyObject dp)
        {
            return (bool)dp.GetValue(BindPasswordProperty);
        }

        public static string GetBoundPassword(DependencyObject dp)
        {
            return (string)dp.GetValue(BoundPasswordProperty);
        }

        public static void SetBoundPassword(DependencyObject dp, string value)
        {
            dp.SetValue(BoundPasswordProperty, value);
        }

        private static bool GetUpdatingPassword(DependencyObject dp)
        {
            return (bool)dp.GetValue(UpdatingPasswordProperty);
        }

        private static void SetUpdatingPassword(DependencyObject dp, bool value)
        {
            dp.SetValue(UpdatingPasswordProperty, value);
        }

        private static void OnBoundPasswordChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is PasswordBox passwordBox)
            {
                // Disconnect the handler while we're updating
                passwordBox.PasswordChanged -= HandlePasswordChanged;

                if (!GetUpdatingPassword(passwordBox))
                {
                    passwordBox.Password = (string)e.NewValue;
                }

                passwordBox.PasswordChanged += HandlePasswordChanged;
            }
        }

        private static void OnBindPasswordChanged(DependencyObject dp, DependencyPropertyChangedEventArgs e)
        {
            if (dp is PasswordBox passwordBox)
            {
                if ((bool)e.OldValue)
                {
                    passwordBox.PasswordChanged -= HandlePasswordChanged;
                }

                if ((bool)e.NewValue)
                {
                    passwordBox.PasswordChanged += HandlePasswordChanged;
                }
            }
        }

        private static void HandlePasswordChanged(object sender, RoutedEventArgs e)
        {
            if (sender is PasswordBox passwordBox)
            {
                SetUpdatingPassword(passwordBox, true);
                SetBoundPassword(passwordBox, passwordBox.Password);
                SetUpdatingPassword(passwordBox, false);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Models\DeadLetterModels.cs
================================================================================

// src\CamBridge.Config\Models\DeadLetterModels.cs
// Version: 0.7.1
// Description: Dead letter queue models for API communication
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;

namespace CamBridge.Config.Models
{
    /// <summary>
    /// Dead letter item from API
    /// </summary>
    public class DeadLetterItemModel
    {
        public Guid Id { get; set; }
        public string FileName { get; set; } = string.Empty;
        public string FilePath { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public DateTime FailedAt { get; set; }
        public DateTime FirstAttempt { get; set; }
        public DateTime LastAttempt { get; set; }
        public string ErrorMessage { get; set; } = string.Empty;
        public int RetryCount { get; set; }
        public int AttemptCount { get; set; }
        public string OriginalPath { get; set; } = string.Empty;
        public long FileSize { get; set; }
    }

    /// <summary>
    /// Detailed statistics from API
    /// </summary>
    public class DetailedStatisticsModel
    {
        public int TotalProcessed { get; set; }
        public int TotalSuccessful { get; set; }
        public int TotalFailed { get; set; }
        public int TotalQueued { get; set; }
        public double AverageProcessingTimeMs { get; set; }
        public DateTime LastUpdate { get; set; }

        // Per-pipeline statistics
        public Dictionary<string, PipelineStatistics>? PipelineStats { get; set; }
    }

    /// <summary>
    /// Statistics for a single pipeline
    /// </summary>
    public class PipelineStatistics
    {
        public string PipelineId { get; set; } = string.Empty;
        public string PipelineName { get; set; } = string.Empty;
        public int Processed { get; set; }
        public int Successful { get; set; }
        public int Failed { get; set; }
        public int Queued { get; set; }
        public double SuccessRate { get; set; }
    }
}


================================================================================
FILE: src\CamBridge.Config\Models\ServiceStatusModel.cs
================================================================================

// src\CamBridge.Config\Models\ServiceStatusModel.cs
// Version: 0.7.28
// Description: Service status model matching the actual API response
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace CamBridge.Config.Models
{
    /// <summary>
    /// Root response from /api/status endpoint
    /// </summary>
    public class ServiceStatusModel
    {
        // Nested service info
        [JsonPropertyName("service")]
        public ServiceInfo Service { get; set; } = new();

        // Environment info
        [JsonPropertyName("environment")]
        public EnvironmentInfo? Environment { get; set; }

        // Pipeline list
        [JsonPropertyName("pipelines")]
        public List<PipelineStatusData> Pipelines { get; set; } = new();

        // Statistics
        [JsonPropertyName("statistics")]
        public ServiceStatistics? Statistics { get; set; }

        // Configuration
        [JsonPropertyName("configuration")]
        public ServiceConfigurationInfo? Configuration { get; set; }

        // Helper properties for backward compatibility
        [JsonIgnore]
        public string ServiceStatus => Service?.Status ?? "Unknown";

        [JsonIgnore]
        public string Version => Service?.Version ?? "Unknown";

        [JsonIgnore]
        public TimeSpan Uptime => ParseUptime(Service?.Uptime);

        [JsonIgnore]
        public int PipelineCount => Statistics?.TotalPipelines ?? 0;

        [JsonIgnore]
        public int ActivePipelines => Statistics?.ActivePipelines ?? 0;

        [JsonIgnore]
        public int TotalSuccessful => Statistics?.TotalProcessed ?? 0;

        [JsonIgnore]
        public int TotalFailed => Statistics?.TotalErrors ?? 0;

        private static TimeSpan ParseUptime(string? uptimeStr)
        {
            if (string.IsNullOrEmpty(uptimeStr))
                return TimeSpan.Zero;

            // Parse formats like "2m", "1h 5m", "2d 3h 5m"
            var parts = uptimeStr.Split(' ');
            var totalMinutes = 0;

            foreach (var part in parts)
            {
                if (part.EndsWith("d"))
                {
                    if (int.TryParse(part.TrimEnd('d'), out var days))
                        totalMinutes += days * 24 * 60;
                }
                else if (part.EndsWith("h"))
                {
                    if (int.TryParse(part.TrimEnd('h'), out var hours))
                        totalMinutes += hours * 60;
                }
                else if (part.EndsWith("m"))
                {
                    if (int.TryParse(part.TrimEnd('m'), out var minutes))
                        totalMinutes += minutes;
                }
            }

            return TimeSpan.FromMinutes(totalMinutes);
        }
    }

    /// <summary>
    /// Service information
    /// </summary>
    public class ServiceInfo
    {
        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        [JsonPropertyName("displayName")]
        public string DisplayName { get; set; } = string.Empty;

        [JsonPropertyName("version")]
        public string Version { get; set; } = "Unknown";

        [JsonPropertyName("status")]
        public string Status { get; set; } = "Unknown";

        [JsonPropertyName("timestamp")]
        public DateTime Timestamp { get; set; }

        [JsonPropertyName("startTime")]
        public DateTime StartTime { get; set; }

        [JsonPropertyName("uptime")]
        public string Uptime { get; set; } = "";

        [JsonPropertyName("processId")]
        public int ProcessId { get; set; }
    }

    /// <summary>
    /// Environment information
    /// </summary>
    public class EnvironmentInfo
    {
        [JsonPropertyName("machineName")]
        public string MachineName { get; set; } = string.Empty;

        [JsonPropertyName("osVersion")]
        public string OsVersion { get; set; } = string.Empty;

        [JsonPropertyName("processorCount")]
        public int ProcessorCount { get; set; }

        [JsonPropertyName("workingSet")]
        public long WorkingSet { get; set; }

        [JsonPropertyName("dotNetVersion")]
        public string DotNetVersion { get; set; } = string.Empty;
    }

    /// <summary>
    /// Service statistics
    /// </summary>
    public class ServiceStatistics
    {
        [JsonPropertyName("totalPipelines")]
        public int TotalPipelines { get; set; }

        [JsonPropertyName("activePipelines")]
        public int ActivePipelines { get; set; }

        [JsonPropertyName("totalProcessed")]
        public int TotalProcessed { get; set; }

        [JsonPropertyName("totalErrors")]
        public int TotalErrors { get; set; }

        [JsonPropertyName("totalQueued")]
        public int TotalQueued { get; set; }
    }

    /// <summary>
    /// Individual pipeline status
    /// </summary>
    public class PipelineStatusData
    {
        [JsonPropertyName("id")]
        public string Id { get; set; } = string.Empty;

        [JsonPropertyName("name")]
        public string Name { get; set; } = string.Empty;

        [JsonPropertyName("isActive")]
        public bool IsActive { get; set; }

        [JsonPropertyName("queueDepth")]
        public int QueueDepth { get; set; }

        [JsonPropertyName("processedCount")]
        public int ProcessedCount { get; set; }

        [JsonPropertyName("errorCount")]
        public int ErrorCount { get; set; }

        [JsonPropertyName("lastProcessed")]
        public DateTime LastProcessed { get; set; }

        [JsonPropertyName("watchPath")]
        public string WatchPath { get; set; } = string.Empty;

        [JsonPropertyName("outputPath")]
        public string OutputPath { get; set; } = string.Empty;

        // Backward compatibility
        [JsonIgnore]
        public int QueueLength => QueueDepth;

        [JsonIgnore]
        public int TotalProcessed => ProcessedCount;

        [JsonIgnore]
        public int TotalFailed => ErrorCount;

        [JsonIgnore]
        public int TotalSuccessful => ProcessedCount - ErrorCount;

        [JsonIgnore]
        public List<string> WatchedFolders => new() { WatchPath };

        [JsonIgnore]
        public int ActiveProcessing => 0; // Not in new API
    }

    /// <summary>
    /// Service configuration information
    /// </summary>
    public class ServiceConfigurationInfo
    {
        [JsonPropertyName("path")]
        public string? Path { get; set; }

        [JsonPropertyName("logsDirectory")]
        public string? LogsDirectory { get; set; }

        // Legacy properties
        public string? DefaultOutputFolder { get; set; }
        public string? ExifToolPath { get; set; }
        public string? Version { get; set; }
    }
}


================================================================================
FILE: src\CamBridge.Config\obj\x64\Release\net8.0-windows\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
================================================================================

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


================================================================================
FILE: src\CamBridge.Config\obj\x64\Release\net8.0-windows\CamBridge.Config.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.10+ee5ebf36a408cf8cb648db40b0c428beb752eef8")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Config")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows7.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows7.0")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Config\obj\x64\Release\net8.0-windows\CamBridge.Config_xul0liq2_wpftmp.AssemblyInfo.cs
================================================================================

//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.42000
//
//     Ã„nderungen an dieser Datei kÃ¶nnen falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyCopyrightAttribute("Â© 2025 Claude\'s Improbably Reliable Software Solutions")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("0.8.10+ee5ebf36a408cf8cb648db40b0c428beb752eef8")]
[assembly: System.Reflection.AssemblyProductAttribute("CamBridge Medical Image Converter")]
[assembly: System.Reflection.AssemblyTitleAttribute("CamBridge.Config")]
[assembly: System.Reflection.AssemblyVersionAttribute("0.8.10.0")]
[assembly: System.Reflection.AssemblyMetadataAttribute("RepositoryUrl", "https://github.com/yourusername/CamBridge")]
[assembly: System.Resources.NeutralResourcesLanguageAttribute("en-US")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows7.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows7.0")]

// Von der MSBuild WriteCodeFragment-Klasse generiert.



================================================================================
FILE: src\CamBridge.Config\Services\ConfigurationService.cs
================================================================================

// src\CamBridge.Config\Services\ConfigurationService.cs
// Version: 0.7.17
// Description: Configuration service with enum validation
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using CamBridge.Core;
using CamBridge.Core.Infrastructure;
using System.Diagnostics;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Configuration service using centralized config management
    /// KISS: One config path, one format (V2 with CamBridge wrapper)!
    /// NEW in 0.7.17: Enum validation for OutputOrganization
    /// </summary>
    public class ConfigurationService : IConfigurationService
    {
        private readonly JsonSerializerOptions _jsonOptions;
        private readonly string _configPath;

        public ConfigurationService()
        {
            _jsonOptions = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNameCaseInsensitive = true,
                // Add converter for enum validation
                Converters = { new JsonStringEnumConverter() }
            };

            // SINGLE SOURCE OF TRUTH!
            _configPath = ConfigurationPaths.GetPrimaryConfigPath();

            Debug.WriteLine("=== ConfigurationService INIT ===");
            Debug.WriteLine($"Config Path: {_configPath}");
            Debug.WriteLine($"Config Exists: {File.Exists(_configPath)}");
            Debug.WriteLine("=================================");
        }

        public async Task<T?> LoadConfigurationAsync<T>() where T : class
        {
            Debug.WriteLine($"\n=== LOADING {typeof(T).Name} ===");
            Debug.WriteLine($"From: {_configPath}");

            try
            {
                if (!File.Exists(_configPath))
                {
                    Debug.WriteLine("Config file not found - will be created by InitializePrimaryConfig");
                    return null;
                }

                var json = await File.ReadAllTextAsync(_configPath);
                Debug.WriteLine($"Read {json.Length} characters");

                // Special handling for CamBridgeSettingsV2 - ALWAYS load from "CamBridge" section
                if (typeof(T) == typeof(CamBridgeSettingsV2))
                {
                    using var doc = JsonDocument.Parse(json);
                    var root = doc.RootElement;

                    // We REQUIRE a "CamBridge" section - no fallbacks!
                    if (!root.TryGetProperty("CamBridge", out var cambridgeSection))
                    {
                        throw new InvalidOperationException(
                            "Configuration file is missing required 'CamBridge' section! " +
                            "This is not a valid V2 configuration file. " +
                            "Expected format: { \"CamBridge\": { \"Version\": \"2.0\", ... } }");
                    }

                    // Deserialize from the CamBridge section
                    var settings = JsonSerializer.Deserialize<CamBridgeSettingsV2>(
                        cambridgeSection.GetRawText(),
                        _jsonOptions);

                    if (settings == null)
                    {
                        throw new InvalidOperationException(
                            "Failed to deserialize CamBridge section to CamBridgeSettingsV2");
                    }

                    // NEW in 0.7.17: Validate all enum values in pipelines
                    ValidateEnumValues(settings);

                    Debug.WriteLine($"âœ… Loaded settings from CamBridge section");
                    Debug.WriteLine($"   Version: {settings.Version}");
                    Debug.WriteLine($"   Pipelines: {settings.Pipelines.Count}");
                    Debug.WriteLine($"   MappingSets: {settings.MappingSets.Count}");

                    return settings as T;
                }
                else
                {
                    // Generic deserialization (for other types if needed)
                    var config = JsonSerializer.Deserialize<T>(json, _jsonOptions);
                    if (config != null)
                    {
                        Debug.WriteLine($"âœ… Loaded {typeof(T).Name} successfully");
                        return config;
                    }
                }

                Debug.WriteLine("âŒ Failed to deserialize config");
                return null;
            }
            catch (JsonException jsonEx)
            {
                // Special handling for enum parsing errors
                if (jsonEx.Message.Contains("OutputOrganization"))
                {
                    throw new InvalidOperationException(
                        "Invalid OutputOrganization value in configuration. " +
                        "Valid values are: None, ByPatient, ByDate, ByPatientAndDate. " +
                        "Please check your pipeline ProcessingOptions settings.", jsonEx);
                }
                throw;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR loading config: {ex.Message}");
                Debug.WriteLine($"Stack: {ex.StackTrace}");
                throw;
            }
        }

        /// <summary>
        /// NEW in 0.7.17: Validate enum values after deserialization
        /// </summary>
        private void ValidateEnumValues(CamBridgeSettingsV2 settings)
        {
            var validOutputOrgValues = Enum.GetNames(typeof(OutputOrganization));
            var validOutputOrgStr = string.Join(", ", validOutputOrgValues);

            foreach (var pipeline in settings.Pipelines)
            {
                // Validate OutputOrganization
                if (pipeline.ProcessingOptions != null)
                {
                    var orgValue = pipeline.ProcessingOptions.OutputOrganization;
                    if (!Enum.IsDefined(typeof(OutputOrganization), orgValue))
                    {
                        throw new InvalidOperationException(
                            $"Pipeline '{pipeline.Name}' has invalid OutputOrganization value. " +
                            $"Valid values are: {validOutputOrgStr}. " +
                            $"Found: {orgValue}");
                    }
                }

                // Validate PostProcessingActions
                if (pipeline.ProcessingOptions != null)
                {
                    if (!Enum.IsDefined(typeof(PostProcessingAction), pipeline.ProcessingOptions.SuccessAction))
                    {
                        throw new InvalidOperationException(
                            $"Pipeline '{pipeline.Name}' has invalid SuccessAction value. " +
                            $"Valid values are: {string.Join(", ", Enum.GetNames(typeof(PostProcessingAction)))}");
                    }

                    if (!Enum.IsDefined(typeof(PostProcessingAction), pipeline.ProcessingOptions.FailureAction))
                    {
                        throw new InvalidOperationException(
                            $"Pipeline '{pipeline.Name}' has invalid FailureAction value. " +
                            $"Valid values are: {string.Join(", ", Enum.GetNames(typeof(PostProcessingAction)))}");
                    }
                }
            }

            Debug.WriteLine("âœ… All enum values validated successfully");
        }

        public async Task SaveConfigurationAsync<T>(T configuration) where T : class
        {
            if (configuration == null)
                throw new ArgumentNullException(nameof(configuration));

            try
            {
                Debug.WriteLine($"\n=== SAVING {typeof(T).Name} ===");
                Debug.WriteLine($"To: {_configPath}");

                // Create backup before saving
                if (File.Exists(_configPath))
                {
                    try
                    {
                        // Simple inline backup implementation
                        var backupPath = $"{_configPath}.backup_{DateTime.Now:yyyyMMdd_HHmmss}";
                        File.Copy(_configPath, backupPath, true);
                        Debug.WriteLine($"Created backup: {backupPath}");
                    }
                    catch (Exception backupEx)
                    {
                        Debug.WriteLine($"Backup failed (continuing): {backupEx.Message}");
                    }
                }

                // For CamBridgeSettingsV2, we ALWAYS wrap it in the CamBridge section
                if (configuration is CamBridgeSettingsV2 v2Settings)
                {
                    // Validate before saving
                    ValidateEnumValues(v2Settings);

                    // Create wrapper object with proper V2 format
                    var wrapper = new Dictionary<string, object>
                    {
                        ["CamBridge"] = v2Settings,
                        ["Logging"] = new
                        {
                            LogLevel = new
                            {
                                Default = "Information",
                                Microsoft = "Warning",
                                CamBridge = "Information"
                            }
                        }
                    };

                    var json = JsonSerializer.Serialize(wrapper, _jsonOptions);
                    await File.WriteAllTextAsync(_configPath, json);

                    Debug.WriteLine($"âœ… Config saved with CamBridge wrapper ({json.Length} characters)");
                    Debug.WriteLine($"   Pipelines saved: {v2Settings.Pipelines.Count}");
                }
                else
                {
                    // Generic save (shouldn't happen in normal use)
                    var json = JsonSerializer.Serialize(configuration, _jsonOptions);
                    await File.WriteAllTextAsync(_configPath, json);
                    Debug.WriteLine($"âœ… Config saved successfully ({json.Length} characters)");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ERROR saving config: {ex.Message}");
                throw new InvalidOperationException($"Failed to save configuration to {_configPath}", ex);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\HttpApiService.cs
================================================================================

/**************************************************************************
*  HttpApiService.cs                                                      *
*  PATH: src\CamBridge.Config\Services\HttpApiService.cs                  *
*  VERSION: 0.7.11 | SIZE: ~7KB | MODIFIED: 2025-06-13                   *
*                                                                         *
*  DESCRIPTION: HTTP client for CamBridge Service API with PORT FIX      *
*  Copyright (c) 2025 Claude's Improbably Reliable Software Solutions     *
**************************************************************************/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using CamBridge.Config.Models;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// KISS implementation of IApiService - now with correct port!
    /// </summary>
    public class HttpApiService : IApiService
    {
        private readonly HttpClient _httpClient;

        public HttpApiService(HttpClient httpClient, object? unused = null)
        {
            _httpClient = httpClient;
            // CRITICAL FIX: Use port 5111 to match Service configuration!
            _httpClient.BaseAddress = new Uri("http://localhost:5111/"); // FIX: Was 5050!
            _httpClient.Timeout = TimeSpan.FromSeconds(5);
        }

        public async Task<ServiceStatusModel?> GetStatusAsync()
        {
            return await TryGetAsync<ServiceStatusModel>("api/status");
        }

        public async Task<bool> IsServiceAvailableAsync()
        {
            return await TryGetAsync<object>("health") != null;
        }

        public async Task<DetailedStatisticsModel?> GetStatisticsAsync()
        {
            // KISS: Not implemented yet, return null
            await Task.CompletedTask;
            return null;
        }

        /// <summary>
        /// KISS Helper: One method to rule them all!
        /// </summary>
        private async Task<T?> TryGetAsync<T>(string endpoint) where T : class
        {
            try
            {
                var response = await _httpClient.GetAsync(endpoint);
                if (!response.IsSuccessStatusCode)
                {
                    Debug.WriteLine($"API call failed ({endpoint}): {response.StatusCode}");
                    return null;
                }

                var json = await response.Content.ReadAsStringAsync();
                Debug.WriteLine($"API Response ({endpoint}): {json.Length} characters");

                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };

                return JsonSerializer.Deserialize<T>(json, options);
            }
            catch (HttpRequestException httpEx)
            {
                Debug.WriteLine($"HTTP error ({endpoint}): {httpEx.Message}");
                return null;
            }
            catch (TaskCanceledException)
            {
                Debug.WriteLine($"API call timeout ({endpoint})");
                return null;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"API call failed ({endpoint}): {ex.Message}");
                return null;
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\IApiService.cs
================================================================================

// src/CamBridge.Config/Services/IApiService.cs
// Version: 0.7.8
// Description: Interface for CamBridge Service API - KISS without DeadLetter!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CamBridge.Config.Models;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Interface for CamBridge Service API communication
    /// KISS: Removed DeadLetter methods!
    /// </summary>
    public interface IApiService
    {
        /// <summary>
        /// Gets the current service status
        /// </summary>
        Task<ServiceStatusModel?> GetStatusAsync();

        /// <summary>
        /// Gets detailed statistics
        /// </summary>
        Task<DetailedStatisticsModel?> GetStatisticsAsync();

        /// <summary>
        /// Checks if the service is reachable
        /// </summary>
        Task<bool> IsServiceAvailableAsync();
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\IConfigurationService.cs
================================================================================

using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    public interface IConfigurationService
    {
        Task<T?> LoadConfigurationAsync<T>() where T : class;
        Task SaveConfigurationAsync<T>(T configuration) where T : class;
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\INavigationService.cs
================================================================================

using System;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Navigation service interface
    /// </summary>
    public interface INavigationService
    {
        bool CanGoBack { get; }
        void NavigateTo(string pageKey);
        void GoBack();
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\IPipelineSettingsService.cs
================================================================================

// src\CamBridge.Config\Services\IPipelineSettingsService.cs
// Version: 0.8.5
// Description: Service interface for pipeline settings operations
// Session: 95 - Extracting business logic from ViewModels

using CamBridge.Core;
using System;
using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Service for pipeline settings operations
    /// Extracted from PipelineConfigViewModel to enable testing
    /// </summary>
    public interface IPipelineSettingsService
    {
        /// <summary>
        /// Load settings from configuration
        /// </summary>
        Task<CamBridgeSettingsV2?> LoadSettingsAsync();

        /// <summary>
        /// Save settings to configuration with backup
        /// </summary>
        Task SaveSettingsAsync(CamBridgeSettingsV2 settings);

        /// <summary>
        /// Create a deep clone of a pipeline configuration
        /// </summary>
        PipelineConfiguration ClonePipeline(PipelineConfiguration source);

        /// <summary>
        /// Create a new pipeline with default settings
        /// </summary>
        PipelineConfiguration CreateDefaultPipeline(string? name = null);

        /// <summary>
        /// Validate pipeline configuration
        /// </summary>
        ValidationResult ValidatePipeline(PipelineConfiguration pipeline);

        /// <summary>
        /// Get backup path for current save operation
        /// </summary>
        string GetBackupPath();
    }

    /// <summary>
    /// Result of pipeline validation
    /// </summary>
    public class ValidationResult
    {
        public bool IsValid { get; init; }
        public string[] Errors { get; init; } = Array.Empty<string>();
        public string[] Warnings { get; init; } = Array.Empty<string>();

        public static ValidationResult Success() => new() { IsValid = true };

        public static ValidationResult Failure(params string[] errors) => new()
        {
            IsValid = false,
            Errors = errors
        };
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\IServiceManager.cs
================================================================================

// src/CamBridge.Config/Services/IServiceManager.cs
using System;
using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Interface for managing the CamBridge Windows Service
    /// </summary>
    public interface IServiceManager
    {
        /// <summary>
        /// Checks if the application is running with administrator privileges
        /// </summary>
        bool IsRunningAsAdministrator();

        /// <summary>
        /// Checks if the CamBridge service is installed
        /// </summary>
        Task<bool> IsServiceInstalledAsync();

        /// <summary>
        /// Gets the current status of the CamBridge service
        /// </summary>
        Task<ServiceStatus> GetServiceStatusAsync();

        /// <summary>
        /// Gets the start time of the service if it's running
        /// </summary>
        Task<DateTime?> GetServiceStartTimeAsync();

        /// <summary>
        /// Installs the CamBridge service
        /// </summary>
        Task<bool> InstallServiceAsync();

        /// <summary>
        /// Uninstalls the CamBridge service
        /// </summary>
        Task<bool> UninstallServiceAsync();

        /// <summary>
        /// Starts the CamBridge service
        /// </summary>
        Task<bool> StartServiceAsync();

        /// <summary>
        /// Stops the CamBridge service
        /// </summary>
        Task<bool> StopServiceAsync();

        /// <summary>
        /// Restarts the CamBridge service
        /// </summary>
        Task<bool> RestartServiceAsync();
    }

    /// <summary>
    /// Service status enumeration
    /// </summary>
    public enum ServiceStatus
    {
        Unknown,
        Running,
        Stopped,
        Starting,
        Stopping
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\ISettingsService.cs
================================================================================

// src\CamBridge.Config\Services\ISettingsService.cs
// Version: 0.7.3
// Description: Multi-layer settings service interface
// Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using CamBridge.Core;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Service for managing the 3-layer settings architecture:
    /// - System settings (shared between Service and Config Tool)
    /// - Pipeline configurations (shared, multiple instances)
    /// - User preferences (per-user UI settings)
    /// </summary>
    public interface ISettingsService
    {
        // === SYSTEM-WIDE SETTINGS ===

        /// <summary>
        /// Gets the current system settings
        /// </summary>
        Task<SystemSettings> GetSystemSettingsAsync();

        /// <summary>
        /// Saves system settings with backup
        /// </summary>
        Task SaveSystemSettingsAsync(SystemSettings settings);

        /// <summary>
        /// Reloads system settings from disk
        /// </summary>
        Task ReloadSystemSettingsAsync();

        /// <summary>
        /// Validates system settings
        /// </summary>
        Task<SettingsValidationResult> ValidateSystemSettingsAsync(SystemSettings settings);

        // === PIPELINE CONFIGURATIONS ===

        /// <summary>
        /// Gets all available pipeline configurations
        /// </summary>
        Task<IList<PipelineConfiguration>> GetPipelinesAsync();

        /// <summary>
        /// Gets a specific pipeline configuration
        /// </summary>
        Task<PipelineConfiguration?> GetPipelineAsync(Guid pipelineId);

        /// <summary>
        /// Saves a pipeline configuration
        /// </summary>
        Task SavePipelineAsync(PipelineConfiguration pipeline);

        /// <summary>
        /// Deletes a pipeline configuration
        /// </summary>
        Task DeletePipelineAsync(Guid pipelineId);

        /// <summary>
        /// Imports a pipeline configuration from file
        /// </summary>
        Task<PipelineConfiguration> ImportPipelineAsync(string filePath);

        /// <summary>
        /// Exports a pipeline configuration to file
        /// </summary>
        Task ExportPipelineAsync(Guid pipelineId, string filePath);

        /// <summary>
        /// Creates a copy of an existing pipeline
        /// </summary>
        Task<PipelineConfiguration> ClonePipelineAsync(Guid sourcePipelineId, string newName);

        // === USER PREFERENCES ===

        /// <summary>
        /// Gets the current user preferences
        /// </summary>
        Task<UserPreferences> GetUserPreferencesAsync();

        /// <summary>
        /// Saves user preferences
        /// </summary>
        Task SaveUserPreferencesAsync(UserPreferences preferences);

        /// <summary>
        /// Resets user preferences to defaults
        /// </summary>
        Task ResetUserPreferencesAsync();

        /// <summary>
        /// Exports user preferences for backup
        /// </summary>
        Task ExportUserPreferencesAsync(string filePath);

        /// <summary>
        /// Imports user preferences from backup
        /// </summary>
        Task ImportUserPreferencesAsync(string filePath);

        // === MIGRATION AND MAINTENANCE ===

        /// <summary>
        /// Checks if settings migration is needed and performs it
        /// </summary>
        Task<SettingsMigrationResult> MigrateSettingsIfNeededAsync();

        /// <summary>
        /// Creates backups of all settings
        /// </summary>
        Task<SettingsBackupResult> BackupAllSettingsAsync();

        /// <summary>
        /// Restores settings from a backup
        /// </summary>
        Task RestoreFromBackupAsync(string backupPath);

        /// <summary>
        /// Validates all settings files
        /// </summary>
        Task<SettingsHealthCheckResult> ValidateAllSettingsAsync();

        /// <summary>
        /// Cleans up old backups and temporary files
        /// </summary>
        Task CleanupAsync(int keepBackupCount = 10);

        // === EVENTS ===

        /// <summary>
        /// Raised when system settings change
        /// </summary>
        event EventHandler<SettingsChangedEventArgs>? SystemSettingsChanged;

        /// <summary>
        /// Raised when a pipeline configuration changes
        /// </summary>
        event EventHandler<PipelineChangedEventArgs>? PipelineChanged;

        /// <summary>
        /// Raised when user preferences change
        /// </summary>
        event EventHandler<SettingsChangedEventArgs>? UserPreferencesChanged;
    }

    /// <summary>
    /// Result of settings validation
    /// </summary>
    public class SettingsValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
    }

    /// <summary>
    /// Result of settings migration
    /// </summary>
    public class SettingsMigrationResult
    {
        public bool MigrationPerformed { get; set; }
        public string FromVersion { get; set; } = string.Empty;
        public string ToVersion { get; set; } = string.Empty;
        public List<string> MigratedFiles { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
    }

    /// <summary>
    /// Result of backup operation
    /// </summary>
    public class SettingsBackupResult
    {
        public bool Success { get; set; }
        public string BackupPath { get; set; } = string.Empty;
        public List<string> BackedUpFiles { get; set; } = new();
        public long TotalSizeBytes { get; set; }
    }

    /// <summary>
    /// Result of health check
    /// </summary>
    public class SettingsHealthCheckResult
    {
        public bool IsHealthy { get; set; }
        public Dictionary<string, FileHealthStatus> FileStatuses { get; set; } = new();
        public List<string> Issues { get; set; } = new();
    }

    /// <summary>
    /// Health status of a settings file
    /// </summary>
    public class FileHealthStatus
    {
        public bool Exists { get; set; }
        public bool IsReadable { get; set; }
        public bool IsWritable { get; set; }
        public bool IsValidJson { get; set; }
        public long SizeBytes { get; set; }
        public DateTime LastModified { get; set; }
    }

    /// <summary>
    /// Event args for settings changes
    /// </summary>
    public class SettingsChangedEventArgs : EventArgs
    {
        public string SettingsType { get; set; } = string.Empty;
        public string ChangedBy { get; set; } = string.Empty;
        public DateTime ChangeTime { get; set; } = DateTime.UtcNow;
    }

    /// <summary>
    /// Event args for pipeline changes
    /// </summary>
    public class PipelineChangedEventArgs : SettingsChangedEventArgs
    {
        public Guid PipelineId { get; set; }
        public string PipelineName { get; set; } = string.Empty;
        public PipelineChangeType ChangeType { get; set; }
    }

    /// <summary>
    /// Type of pipeline change
    /// </summary>
    public enum PipelineChangeType
    {
        Created,
        Updated,
        Deleted,
        Imported,
        Exported
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\NavigationService.cs
================================================================================

// src\CamBridge.Config\Services\NavigationService.cs
// Version: 0.7.28
// Description: Navigation service with LogViewer page added

using System;
using System.Collections.Generic;
using System.Windows.Controls;
using CamBridge.Config.Views;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;

namespace CamBridge.Config.Services
{
    public class NavigationService : INavigationService
    {
        private Frame? _frame;
        private readonly Dictionary<string, Type> _pages = new();
        private readonly IServiceProvider _serviceProvider;

        public NavigationService()
        {
            // Get service provider from App
            var app = (App)App.Current;
            _serviceProvider = app.Host!.Services;

            // Register pages - Updated with LogViewer
            _pages["Dashboard"] = typeof(DashboardPage);
            _pages["PipelineConfig"] = typeof(PipelineConfigPage);
            _pages["DeadLetters"] = typeof(DeadLettersPage);
            _pages["MappingEditor"] = typeof(MappingEditorPage);
            _pages["ServiceControl"] = typeof(ServiceControlPage);
            _pages["LogViewer"] = typeof(LogViewerPage);
            _pages["About"] = typeof(AboutPage);
        }

        public bool CanGoBack => _frame?.CanGoBack ?? false;

        public void SetFrame(object frame)
        {
            _frame = frame as Frame;
        }

        public void NavigateTo(string pageKey)
        {
            if (_frame != null && _pages.TryGetValue(pageKey, out var pageType))
            {
                var page = Activator.CreateInstance(pageType);

                // CRITICAL: Inject ViewModel based on page type!
                if (page is Page pageInstance)
                {
                    object? viewModel = pageKey switch
                    {
                        "Dashboard" => _serviceProvider.GetService<DashboardViewModel>(),
                        "PipelineConfig" => _serviceProvider.GetService<PipelineConfigViewModel>(),
                        "DeadLetters" => _serviceProvider.GetService<DeadLettersViewModel>(),
                        "MappingEditor" => _serviceProvider.GetService<MappingEditorViewModel>(),
                        "ServiceControl" => _serviceProvider.GetService<ServiceControlViewModel>(),
                        "LogViewer" => _serviceProvider.GetService<LogViewerViewModel>(),
                        _ => null
                    };

                    if (viewModel != null)
                    {
                        pageInstance.DataContext = viewModel;
                        System.Diagnostics.Debug.WriteLine($"NavigationService: Injected {viewModel.GetType().Name} into {pageType.Name}");
                    }

                    _frame.Navigate(pageInstance);
                }
            }
        }

        public void GoBack()
        {
            if (_frame?.CanGoBack == true)
            {
                _frame.GoBack();
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\PipelineSettingsService.cs
================================================================================

// src\CamBridge.Config\Services\PipelineSettingsService.cs
// Version: 0.8.10
// Description: Implementation of pipeline settings service - DeadLetterFolder removed!
// Session: 95 - Business logic extracted from ViewModels
// Session: 107 - DeadLetterFolder cleanup

using CamBridge.Core;
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Handles pipeline settings operations
    /// All business logic extracted from PipelineConfigViewModel
    /// </summary>
    public class PipelineSettingsService : IPipelineSettingsService
    {
        private readonly IConfigurationService _configurationService;

        public PipelineSettingsService(IConfigurationService configurationService)
        {
            _configurationService = configurationService ?? throw new ArgumentNullException(nameof(configurationService));
        }

        public async Task<CamBridgeSettingsV2?> LoadSettingsAsync()
        {
            Debug.WriteLine("PipelineSettingsService.LoadSettingsAsync called");

            var settings = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();

            if (settings != null)
            {
                Debug.WriteLine($"Settings loaded: Version={settings.Version}, Pipelines={settings.Pipelines.Count}");

                // Fix any null PacsConfiguration in existing pipelines
                foreach (var pipeline in settings.Pipelines)
                {
                    if (pipeline.PacsConfiguration == null)
                    {
                        Debug.WriteLine($"Creating PacsConfiguration for pipeline: {pipeline.Name}");
                        pipeline.PacsConfiguration = new PacsConfiguration();
                    }
                }
            }

            return settings;
        }

        public async Task SaveSettingsAsync(CamBridgeSettingsV2 settings)
        {
            await _configurationService.SaveConfigurationAsync(settings);
        }

        public PipelineConfiguration ClonePipeline(PipelineConfiguration source)
        {
            var cloned = new PipelineConfiguration
            {
                Id = source.Id,
                Name = source.Name,
                Description = source.Description,
                Enabled = source.Enabled,
                WatchSettings = new PipelineWatchSettings
                {
                    Path = source.WatchSettings.Path,
                    FilePattern = source.WatchSettings.FilePattern,
                    IncludeSubdirectories = source.WatchSettings.IncludeSubdirectories,
                    OutputPath = source.WatchSettings.OutputPath,
                    MinimumFileAgeSeconds = source.WatchSettings.MinimumFileAgeSeconds
                },
                ProcessingOptions = CloneProcessingOptions(source.ProcessingOptions),
                DicomOverrides = source.DicomOverrides != null ? new DicomOverrides
                {
                    InstitutionName = source.DicomOverrides.InstitutionName,
                    InstitutionDepartment = source.DicomOverrides.InstitutionDepartment,
                    StationName = source.DicomOverrides.StationName
                } : null,
                MappingSetId = source.MappingSetId,
                CreatedAt = source.CreatedAt,
                UpdatedAt = DateTime.UtcNow
            };

            // Clone PACS Configuration
            if (source.PacsConfiguration != null)
            {
                cloned.PacsConfiguration = new PacsConfiguration
                {
                    Enabled = source.PacsConfiguration.Enabled,
                    Host = source.PacsConfiguration.Host,
                    Port = source.PacsConfiguration.Port,
                    CalledAeTitle = source.PacsConfiguration.CalledAeTitle,
                    CallingAeTitle = source.PacsConfiguration.CallingAeTitle,
                    TimeoutSeconds = source.PacsConfiguration.TimeoutSeconds,
                    MaxConcurrentUploads = source.PacsConfiguration.MaxConcurrentUploads,
                    RetryOnFailure = source.PacsConfiguration.RetryOnFailure,
                    MaxRetryAttempts = source.PacsConfiguration.MaxRetryAttempts,
                    RetryDelaySeconds = source.PacsConfiguration.RetryDelaySeconds
                };
            }
            else
            {
                // Always ensure PacsConfiguration exists
                cloned.PacsConfiguration = new PacsConfiguration();
            }

            return cloned;
        }

        public PipelineConfiguration CreateDefaultPipeline(string? name = null)
        {
            var pipelineNumber = DateTime.Now.Ticks % 1000; // Simple unique number

            return new PipelineConfiguration
            {
                Id = Guid.NewGuid(),
                Name = name ?? $"Pipeline {pipelineNumber}",
                Description = "New pipeline configuration",
                Enabled = true,
                WatchSettings = new PipelineWatchSettings
                {
                    Path = @"C:\CamBridge\Watch\New",
                    FilePattern = "*.jpg;*.jpeg",
                    IncludeSubdirectories = false,
                    OutputPath = @"C:\CamBridge\Output\New",
                    MinimumFileAgeSeconds = 5
                },
                ProcessingOptions = new ProcessingOptions
                {
                    ArchiveFolder = @"C:\CamBridge\Archive",
                    ErrorFolder = @"C:\CamBridge\Errors",
                    // DeadLetterFolder removed! Just use ErrorFolder for all failures
                    SuccessAction = PostProcessingAction.Archive,
                    FailureAction = PostProcessingAction.MoveToError,
                    CreateBackup = true,
                    BackupFolder = @"C:\CamBridge\Backup",
                    MaxConcurrentProcessing = 2,
                    RetryOnFailure = true,
                    MaxRetryAttempts = 3,
                    OutputOrganization = OutputOrganization.ByPatientAndDate,
                    ProcessExistingOnStartup = false
                },
                PacsConfiguration = new PacsConfiguration
                {
                    Enabled = false,
                    Host = string.Empty,
                    Port = 104,
                    CalledAeTitle = string.Empty,
                    CallingAeTitle = "CAMBRIDGE",
                    TimeoutSeconds = 30,
                    MaxConcurrentUploads = 1,
                    RetryOnFailure = true,
                    MaxRetryAttempts = 3,
                    RetryDelaySeconds = 5
                },
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
        }

        public ValidationResult ValidatePipeline(PipelineConfiguration pipeline)
        {
            var errors = new System.Collections.Generic.List<string>();
            var warnings = new System.Collections.Generic.List<string>();

            // Basic validation
            if (string.IsNullOrWhiteSpace(pipeline.Name))
                errors.Add("Pipeline name is required");

            if (string.IsNullOrWhiteSpace(pipeline.WatchSettings.Path))
                errors.Add("Watch folder path is required");
            else if (!Directory.Exists(pipeline.WatchSettings.Path))
                warnings.Add($"Watch folder does not exist: {pipeline.WatchSettings.Path}");

            // PACS validation if enabled
            if (pipeline.PacsConfiguration?.Enabled == true)
            {
                if (string.IsNullOrWhiteSpace(pipeline.PacsConfiguration.Host))
                    errors.Add("PACS host is required when PACS upload is enabled");

                if (string.IsNullOrWhiteSpace(pipeline.PacsConfiguration.CalledAeTitle))
                    errors.Add("Called AE Title is required when PACS upload is enabled");

                if (string.IsNullOrWhiteSpace(pipeline.PacsConfiguration.CallingAeTitle))
                    errors.Add("Calling AE Title is required when PACS upload is enabled");

                if (pipeline.PacsConfiguration.CalledAeTitle?.Length > 16)
                    errors.Add("Called AE Title must be 16 characters or less");

                if (pipeline.PacsConfiguration.CallingAeTitle?.Length > 16)
                    errors.Add("Calling AE Title must be 16 characters or less");

                if (pipeline.PacsConfiguration.Port <= 0 || pipeline.PacsConfiguration.Port > 65535)
                    errors.Add("PACS port must be between 1 and 65535");
            }

            return errors.Any()
                ? ValidationResult.Failure(errors.ToArray())
                : ValidationResult.Success();
        }

        public string GetBackupPath()
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                "CamBridge",
                $"appsettings.json.backup_{DateTime.Now:yyyyMMdd_HHmmss}");
        }

        private ProcessingOptions CloneProcessingOptions(ProcessingOptions source)
        {
            return new ProcessingOptions
            {
                SuccessAction = source.SuccessAction,
                FailureAction = source.FailureAction,
                ArchiveFolder = source.ArchiveFolder,
                ErrorFolder = source.ErrorFolder,
                BackupFolder = source.BackupFolder,
                CreateBackup = source.CreateBackup,
                MaxConcurrentProcessing = source.MaxConcurrentProcessing,
                RetryOnFailure = source.RetryOnFailure,
                MaxRetryAttempts = source.MaxRetryAttempts,
                OutputOrganization = source.OutputOrganization,
                ProcessExistingOnStartup = source.ProcessExistingOnStartup
                // DeadLetterFolder removed! ErrorFolder handles all failures now
            };
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Services\ServiceManager.cs
================================================================================

// src/CamBridge.Config/Services/ServiceManager.cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Principal;
using System.ServiceProcess;
using System.Text;
using System.Threading.Tasks;

namespace CamBridge.Config.Services
{
    /// <summary>
    /// Implementation of service management functionality
    /// </summary>
    public class ServiceManager : IServiceManager
    {
        private const string ServiceName = "CamBridgeService";
        private const string ServiceDisplayName = "CamBridge Image Processing Service";
        private const string ServiceDescription = "Monitors folders for JPEG images and converts them to DICOM format.";

        public bool IsRunningAsAdministrator()
        {
            var identity = WindowsIdentity.GetCurrent();
            var principal = new WindowsPrincipal(identity);
            return principal.IsInRole(WindowsBuiltInRole.Administrator);
        }

        public async Task<bool> IsServiceInstalledAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    using var controller = ServiceController.GetServices()
                        .FirstOrDefault(s => s.ServiceName == ServiceName);
                    return controller != null;
                }
                catch
                {
                    return false;
                }
            });
        }

        public async Task<ServiceStatus> GetServiceStatusAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    using var controller = new ServiceController(ServiceName);
                    controller.Refresh();

                    return controller.Status switch
                    {
                        ServiceControllerStatus.Running => ServiceStatus.Running,
                        ServiceControllerStatus.Stopped => ServiceStatus.Stopped,
                        ServiceControllerStatus.StartPending => ServiceStatus.Starting,
                        ServiceControllerStatus.StopPending => ServiceStatus.Stopping,
                        _ => ServiceStatus.Unknown
                    };
                }
                catch
                {
                    return ServiceStatus.Unknown;
                }
            });
        }

        public async Task<DateTime?> GetServiceStartTimeAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    // Try to get start time from Windows Management
                    using var process = Process.GetProcessesByName("CamBridge.Service").FirstOrDefault();
                    return process?.StartTime;
                }
                catch
                {
                    return null;
                }
            });
        }

        public async Task<bool> InstallServiceAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    // Find the service executable
                    var serviceExePath = FindServiceExecutable();
                    if (string.IsNullOrEmpty(serviceExePath))
                    {
                        // Log all searched paths for debugging
                        var searchPaths = GetSearchPaths();
                        var pathList = string.Join("\n", searchPaths);

                        // Create a detailed error message
                        var errorMsg = new StringBuilder();
                        errorMsg.AppendLine("Could not find CamBridge.Service.exe");
                        errorMsg.AppendLine("\nSearched in:");
                        foreach (var path in searchPaths)
                        {
                            var exists = File.Exists(path);
                            errorMsg.AppendLine($"  {(exists ? "âœ“" : "âœ—")} {path}");
                        }

                        throw new FileNotFoundException(errorMsg.ToString());
                    }

                    // Log the found path
                    Debug.WriteLine($"Found service executable at: {serviceExePath}");

                    // Use sc.exe to install the service
                    var processInfo = new ProcessStartInfo
                    {
                        FileName = "sc.exe",
                        Arguments = $"create {ServiceName} binPath= \"{serviceExePath}\" DisplayName= \"{ServiceDisplayName}\" start= auto",
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = true,
                        Verb = "runas"
                    };

                    using var process = Process.Start(processInfo);
                    if (process == null)
                    {
                        throw new InvalidOperationException("Failed to start sc.exe process");
                    }

                    var output = process.StandardOutput.ReadToEnd();
                    var error = process.StandardError.ReadToEnd();
                    process.WaitForExit();

                    Debug.WriteLine($"sc.exe output: {output}");
                    if (!string.IsNullOrEmpty(error))
                    {
                        Debug.WriteLine($"sc.exe error: {error}");
                    }

                    if (process.ExitCode == 0)
                    {
                        // Set service description
                        var descProcessInfo = new ProcessStartInfo
                        {
                            FileName = "sc.exe",
                            Arguments = $"description {ServiceName} \"{ServiceDescription}\"",
                            UseShellExecute = false,
                            CreateNoWindow = true,
                            Verb = "runas"
                        };

                        using var descProcess = Process.Start(descProcessInfo);
                        descProcess?.WaitForExit();

                        // Configure recovery options
                        ConfigureServiceRecovery();

                        return true;
                    }
                    else
                    {
                        var errorMessage = $"sc.exe failed with exit code {process.ExitCode}";
                        if (!string.IsNullOrEmpty(error))
                        {
                            errorMessage += $"\nError: {error}";
                        }
                        if (!string.IsNullOrEmpty(output) && output.Contains("error", StringComparison.OrdinalIgnoreCase))
                        {
                            errorMessage += $"\nOutput: {output}";
                        }

                        throw new InvalidOperationException(errorMessage);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Service installation failed: {ex}");
                    throw;
                }
            });
        }

        public async Task<bool> UninstallServiceAsync()
        {
            return await Task.Run(() =>
            {
                try
                {
                    // Use sc.exe to delete the service
                    var processInfo = new ProcessStartInfo
                    {
                        FileName = "sc.exe",
                        Arguments = $"delete {ServiceName}",
                        UseShellExecute = false,
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        CreateNoWindow = true,
                        Verb = "runas"
                    };

                    using var process = Process.Start(processInfo);
                    process?.WaitForExit();

                    return process?.ExitCode == 0;
                }
                catch
                {
                    return false;
                }
            });
        }

        public async Task<bool> StartServiceAsync()
        {
            try
            {
                using var controller = new ServiceController(ServiceName);

                if (controller.Status == ServiceControllerStatus.Running)
                    return true;

                controller.Start();
                await WaitForServiceStatusAsync(controller, ServiceControllerStatus.Running, TimeSpan.FromSeconds(30));

                return controller.Status == ServiceControllerStatus.Running;
            }
            catch
            {
                return false;
            }
        }

        public async Task<bool> StopServiceAsync()
        {
            try
            {
                using var controller = new ServiceController(ServiceName);

                if (controller.Status == ServiceControllerStatus.Stopped)
                    return true;

                controller.Stop();
                await WaitForServiceStatusAsync(controller, ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(30));

                return controller.Status == ServiceControllerStatus.Stopped;
            }
            catch
            {
                return false;
            }
        }

        public async Task<bool> RestartServiceAsync()
        {
            try
            {
                // Stop service
                var stopResult = await StopServiceAsync();
                if (!stopResult)
                    return false;

                // Wait a bit before starting
                await Task.Delay(1000);

                // Start service
                return await StartServiceAsync();
            }
            catch
            {
                return false;
            }
        }

        private async Task WaitForServiceStatusAsync(ServiceController controller, ServiceControllerStatus desiredStatus, TimeSpan timeout)
        {
            await Task.Run(() =>
            {
                try
                {
                    controller.WaitForStatus(desiredStatus, timeout);
                }
                catch (System.ServiceProcess.TimeoutException)
                {
                    // Status change timed out
                }
            });
        }

        private string? FindServiceExecutable()
        {
            var possiblePaths = GetSearchPaths();

            foreach (var path in possiblePaths)
            {
                try
                {
                    var normalizedPath = Path.GetFullPath(path);
                    Debug.WriteLine($"Checking: {normalizedPath}");
                    if (File.Exists(normalizedPath))
                    {
                        Debug.WriteLine($"Found service at: {normalizedPath}");
                        return normalizedPath;
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error checking path {path}: {ex.Message}");
                }
            }

            return null;
        }

        private string[] GetSearchPaths()
        {
            var paths = new List<string>
            {
                // Same directory as config app
                Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? "", "CamBridge.Service.exe"),
                // Parent directory (if config is in subfolder)
                Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? "", "..", "CamBridge.Service.exe"),
                // Debug/Release output paths
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "CamBridge.Service.exe"),
            };

            // Find solution directory first for more accurate paths
            var solutionDir = FindSolutionDirectory();
            if (!string.IsNullOrEmpty(solutionDir))
            {
                // Add all known locations from PROJECT_WISDOM
                paths.AddRange(new[]
                {
                    // Standard debug/release paths
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0", "CamBridge.Service.exe"),
                    
                    // win-x64 specific paths (from PROJECT_WISDOM)
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    
                    // x64 configuration paths
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Debug", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Release", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Release", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    
                    // net8.0-windows paths (this was missing!)
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0-windows", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0-windows", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Debug", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "Release", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Debug", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(solutionDir, "src", "CamBridge.Service", "bin", "x64", "Release", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    
                    // Published output
                    Path.Combine(solutionDir, "publish", "CamBridge.Service.exe")
                });
            }
            else
            {
                // Fallback paths relative to current directory
                paths.AddRange(new[]
                {
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "Debug", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "Release", "net8.0", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "x64", "Debug", "net8.0", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "CamBridge.Service", "bin", "x64", "Debug", "net8.0-windows", "win-x64", "CamBridge.Service.exe"),
                    Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "publish", "CamBridge.Service.exe")
                });
            }

            return paths.Distinct().ToArray();
        }

        private string? FindSolutionDirectory()
        {
            var directory = new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory);

            while (directory != null && directory.Parent != null)
            {
                if (directory.GetFiles("CamBridge.sln").Any())
                {
                    return directory.FullName;
                }
                directory = directory.Parent;
            }

            return null;
        }

        private void ConfigureServiceRecovery()
        {
            try
            {
                // Configure service to restart on failure
                var processInfo = new ProcessStartInfo
                {
                    FileName = "sc.exe",
                    Arguments = $"failure {ServiceName} reset= 86400 actions= restart/60000/restart/60000/restart/60000",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    Verb = "runas"
                };

                using var process = Process.Start(processInfo);
                process?.WaitForExit();
            }
            catch
            {
                // Recovery configuration is optional, so we don't fail the installation
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\DashboardViewModel.cs
================================================================================

// src\CamBridge.Config\ViewModels\DashboardViewModel.cs
// Version: 0.7.21
// Description: MINIMAL Dashboard - Just show if service is running!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using CamBridge.Config.Models;
using CamBridge.Config.Services;
using CamBridge.Core;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// MINIMAL Dashboard - KISS approach!
    /// </summary>
    public partial class DashboardViewModel : ObservableObject
    {
        private readonly IConfigurationService _configurationService;
        private DispatcherTimer? _refreshTimer;
        private readonly HttpClient _httpClient = new();

        [ObservableProperty]
        private string serviceStatus = "Checking...";

        [ObservableProperty]
        private bool isServiceRunning = false;

        [ObservableProperty]
        private string uptimeText = "";

        [ObservableProperty]
        private string versionText = "";

        [ObservableProperty]
        private DateTime lastUpdate = DateTime.Now;

        [ObservableProperty]
        private bool isLoading;

        // Collections
        public ObservableCollection<PipelineStatusViewModel> PipelineStatuses { get; }

        // Commands
        public IAsyncRelayCommand RefreshCommand { get; }
        public IAsyncRelayCommand StartServiceCommand { get; }

        public DashboardViewModel(IApiService? apiService = null, IConfigurationService? configurationService = null)
        {
            // We ignore IApiService - go direct!
            _configurationService = configurationService ?? new ConfigurationService();

            PipelineStatuses = new ObservableCollection<PipelineStatusViewModel>();

            RefreshCommand = new AsyncRelayCommand(RefreshAsync);
            StartServiceCommand = new AsyncRelayCommand(StartServiceAsync);

            // Setup timer
            _refreshTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(5)
            };
            _refreshTimer.Tick += async (s, e) => await RefreshAsync();
            _refreshTimer.Start();

            // Initial load
            Task.Run(async () => await RefreshAsync());
        }

        private async Task RefreshAsync()
        {
            try
            {
                IsLoading = true;
                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss}] Dashboard refresh...");

                // MINIMAL: Direct HTTP call!
                var response = await _httpClient.GetAsync("http://localhost:5111/api/status");

                if (response.IsSuccessStatusCode)
                {
                    var json = await response.Content.ReadAsStringAsync();
                    var status = JsonSerializer.Deserialize<ServiceStatusModel>(json, new JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true
                    });

                    if (status != null)
                    {
                        // Update UI on dispatcher
                        await Application.Current.Dispatcher.InvokeAsync(() =>
                        {
                            IsServiceRunning = true;
                            ServiceStatus = status.Service.Status;
                            UptimeText = $"Uptime: {status.Service.Uptime}";
                            VersionText = $"Version: {status.Service.Version}";

                            Debug.WriteLine($"Service is {status.ServiceStatus}!");

                            // Update pipelines
                            if (status.Pipelines != null)
                            {
                                UpdatePipelines(status.Pipelines);
                            }
                        });
                    }
                }
                else
                {
                    // Service offline
                    await Application.Current.Dispatcher.InvokeAsync(() =>
                    {
                        IsServiceRunning = false;
                        ServiceStatus = "Offline";
                        UptimeText = "";
                        VersionText = "";
                        Debug.WriteLine("Service is offline!");
                    });
                }

                LastUpdate = DateTime.Now;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Dashboard refresh error: {ex.Message}");

                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    IsServiceRunning = false;
                    ServiceStatus = "Offline";
                    UptimeText = "";
                    VersionText = "Cannot connect to service";
                });
            }
            finally
            {
                IsLoading = false;
            }
        }

private void UpdatePipelines(List<PipelineStatusData> pipelines)
{
    PipelineStatuses.Clear();

    foreach (var p in pipelines)
    {
        PipelineStatuses.Add(new PipelineStatusViewModel
        {
            PipelineName = p.Name,
            Status = p.IsActive ? "Active" : "Inactive",
            IsEnabled = p.IsActive,
            QueueLength = p.QueueDepth,           // Changed from QueueLength
            ProcessedToday = p.ProcessedCount,    // Changed from TotalProcessed
            ErrorsToday = p.ErrorCount,           // Changed from TotalFailed
            WatchFolder = p.WatchPath             // Changed from WatchedFolders[0]
        });
    }
}

        private async Task StartServiceAsync()
        {
            try
            {
                var startInfo = new ProcessStartInfo
                {
                    FileName = "net.exe",
                    Arguments = "start CamBridgeService",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    Verb = "runas"
                };

                var process = Process.Start(startInfo);
                await process!.WaitForExitAsync();

                // Wait and refresh
                await Task.Delay(2000);
                await RefreshAsync();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Failed to start service: {ex.Message}");
            }
        }

        public void Cleanup()
        {
            _refreshTimer?.Stop();
            _httpClient?.Dispose();
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\DeadLettersViewModel.cs
================================================================================

// src/CamBridge.Config/ViewModels/DeadLettersViewModel.cs
// Version: 0.7.8
// Description: SIMPLE error folder viewer - KISS approach!

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Simple ViewModel for error folder viewing - KISS!
    /// </summary>
    public partial class DeadLettersViewModel : ViewModelBase
    {
        [ObservableProperty] private string _errorFolder;
        [ObservableProperty] private bool _errorFolderExists;
        [ObservableProperty] private int _errorFileCount;

        public DeadLettersViewModel()
        {
            // Default error folder from ProcessingOptions
            _errorFolder = @"C:\CamBridge\Errors";
            CheckErrorFolder();
        }

        /// <summary>
        /// Open error folder in Windows Explorer
        /// </summary>
        [RelayCommand]
        private void OpenErrorFolder()
        {
            try
            {
                if (!Directory.Exists(ErrorFolder))
                {
                    Directory.CreateDirectory(ErrorFolder);
                }

                Process.Start("explorer.exe", ErrorFolder);
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show(
                    $"Could not open error folder: {ex.Message}",
                    "Error",
                    System.Windows.MessageBoxButton.OK,
                    System.Windows.MessageBoxImage.Warning);
            }
        }

        /// <summary>
        /// Refresh error folder status
        /// </summary>
        [RelayCommand]
        private async Task RefreshAsync()
        {
            await Task.Run(() => CheckErrorFolder());
        }

        /// <summary>
        /// Check if error folder exists and count files
        /// </summary>
        private void CheckErrorFolder()
        {
            try
            {
                ErrorFolderExists = Directory.Exists(ErrorFolder);

                if (ErrorFolderExists)
                {
                    var errorFiles = Directory.GetFiles(ErrorFolder, "*.jpg", SearchOption.AllDirectories);
                    ErrorFileCount = errorFiles.Length;
                }
                else
                {
                    ErrorFileCount = 0;
                }
            }
            catch
            {
                ErrorFileCount = 0;
            }
        }

        public void Cleanup()
        {
            // Nothing to cleanup in simple implementation
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\LogViewerViewModel.cs
================================================================================

// src\CamBridge.Config\ViewModels\LogViewerViewModel.cs
// Version: 0.8.9
// Description: Enhanced log viewer with Triple Filter and Default Expanded
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.Services;
using CamBridge.Core;
using CamBridge.Core.Enums;
using CamBridge.Core.Infrastructure;
using CamBridge.Core.Logging;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;


namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Tracks file position for incremental reading
    /// </summary>
    public class FilePositionInfo
    {
        public long Position { get; set; }
        public DateTime LastRead { get; set; }
    }

    /// <summary>
    /// Represents a selectable pipeline in the multi-select dropdown
    /// </summary>
    public class PipelineSelection : ViewModelBase
    {
        private bool _isSelected;

        public string Name { get; set; } = string.Empty;
        public string SanitizedName { get; set; } = string.Empty;

        public bool IsSelected
        {
            get => _isSelected;
            set => SetProperty(ref _isSelected, value);
        }
    }

    /// <summary>
    /// Enhanced ViewModel for the log viewer with correlation ID support
    /// </summary>
    public partial class LogViewerViewModel : ViewModelBase
    {
        private readonly ILogger<LogViewerViewModel> _logger;
        private readonly IConfigurationService _configurationService;
        private readonly Dictionary<string, string> _pipelineNameMapping;
        private readonly Timer _refreshTimer;
        private readonly Dictionary<string, long> _filePositions;
        private CancellationTokenSource? _watcherCancellation;
        private FileSystemWatcher? _logWatcher;

        // Constants
        private const int MaxDisplayedEntries = 10000;
        private const int TailLineCount = 1000;
        private const int RefreshIntervalMs = 1000;

        public LogViewerViewModel(
            ILogger<LogViewerViewModel> logger,
            IConfigurationService configurationService)
        {
            _logger = logger;
            _configurationService = configurationService;
            _pipelineNameMapping = new Dictionary<string, string>();
            _filePositions = new Dictionary<string, long>();

            // Initialize collections
            LogEntries = new ObservableCollection<LogEntry>();
            FilteredCombinedEntries = new ObservableCollection<LogEntry>();
            CombinedLogEntries = new ObservableCollection<LogEntry>();
            CorrelationGroups = new ObservableCollection<CorrelationGroup>();
            AvailablePipelines = new ObservableCollection<string>();
            PipelineSelections = new ObservableCollection<PipelineSelection>();

            // Initialize commands
            RefreshCommand = new AsyncRelayCommand(RefreshLogsAsync);
            ClearLogCommand = new RelayCommand(ClearLogs);
            ExportLogCommand = new AsyncRelayCommand(ExportLogsAsync);
            ToggleTreeViewCommand = new RelayCommand(() => IsTreeViewEnabled = !IsTreeViewEnabled);
            ExpandAllCommand = new RelayCommand(ExpandAll);
            CollapseAllCommand = new RelayCommand(CollapseAll);
            CopySelectedCommand = new RelayCommand(CopySelected);
            OpenLogFolderCommand = new RelayCommand(OpenLogFolder);
            ClearFiltersCommand = new RelayCommand(ClearFilters);
            CopyLineCommand = new RelayCommand<object>(CopyLine);
            CopyGroupCommand = new RelayCommand<object>(CopyGroup);
            ExpandGroupCommand = new RelayCommand<object>(ExpandGroup);

            // Initialize timer for auto-refresh
            _refreshTimer = new Timer(OnRefreshTimer, null, Timeout.Infinite, Timeout.Infinite);

            // Set default filter values
            ShowDebug = false;  // Debug meist zu viel
            ShowInformation = true;
            ShowWarning = true;
            ShowError = true;
            ShowCritical = true;
            IsAutoScrollEnabled = false; // Default OFF to prevent flicker
            IsTreeViewEnabled = true; // Default to tree view for correlation
        }

        #region Properties

        [ObservableProperty]
        private ObservableCollection<LogEntry> logEntries;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(DisplayedLineCount))]
        private ObservableCollection<LogEntry> filteredCombinedEntries;

        [ObservableProperty]
        private ObservableCollection<LogEntry> combinedLogEntries;

        [ObservableProperty]
        private ObservableCollection<CorrelationGroup> correlationGroups;

        [ObservableProperty]
        private ObservableCollection<string> availablePipelines;

        [ObservableProperty]
        private ObservableCollection<PipelineSelection> pipelineSelections;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string? searchText;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string filter1 = string.Empty;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string filter2 = string.Empty;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private string filter3 = string.Empty;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showDebug;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showInformation;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showWarning;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showError;

        [ObservableProperty]
        [NotifyPropertyChangedFor(nameof(FilteredCombinedEntries))]
        [NotifyPropertyChangedFor(nameof(CorrelationGroups))]
        private bool showCritical;

        [ObservableProperty]
        private bool isAutoScrollEnabled;

        [ObservableProperty]
        private bool isTreeViewEnabled;

        [ObservableProperty]
        private bool isLoading;

        [ObservableProperty]
        private string currentLogFile = "No log file loaded";

        [ObservableProperty]
        private string currentLogFiles = "No files selected";

        [ObservableProperty]
        private int totalLineCount;

        [ObservableProperty]
        private DateTime lastUpdateTime = DateTime.Now;

        public int DisplayedLineCount =>
            IsTreeViewEnabled
                ? CorrelationGroups?.Sum(g => g.TotalEntries) ?? 0
                : FilteredCombinedEntries?.Count ?? 0;

        public int SelectedPipelineCount => PipelineSelections?.Count(p => p.IsSelected) ?? 0;

        public int SelectedLevelCount
        {
            get
            {
                var count = 0;
                if (ShowDebug) count++;
                if (ShowInformation) count++;
                if (ShowWarning) count++;
                if (ShowError) count++;
                if (ShowCritical) count++;
                return count;
            }
        }

        #endregion

        #region Commands

        public IAsyncRelayCommand RefreshCommand { get; }
        public IRelayCommand ClearLogCommand { get; }
        public IAsyncRelayCommand ExportLogCommand { get; }
        public IRelayCommand ToggleTreeViewCommand { get; }
        public IRelayCommand ExpandAllCommand { get; }
        public IRelayCommand CollapseAllCommand { get; }
        public IRelayCommand CopySelectedCommand { get; }
        public IRelayCommand OpenLogFolderCommand { get; }
        public IRelayCommand ClearFiltersCommand { get; }
        public ICommand CopyLineCommand { get; }
        public ICommand CopyGroupCommand { get; }
        public ICommand ExpandGroupCommand { get; }

        #endregion

        #region Public Methods

        public async Task InitializeAsync()
        {
            try
            {
                _logger.LogInformation("Initializing Enhanced LogViewerViewModel");

                // Load available pipelines
                await LoadAvailablePipelinesAsync();

                // Update count display
                OnPropertyChanged(nameof(SelectedPipelineCount));
                OnPropertyChanged(nameof(SelectedLevelCount));

                // Log initial filter state
                _logger.LogInformation("Initial filter state: Debug={Debug}, Info={Info}, Warn={Warn}, Error={Error}, Critical={Critical}",
                    ShowDebug, ShowInformation, ShowWarning, ShowError, ShowCritical);

                // Log selected pipelines
                var selected = PipelineSelections.Where(p => p.IsSelected).Select(p => p.Name).ToList();
                _logger.LogInformation("Selected pipelines: {Pipelines}", string.Join(", ", selected));

                // Load initial logs
                await RefreshLogsAsync();

                // Start auto-refresh if enabled
                if (IsAutoScrollEnabled)
                {
                    _refreshTimer.Change(RefreshIntervalMs, RefreshIntervalMs);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to initialize LogViewerViewModel");
            }
        }

        public void Cleanup()
        {
            try
            {
                _refreshTimer?.Change(Timeout.Infinite, Timeout.Infinite);
                _refreshTimer?.Dispose();
                _watcherCancellation?.Cancel();
                _watcherCancellation?.Dispose();
                _logWatcher?.Dispose();

                // Unsubscribe from selection changes
                foreach (var selection in PipelineSelections)
                {
                    selection.PropertyChanged -= OnPipelineSelectionChanged;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during cleanup");
            }
        }

        #endregion

        #region Copy Command Implementations

        private void CopyLine(object? parameter)
        {
            if (parameter is LogEntry entry)
            {
                var text = $"[{entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff}] [{entry.CorrelationId}] [{entry.Stage}] {entry.Message}";
                Clipboard.SetText(text);
            }
        }

        private void CopyGroup(object? parameter)
        {
            if (parameter is CorrelationGroup group)
            {
                var sb = new StringBuilder();
                sb.AppendLine($"=== {group.CorrelationId} - {group.Pipeline} [{group.DurationText}] ===");

                // Get all entries sorted
                var allEntries = new List<LogEntry>();
                foreach (var stage in group.Stages)
                {
                    allEntries.AddRange(stage.Entries);
                }
                allEntries.AddRange(group.UngroupedEntries);

                foreach (var entry in allEntries.OrderBy(e => e.Timestamp))
                {
                    sb.AppendLine($"{entry.Timestamp:HH:mm:ss.fff} {entry.Stage}: {entry.Message}");
                }

                Clipboard.SetText(sb.ToString());
            }
        }

        private void ExpandGroup(object? parameter)
        {
            if (parameter is CorrelationGroup group)
            {
                group.IsExpanded = true;
                // In compact view we don't have nested stages anymore
            }
        }

        #endregion

        private void ApplyFilters()
        {
            // WICHTIG: Muss auf dem UI Thread laufen!
            if (!Application.Current.Dispatcher.CheckAccess())
            {
                Application.Current.Dispatcher.Invoke(() => ApplyFilters());
                return;
            }

            _logger.LogDebug("ApplyFilters: Starting with {Count} combined entries", CombinedLogEntries.Count);

            var filtered = CombinedLogEntries.AsEnumerable();

            // Apply level filters
            var anyLevelSelected = ShowDebug || ShowInformation || ShowWarning || ShowError || ShowCritical;

            if (anyLevelSelected)
            {
                filtered = filtered.Where(e =>
                    (ShowDebug && e.Level == LogLevel.Debug) ||
                    (ShowInformation && e.Level == LogLevel.Information) ||
                    (ShowWarning && e.Level == LogLevel.Warning) ||
                    (ShowError && e.Level == LogLevel.Error) ||
                    (ShowCritical && e.Level == LogLevel.Critical));
            }

            // Apply search filter (legacy single search)
            if (!string.IsNullOrWhiteSpace(SearchText))
            {
                var searchLower = SearchText.ToLowerInvariant();
                filtered = filtered.Where(e =>
                    e.Message.ToLowerInvariant().Contains(searchLower) ||
                    e.LevelText.ToLowerInvariant().Contains(searchLower) ||
                    e.Source.ToLowerInvariant().Contains(searchLower) ||
                    (e.CorrelationId?.ToLowerInvariant().Contains(searchLower) ?? false) ||
                    (e.Stage?.ToString().ToLowerInvariant().Contains(searchLower) ?? false));
            }

            // Update filtered collection
            var filteredList = filtered.ToList();

            // NEW: Apply Triple Text Filter if tree view is enabled
            if (IsTreeViewEnabled && (!string.IsNullOrWhiteSpace(Filter1) || !string.IsNullOrWhiteSpace(Filter2) || !string.IsNullOrWhiteSpace(Filter3)))
            {
                filteredList = ApplyTripleTextFilter(filteredList);
            }

            _logger.LogDebug("After filtering: {Count} entries remain", filteredList.Count);

            FilteredCombinedEntries.Clear();
            foreach (var entry in filteredList)
            {
                FilteredCombinedEntries.Add(entry);
            }

            // Update correlation groups if tree view is enabled
            if (IsTreeViewEnabled)
            {
                UpdateCorrelationGroups(filteredList);
            }
        }

        private List<LogEntry> ApplyTripleTextFilter(List<LogEntry> entries)
        {
            // For tree-aware filtering, we need to check groups
            var groups = entries
                .Where(e => !string.IsNullOrEmpty(e.CorrelationId))
                .GroupBy(e => e.CorrelationId!)
                .ToList();

            var matchingEntries = new List<LogEntry>();

            foreach (var group in groups)
            {
                // Check if ANY entry in the group matches ALL active filters
                bool groupMatches = group.Any(entry =>
                {
                    var fullText = $"{entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.CorrelationId} {entry.Stage} {entry.Message} {entry.Pipeline}";

                    return MatchesWildcard(fullText, Filter1) &&
                           MatchesWildcard(fullText, Filter2) &&
                           MatchesWildcard(fullText, Filter3);
                });

                if (groupMatches)
                {
                    // Include ALL entries from matching groups (tree-aware!)
                    matchingEntries.AddRange(group);
                }
            }

            // Also check uncorrelated entries individually
            var uncorrelated = entries.Where(e => string.IsNullOrEmpty(e.CorrelationId)).ToList();
            foreach (var entry in uncorrelated)
            {
                var fullText = $"{entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.Message} {entry.Pipeline}";

                if (MatchesWildcard(fullText, Filter1) &&
                    MatchesWildcard(fullText, Filter2) &&
                    MatchesWildcard(fullText, Filter3))
                {
                    matchingEntries.Add(entry);
                }
            }

            return matchingEntries;
        }

        private bool MatchesWildcard(string text, string pattern)
        {
            if (string.IsNullOrWhiteSpace(pattern)) return true;

            // Convert wildcard pattern to regex
            var regexPattern = "^" + Regex.Escape(pattern)
                .Replace("\\*", ".*")    // * = any number of chars
                .Replace("\\?", ".")     // ? = exactly one char
                + "$";

            return Regex.IsMatch(text, regexPattern, RegexOptions.IgnoreCase);
        }

        private void ClearFilters()
        {
            SearchText = string.Empty;
            Filter1 = string.Empty;
            Filter2 = string.Empty;
            Filter3 = string.Empty;
        }

        private void UpdateCorrelationGroups(List<LogEntry> entries)
        {
            // DEBUG OUTPUT
            Console.WriteLine($"[DEBUG] UpdateCorrelationGroups called with {entries.Count} entries");

            CorrelationGroups.Clear();

            // Group by correlation ID
            var groups = entries
                .Where(e => !string.IsNullOrEmpty(e.CorrelationId))
                .GroupBy(e => e.CorrelationId!)
                .OrderByDescending(g => g.Max(e => e.Timestamp));

            Console.WriteLine($"[DEBUG] Found {groups.Count()} correlation groups");

            foreach (var group in groups)
            {
                Console.WriteLine($"[DEBUG] Processing group {group.Key} with {group.Count()} entries");

                var correlationGroup = new CorrelationGroup
                {
                    CorrelationId = group.Key,
                    StartTime = group.Min(e => e.Timestamp),
                    EndTime = group.Max(e => e.Timestamp),
                    Pipeline = group.FirstOrDefault(e => !string.IsNullOrEmpty(e.Pipeline))?.Pipeline ?? "Unknown",
                    IsExpanded = true // Default expanded!
                };

                // Build stage hierarchy
                var stages = new Dictionary<ProcessingStage, StageGroup>();

                foreach (var entry in group.OrderBy(e => e.Timestamp))
                {
                    if (entry.Stage.HasValue)
                    {
                        if (!stages.ContainsKey(entry.Stage.Value))
                        {
                            stages[entry.Stage.Value] = new StageGroup
                            {
                                Stage = entry.Stage.Value,
                                StartTime = entry.Timestamp,
                                IsExpanded = true // Default expanded!
                            };
                        }

                        stages[entry.Stage.Value].Entries.Add(entry);
                        stages[entry.Stage.Value].EndTime = entry.Timestamp;
                    }
                    else
                    {
                        // Add entries without stage directly to correlation group
                        correlationGroup.UngroupedEntries.Add(entry);
                    }
                }

                // Add stages to correlation group
                foreach (var stage in stages.Values.OrderBy(s => s.StartTime))
                {
                    correlationGroup.Stages.Add(stage);
                }

                // Determine overall status
                if (stages.ContainsKey(ProcessingStage.Error))
                {
                    correlationGroup.Status = ProcessingStatus.Failed;
                }
                else if (stages.ContainsKey(ProcessingStage.Complete))
                {
                    correlationGroup.Status = ProcessingStatus.Completed;
                }
                else
                {
                    correlationGroup.Status = ProcessingStatus.InProgress;
                }

                CorrelationGroups.Add(correlationGroup);
            }

            // Add entries without correlation ID
            var uncorrelatedEntries = entries.Where(e => string.IsNullOrEmpty(e.CorrelationId)).ToList();
            Console.WriteLine($"[DEBUG] Found {uncorrelatedEntries.Count} uncorrelated entries");

            if (uncorrelatedEntries.Any())
            {
                var uncorrelatedGroup = new CorrelationGroup
                {
                    CorrelationId = "Uncorrelated",
                    StartTime = uncorrelatedEntries.Min(e => e.Timestamp),
                    EndTime = uncorrelatedEntries.Max(e => e.Timestamp),
                    Pipeline = "Various",
                    IsExpanded = true, // Default expanded!
                    Status = ProcessingStatus.Unknown
                };

                foreach (var entry in uncorrelatedEntries.OrderBy(e => e.Timestamp))
                {
                    uncorrelatedGroup.UngroupedEntries.Add(entry);
                }

                CorrelationGroups.Add(uncorrelatedGroup);
            }

            Console.WriteLine($"[DEBUG] Total CorrelationGroups: {CorrelationGroups.Count}");
        }

        private void ExpandAll()
        {
            foreach (var group in CorrelationGroups)
            {
                group.IsExpanded = true;
                foreach (var stage in group.Stages)
                {
                    stage.IsExpanded = true;
                }
            }
        }

        private void CollapseAll()
        {
            foreach (var group in CorrelationGroups)
            {
                group.IsExpanded = false;
                foreach (var stage in group.Stages)
                {
                    stage.IsExpanded = false;
                }
            }
        }

        private void CopySelected()
        {
            // Copy all visible log entries to clipboard
            var sb = new StringBuilder();

            if (IsTreeViewEnabled)
            {
                // Copy tree structure
                foreach (var group in CorrelationGroups)
                {
                    sb.AppendLine($"=== {group.CorrelationId} - {group.Pipeline} [{group.DurationText}] ===");

                    foreach (var stage in group.Stages)
                    {
                        sb.AppendLine($"  {stage.Stage} [{stage.DurationText}]");
                        foreach (var entry in stage.Entries)
                        {
                            sb.AppendLine($"    {entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                        }
                    }

                    if (group.UngroupedEntries.Any())
                    {
                        sb.AppendLine("  [Ungrouped]");
                        foreach (var entry in group.UngroupedEntries)
                        {
                            sb.AppendLine($"    {entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                        }
                    }

                    sb.AppendLine();
                }
            }
            else
            {
                // Copy flat list
                foreach (var entry in FilteredCombinedEntries)
                {
                    sb.AppendLine($"{entry.Timestamp:HH:mm:ss.fff} {entry.LevelText} [{entry.CorrelationId}] [{entry.Stage}] {entry.Message}");
                }
            }

            if (sb.Length > 0)
            {
                Clipboard.SetText(sb.ToString());
                _logger.LogInformation("Copied {Count} entries to clipboard",
                    IsTreeViewEnabled ? CorrelationGroups.Sum(g => g.TotalEntries) : FilteredCombinedEntries.Count);
            }
        }

        private void OpenLogFolder()
        {
            try
            {
                var logPath = ConfigurationPaths.GetLogsDirectory();
                if (Directory.Exists(logPath))
                {
                    Process.Start(new ProcessStartInfo
                    {
                        FileName = logPath,
                        UseShellExecute = true,
                        Verb = "open"
                    });
                    _logger.LogInformation("Opened log folder: {Path}", logPath);
                }
                else
                {
                    _logger.LogWarning("Log folder does not exist: {Path}", logPath);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to open log folder");
            }
        }
        private async Task LoadAvailablePipelinesAsync()
        {
            try
            {
                AvailablePipelines.Clear();
                PipelineSelections.Clear();
                _pipelineNameMapping.Clear();

                // Always add Service (Global) log
                AvailablePipelines.Add("Service (Global)");
                PipelineSelections.Add(new PipelineSelection
                {
                    Name = "Service (Global)",
                    SanitizedName = "service",
                    IsSelected = true // Default selected
                });

                // Get configured pipelines
                var settings = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();
                if (settings?.Pipelines != null)
                {
                    foreach (var pipeline in settings.Pipelines)
                    {
                        var displayName = $"{pipeline.Name}";
                        var sanitizedName = SanitizeForFileName(pipeline.Name);

                        AvailablePipelines.Add(displayName);
                        _pipelineNameMapping[displayName] = sanitizedName;

                        PipelineSelections.Add(new PipelineSelection
                        {
                            Name = displayName,
                            SanitizedName = sanitizedName,
                            IsSelected = false
                        });
                    }
                }

                // Also check for existing log files that might not be in config
                var logPath = ConfigurationPaths.GetLogsDirectory();
                if (Directory.Exists(logPath))
                {
                    var pipelineLogFiles = Directory.GetFiles(logPath, "pipeline_*.log")
                        .Select(Path.GetFileNameWithoutExtension)
                        .Where(f => f != null && f.StartsWith("pipeline_"))
                        .Select(f => f!.Substring("pipeline_".Length))
                        .Distinct();

                    foreach (var logName in pipelineLogFiles)
                    {
                        if (!_pipelineNameMapping.Values.Contains(logName))
                        {
                            var displayName = $"{logName} (Archived)";
                            AvailablePipelines.Add(displayName);
                            _pipelineNameMapping[displayName] = logName;

                            PipelineSelections.Add(new PipelineSelection
                            {
                                Name = displayName,
                                SanitizedName = logName,
                                IsSelected = false
                            });
                        }
                    }
                }

                // Listen for selection changes
                foreach (var selection in PipelineSelections)
                {
                    selection.PropertyChanged += OnPipelineSelectionChanged;
                }

                // Update initial count
                OnPropertyChanged(nameof(SelectedPipelineCount));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to load available pipelines");
            }
        }

        private async Task RefreshLogsAsync()
        {
            try
            {
                IsLoading = true;

                // Get selected pipelines
                var selectedPipelines = PipelineSelections.Where(p => p.IsSelected).ToList();
                if (!selectedPipelines.Any())
                {
                    CombinedLogEntries.Clear();
                    CorrelationGroups.Clear();
                    CurrentLogFiles = "No pipelines selected";
                    return;
                }

                // Update current files display
                CurrentLogFiles = string.Join(", ", selectedPipelines.Select(p => p.Name));

                // Collect all log entries from selected pipelines
                var allEntries = new List<LogEntry>();

                foreach (var pipeline in selectedPipelines)
                {
                    var logFileName = GetLogFileName(pipeline.Name);
                    var logPath = Path.Combine(ConfigurationPaths.GetLogsDirectory(), logFileName);

                    if (File.Exists(logPath))
                    {
                        // Read entries from this pipeline
                        var entries = await ReadLogFileAsync(logPath, pipeline.Name);
                        allEntries.AddRange(entries);
                    }
                }

                // Sort all entries by timestamp (millisecond precision)
                var sortedEntries = allEntries
                    .OrderBy(e => e.Timestamp)
                    .TakeLast(MaxDisplayedEntries)
                    .ToList();

                // Update collection efficiently (minimize UI updates)
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    // For auto-scroll, append only new entries to prevent flicker
                    if (IsAutoScrollEnabled && CombinedLogEntries.Count > 0)
                    {
                        // Find the last timestamp we have
                        var lastTimestamp = CombinedLogEntries.Last().Timestamp;

                        // Add only newer entries
                        var newEntries = sortedEntries
                            .Where(e => e.Timestamp > lastTimestamp)
                            .ToList();

                        foreach (var entry in newEntries)
                        {
                            CombinedLogEntries.Add(entry);

                            // Maintain max entries
                            if (CombinedLogEntries.Count > MaxDisplayedEntries)
                                CombinedLogEntries.RemoveAt(0);
                        }
                    }
                    else
                    {
                        // Full refresh when not auto-scrolling
                        CombinedLogEntries.Clear();
                        foreach (var entry in sortedEntries)
                        {
                            CombinedLogEntries.Add(entry);
                        }
                    }
                });

                TotalLineCount = CombinedLogEntries.Count;
                LastUpdateTime = DateTime.Now;
                ApplyFilters();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to refresh logs");
            }
            finally
            {
                IsLoading = false;
            }
        }

        private async Task<List<LogEntry>> ReadLogFileAsync(string logPath, string sourcePipeline)
        {
            var entries = new List<LogEntry>();

            try
            {
                _logger.LogInformation("Reading log file: {Path} for pipeline: {Pipeline}", logPath, sourcePipeline);

                using (var fs = new FileStream(logPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var reader = new StreamReader(fs, Encoding.UTF8))
                {
                    string? line;
                    int lineCount = 0;
                    int parsedCount = 0;

                    while ((line = await reader.ReadLineAsync()) != null)
                    {
                        lineCount++;
                        var entry = ParseLogLine(line);
                        if (entry != null)
                        {
                            entry.Source = sourcePipeline; // Tag with source
                            entries.Add(entry);
                            parsedCount++;
                        }
                    }

                    _logger.LogInformation("Read {Lines} lines, parsed {Parsed} entries from {File}",
                        lineCount, parsedCount, Path.GetFileName(logPath));
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to read log file: {LogPath}", logPath);
            }

            return entries;
        }

        private LogEntry? ParseLogLine(string line)
        {
            if (string.IsNullOrWhiteSpace(line))
                return null;

            try
            {
                // DEBUG output for first few lines
                if (TotalLineCount < 10)
                {
                    Console.WriteLine($"[DEBUG] Parsing line: {line}");
                }

                // Try the REAL format from actual logs!
                // Format: [HH:mm:ss LEVEL] [CorrelationId] ["Stage"] Message [Duplicate]
                // Example: [23:56:28 INF] [F23562879-R0010168] ["FileDetected"] Processing file: R0010168.JPG [Processing file: R0010168.JPG]
                var realLogFormatMatch = Regex.Match(line,
                    @"^\[(\d{2}:\d{2}:\d{2})\s+(\w+)\]\s+\[([^\]]+)\]\s+\[""([^""]+)""\]\s+([^[]+)(?:\[.*\])?");

                if (realLogFormatMatch.Success)
                {
                    var timeStr = realLogFormatMatch.Groups[1].Value;
                    var levelStr = realLogFormatMatch.Groups[2].Value;
                    var correlationId = realLogFormatMatch.Groups[3].Value;
                    var stageStr = realLogFormatMatch.Groups[4].Value;
                    var message = realLogFormatMatch.Groups[5].Value.Trim();

                    // Parse timestamp (add today's date)
                    var timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss", CultureInfo.InvariantCulture);
                    timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

                    // Parse log level
                    var level = ParseLogLevel(levelStr);

                    // Parse stage
                    ProcessingStage? stage = null;
                    if (Enum.TryParse<ProcessingStage>(stageStr, true, out var parsedStage))
                    {
                        stage = parsedStage;
                    }

                    // Extract pipeline name if present at end of message
                    string? pipeline = null;
                    var pipelineMatch = Regex.Match(message, @"\[([^\]]+)\]\s*$");
                    if (pipelineMatch.Success)
                    {
                        pipeline = pipelineMatch.Groups[1].Value;
                        message = message.Substring(0, message.Length - pipelineMatch.Value.Length).Trim();
                    }

                    // Extract duration if present
                    int? durationMs = null;
                    var durationMatch = Regex.Match(message, @"\[(\d+)ms\]");
                    if (durationMatch.Success)
                    {
                        durationMs = int.Parse(durationMatch.Groups[1].Value);
                        message = message.Replace(durationMatch.Value, "").Trim();
                    }

                    // DEBUG output
                    if (TotalLineCount < 10)
                    {
                        Console.WriteLine($"[DEBUG] MATCHED REAL FORMAT: CorrelationId={correlationId}, Stage={stage}, Pipeline={pipeline}");
                    }

                    return new LogEntry
                    {
                        Timestamp = timestamp,
                        Level = level,
                        Message = message,
                        RawLine = line,
                        CorrelationId = correlationId,
                        Stage = stage,
                        Pipeline = pipeline,
                        DurationMs = durationMs
                    };
                }

                // First try the ACTUAL format from the logs
                // Example: [F00044243-R0010168] ["ExifExtraction"] Extracting EXIF metadata [Extracting EXIF metadata]
                // Note: Last part in brackets might be duplicated message - ignore it
                var actualFormatMatch = Regex.Match(line,
                    @"^\[([^\]]+)\]\s+\[""?([^\]""]+)""?\]\s+([^[]+)(?:\[.*\])?$");

                if (actualFormatMatch.Success)
                {
                    var correlationId = actualFormatMatch.Groups[1].Value;
                    var stageStr = actualFormatMatch.Groups[2].Value;
                    var message = actualFormatMatch.Groups[3].Value.Trim();

                    // Check if this is a real correlation ID (starts with letter + numbers)
                    if (Regex.IsMatch(correlationId, @"^[A-Z]\d{8,}"))
                    {
                        // Use current time since no timestamp in this format
                        var timestamp = DateTime.Now;

                        // Parse stage
                        ProcessingStage? stage = null;
                        if (Enum.TryParse<ProcessingStage>(stageStr, true, out var parsedStage))
                        {
                            stage = parsedStage;
                        }

                        // Determine log level from content
                        var level = DetermineLogLevel(stage, message);

                        // Extract pipeline name if present
                        string? pipeline = null;
                        var pipelineMatch = Regex.Match(message, @"\[([^\]]+)\]$");
                        if (pipelineMatch.Success)
                        {
                            pipeline = pipelineMatch.Groups[1].Value;
                            message = message.Substring(0, message.Length - pipelineMatch.Value.Length).Trim();
                        }

                        // DEBUG output
                        if (TotalLineCount < 10)
                        {
                            Console.WriteLine($"[DEBUG] Parsed NEW FORMAT: CorrelationId={correlationId}, Stage={stage}, Pipeline={pipeline}");
                        }

                        return new LogEntry
                        {
                            Timestamp = timestamp,
                            Level = level,
                            Message = message,
                            RawLine = line,
                            CorrelationId = correlationId,
                            Stage = stage,
                            Pipeline = pipeline
                        };
                    }
                }

                // ALSO try the timestamp format we expected
                // Example: 23:01:37.000 INF [F23013594-R0010168] ["ExifExtraction"] Extracting EXIF metadata completed
                var timestampFormatMatch = Regex.Match(line,
                    @"^(\d{2}:\d{2}:\d{2}\.\d{3})\s+(\w+)\s+\[([^\]]+)\]\s+\[""?([^\]""]+)""?\]\s+(.+)$");

                if (timestampFormatMatch.Success)
                {
                    var timeStr = timestampFormatMatch.Groups[1].Value;
                    var levelStr = timestampFormatMatch.Groups[2].Value;
                    var correlationId = timestampFormatMatch.Groups[3].Value;
                    var stageStr = timestampFormatMatch.Groups[4].Value;
                    var message = timestampFormatMatch.Groups[5].Value;

                    // Parse timestamp (add today's date)
                    var timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss.fff", CultureInfo.InvariantCulture);
                    timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

                    // Parse log level
                    var level = ParseLogLevel(levelStr);

                    // Parse stage
                    ProcessingStage? stage = null;
                    if (Enum.TryParse<ProcessingStage>(stageStr, true, out var parsedStage))
                    {
                        stage = parsedStage;
                    }

                    // Extract pipeline name from message if present
                    string? pipeline = null;
                    var pipelineMatch = Regex.Match(message, @"\[([\w\s]+)\]$");
                    if (pipelineMatch.Success)
                    {
                        pipeline = pipelineMatch.Groups[1].Value;
                        message = message.Substring(0, message.Length - pipelineMatch.Value.Length).Trim();
                    }

                    // Extract duration if present
                    int? durationMs = null;
                    var durationMatch = Regex.Match(message, @"\[(\d+)ms\]");
                    if (durationMatch.Success)
                    {
                        durationMs = int.Parse(durationMatch.Groups[1].Value);
                        message = message.Replace(durationMatch.Value, "").Trim();
                    }

                    return new LogEntry
                    {
                        Timestamp = timestamp,
                        Level = level,
                        Message = message,
                        RawLine = line,
                        CorrelationId = correlationId,
                        Stage = stage,
                        Pipeline = pipeline,
                        DurationMs = durationMs
                    };
                }

                // Try simpler correlation format without stage
                // Example: 23:01:37.000 DBG [F23013594-R0010168] Found barcode data in Barcode field
                var simpleCorrelationMatch = Regex.Match(line,
                    @"^(\d{2}:\d{2}:\d{2}\.\d{3})\s+(\w+)\s+\[([^\]]+)\]\s+(.+)$");

                if (simpleCorrelationMatch.Success)
                {
                    var timeStr = simpleCorrelationMatch.Groups[1].Value;
                    var levelStr = simpleCorrelationMatch.Groups[2].Value;
                    var correlationIdOrMessage = simpleCorrelationMatch.Groups[3].Value;
                    var remainingMessage = simpleCorrelationMatch.Groups[4].Value;

                    // Check if this looks like a correlation ID (starts with F followed by digits)
                    if (Regex.IsMatch(correlationIdOrMessage, @"^F\d{8,}"))
                    {
                        var timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss.fff", CultureInfo.InvariantCulture);
                        timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

                        return new LogEntry
                        {
                            Timestamp = timestamp,
                            Level = ParseLogLevel(levelStr),
                            Message = remainingMessage,
                            RawLine = line,
                            CorrelationId = correlationIdOrMessage
                        };
                    }
                }

                // Fallback to standard Serilog format WITHOUT correlation
                // Example: [14:23:45 INF] Pipeline Radiology started
                var standardMatch = Regex.Match(line, @"^\[?(\d{2}:\d{2}:\d{2}(?:\.\d{3})?)\s+(\w+)\]?\s+(.+)$");

                if (standardMatch.Success)
                {
                    var timeStr = standardMatch.Groups[1].Value;
                    var levelStr = standardMatch.Groups[2].Value;
                    var message = standardMatch.Groups[3].Value;

                    // Parse timestamp
                    DateTime timestamp;
                    if (timeStr.Contains('.'))
                    {
                        timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss.fff", CultureInfo.InvariantCulture);
                    }
                    else
                    {
                        timestamp = DateTime.ParseExact(timeStr, "HH:mm:ss", CultureInfo.InvariantCulture);
                    }

                    // Add today's date
                    timestamp = DateTime.Today.Add(timestamp.TimeOfDay);

                    var level = ParseLogLevel(levelStr);

                    return new LogEntry
                    {
                        Timestamp = timestamp,
                        Level = level,
                        Message = message,
                        RawLine = line
                    };
                }

                // Last resort - just treat as info message
                return new LogEntry
                {
                    Timestamp = DateTime.Now,
                    Level = LogLevel.Information,
                    Message = line,
                    RawLine = line
                };
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to parse log line: {Line}", line);
                // Return the line as-is
                return new LogEntry
                {
                    Timestamp = DateTime.Now,
                    Level = LogLevel.Information,
                    Message = line,
                    RawLine = line
                };
            }
        }

        private LogLevel DetermineLogLevel(ProcessingStage? stage, string message)
        {
            // Check stage first
            if (stage == ProcessingStage.Error)
                return LogLevel.Error;

            // Check message content
            var messageLower = message.ToLowerInvariant();
            if (messageLower.Contains("error") || messageLower.Contains("failed"))
                return LogLevel.Error;

            if (messageLower.Contains("warning") || messageLower.Contains("warn") || messageLower.Contains("slow"))
                return LogLevel.Warning;

            if (messageLower.Contains("debug"))
                return LogLevel.Debug;

            // Default to Information
            return LogLevel.Information;
        }

        private LogLevel ParseLogLevel(string levelStr)
        {
            return levelStr.ToUpperInvariant() switch
            {
                "DBG" or "DEB" or "DEBUG" => LogLevel.Debug,
                "INF" or "INFO" or "INFORMATION" => LogLevel.Information,
                "WRN" or "WARN" or "WARNING" => LogLevel.Warning,
                "ERR" or "ERROR" => LogLevel.Error,
                "CRT" or "CRIT" or "CRITICAL" or "FTL" or "FATAL" => LogLevel.Critical,
                _ => LogLevel.Information  // Default to Information instead of failing
            };
        }

        private void ClearLogs()
        {
            LogEntries.Clear();
            CombinedLogEntries.Clear();
            FilteredCombinedEntries.Clear();
            CorrelationGroups.Clear();
            TotalLineCount = 0;
            _filePositions.Clear();
        }

        private async Task ExportLogsAsync()
        {
            try
            {
                // Create export dialog
                var dialog = new Microsoft.Win32.SaveFileDialog
                {
                    Filter = "Log files (*.log)|*.log|Text files (*.txt)|*.txt|All files (*.*)|*.*",
                    DefaultExt = ".log",
                    FileName = $"CamBridge_Export_{DateTime.Now:yyyyMMdd_HHmmss}.log"
                };

                if (dialog.ShowDialog() == true)
                {
                    var sb = new StringBuilder();

                    if (IsTreeViewEnabled)
                    {
                        // Export tree structure
                        foreach (var group in CorrelationGroups)
                        {
                            sb.AppendLine($"=== Correlation: {group.CorrelationId} ===");
                            sb.AppendLine($"Pipeline: {group.Pipeline}");
                            sb.AppendLine($"Duration: {group.DurationText}");
                            sb.AppendLine($"Status: {group.Status}");
                            sb.AppendLine();

                            foreach (var stage in group.Stages)
                            {
                                sb.AppendLine($"  Stage: {stage.Stage} [{stage.DurationText}]");
                                foreach (var entry in stage.Entries)
                                {
                                    sb.AppendLine($"    {entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                                }
                                sb.AppendLine();
                            }

                            if (group.UngroupedEntries.Any())
                            {
                                sb.AppendLine("  [Ungrouped Entries]");
                                foreach (var entry in group.UngroupedEntries)
                                {
                                    sb.AppendLine($"    {entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} {entry.LevelText} {entry.Message}");
                                }
                                sb.AppendLine();
                            }

                            sb.AppendLine(new string('=', 50));
                            sb.AppendLine();
                        }
                    }
                    else
                    {
                        // Export flat list
                        var lines = FilteredCombinedEntries.Select(e => e.RawLine ??
                            $"{e.Timestamp:yyyy-MM-dd HH:mm:ss.fff} {e.LevelText} [{e.CorrelationId}] [{e.Stage}] {e.Message}");
                        foreach (var line in lines)
                        {
                            sb.AppendLine(line);
                        }
                    }

                    await File.WriteAllTextAsync(dialog.FileName, sb.ToString(), Encoding.UTF8);

                    _logger.LogInformation("Exported {Count} log entries to {FileName}",
                        IsTreeViewEnabled ? CorrelationGroups.Sum(g => g.TotalEntries) : FilteredCombinedEntries.Count,
                        dialog.FileName);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to export logs");
            }
        }

        private string GetLogFileName(string pipelineSelection)
        {
            var today = DateTime.Now.ToString("yyyyMMdd");

            if (pipelineSelection == "Service (Global)")
            {
                return $"service_{today}.log";
            }

            if (pipelineSelection == "All Pipelines (Legacy)")
            {
                return $"pipelines_{today}.log";
            }

            // Get sanitized name from mapping
            if (_pipelineNameMapping.TryGetValue(pipelineSelection, out var sanitizedName))
            {
                return $"pipeline_{sanitizedName}_{today}.log";
            }

            // Fallback - sanitize the selection directly
            var safeName = SanitizeForFileName(pipelineSelection.Replace(" (Archived)", ""));
            return $"pipeline_{safeName}_{today}.log";
        }

        private string SanitizeForFileName(string pipelineName)
        {
            // Replace invalid filename characters and common separators
            var invalid = Path.GetInvalidFileNameChars()
                .Concat(new[] { ' ', '.', ',', '/', '\\', ':', '-' })
                .Distinct()
                .ToArray();

            var sanitized = string.Join("_", pipelineName.Split(invalid, StringSplitOptions.RemoveEmptyEntries));

            // Limit length
            if (sanitized.Length > 100)
            {
                sanitized = sanitized.Substring(0, 97) + "...";
            }

            return sanitized;
        }

        private void OnRefreshTimer(object? state)
        {
            if (IsAutoScrollEnabled && !IsLoading)
            {
                _ = RefreshLogsAsync();
            }
        }

        private void OnPipelineSelectionChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(PipelineSelection.IsSelected))
            {
                // Update count
                OnPropertyChanged(nameof(SelectedPipelineCount));

                // Update current files display
                var selectedNames = PipelineSelections.Where(p => p.IsSelected).Select(p => p.Name).ToList();
                CurrentLogFiles = selectedNames.Any()
                    ? string.Join(", ", selectedNames)
                    : "No pipelines selected";

                // Refresh logs with new selection
                _ = RefreshLogsAsync();
            }
        }

        partial void OnSearchTextChanged(string? value)
        {
            // Debounce search to avoid too many updates
            ApplyFilters();
        }

        partial void OnShowDebugChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowInformationChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowWarningChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowErrorChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnShowCriticalChanged(bool value)
        {
            ApplyFilters();
            OnPropertyChanged(nameof(SelectedLevelCount));
        }

        partial void OnIsTreeViewEnabledChanged(bool value)
        {
            ApplyFilters();
        }

        partial void OnFilter1Changed(string value)
        {
            ApplyFilters();
        }

        partial void OnFilter2Changed(string value)
        {
            ApplyFilters();
        }

        partial void OnFilter3Changed(string value)
        {
            ApplyFilters();
        }
    }

    /// <summary>
    /// Enhanced log entry with correlation support
    /// </summary>
    public class LogEntry
    {
        public DateTime Timestamp { get; set; }
        public LogLevel Level { get; set; }
        public string Message { get; set; } = string.Empty;
        public string? RawLine { get; set; }
        public string Source { get; set; } = string.Empty; // Which log file this came from

        // Enhanced properties for correlation
        public string? CorrelationId { get; set; }
        public ProcessingStage? Stage { get; set; }
        public string? Pipeline { get; set; }
        public int? DurationMs { get; set; }

        // UI Helper Properties
        public string LevelText => Level switch
        {
            LogLevel.Debug => "DBG",
            LogLevel.Information => "INF",
            LogLevel.Warning => "WRN",
            LogLevel.Error => "ERR",
            LogLevel.Critical => "CRT",
            _ => "???"
        };

        public string LevelColor => Level switch
        {
            LogLevel.Debug => "#808080",      // Gray
            LogLevel.Information => "#0078D4", // Blue
            LogLevel.Warning => "#FFA500",     // Orange
            LogLevel.Error => "#FF0000",       // Red
            LogLevel.Critical => "#8B0000",    // Dark Red
            _ => "#000000"
        };

        // FIXED emoji icons!
        public string StageIcon => Stage switch
        {
            ProcessingStage.ServiceStartup => "ðŸš€",
            ProcessingStage.ConfigurationLoading => "âš™ï¸",
            ProcessingStage.PipelineInitialization => "ðŸ”§",
            ProcessingStage.ServiceShutdown => "ðŸ›‘",
            ProcessingStage.FileDetected => "ðŸ“„",
            ProcessingStage.ExifExtraction => "ðŸ“·",
            ProcessingStage.TagMapping => "ðŸ”„",
            ProcessingStage.DicomConversion => "ðŸ¥",
            ProcessingStage.PostProcessing => "ðŸ“‹",
            ProcessingStage.PacsUpload => "â˜ï¸",
            ProcessingStage.Complete => "âœ…",
            ProcessingStage.Error => "âŒ",
            ProcessingStage.PipelineShutdown => "ðŸ”´",
            ProcessingStage.PipelineRecovery => "ðŸ”§",
            ProcessingStage.WatcherError => "ðŸ‘ï¸",
            ProcessingStage.HealthCheck => "ðŸ’“",
            _ => "ðŸ“Œ"
        };

        public string FormattedDuration => DurationMs.HasValue ? $"{DurationMs}ms" : "";
    }

    /// <summary>
    /// Represents a group of log entries with the same correlation ID
    /// </summary>
    public class CorrelationGroup : ObservableObject
    {
        private bool _isExpanded;

        public string CorrelationId { get; set; } = string.Empty;
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public string Pipeline { get; set; } = string.Empty;
        public ProcessingStatus Status { get; set; }
        public ObservableCollection<StageGroup> Stages { get; } = new();
        public ObservableCollection<LogEntry> UngroupedEntries { get; } = new();

        public bool IsExpanded
        {
            get => _isExpanded;
            set => SetProperty(ref _isExpanded, value);
        }

        public TimeSpan Duration => EndTime - StartTime;
        public string DurationText => $"{Duration.TotalMilliseconds:0}ms";
        public int TotalEntries => Stages.Sum(s => s.Entries.Count) + UngroupedEntries.Count;

        // FIXED emoji icons!
        public string StatusIcon => Status switch
        {
            ProcessingStatus.Completed => "âœ…",
            ProcessingStatus.Failed => "âŒ",
            ProcessingStatus.InProgress => "â³",
            _ => "â“"
        };

        public string StatusColor => Status switch
        {
            ProcessingStatus.Completed => "#4CAF50",
            ProcessingStatus.Failed => "#F44336",
            ProcessingStatus.InProgress => "#FFA500",
            _ => "#808080"
        };
    }

    /// <summary>
    /// Represents a group of log entries for a specific processing stage
    /// </summary>
    public class StageGroup : ObservableObject
    {
        private bool _isExpanded;

        public ProcessingStage Stage { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public ObservableCollection<LogEntry> Entries { get; } = new();

        public bool IsExpanded
        {
            get => _isExpanded;
            set => SetProperty(ref _isExpanded, value);
        }

        public TimeSpan Duration => EndTime - StartTime;
        public string DurationText => $"{Duration.TotalMilliseconds:0}ms";

        public string StageIcon => Entries.FirstOrDefault()?.StageIcon ?? "ðŸ“Œ";
    }

    /// <summary>
    /// Processing status for correlation groups
    /// </summary>
    public enum ProcessingStatus
    {
        Unknown,
        InProgress,
        Completed,
        Failed
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\MainViewModel.cs
================================================================================

// src\CamBridge.Config\ViewModels\MainViewModel.cs
// Version: 0.6.8
// Description: Main view model with correct version
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

namespace CamBridge.Config.ViewModels
{
    public class MainViewModel : ViewModelBase
    {
        public string Title => "CamBridge Configuration v0.6.8";
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\MappingEditorViewModel.cs
================================================================================

// src/CamBridge.Config/ViewModels/MappingEditorViewModel.cs
// Version: 0.7.26
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Modified: 2025-06-18
// Status: Development/Local - Transform Editor Enhanced

using CamBridge.Config.Dialogs;
using CamBridge.Config.Extensions;
using CamBridge.Config.Services;
using CamBridge.Core;
using CamBridge.Core.Interfaces;
using CamBridge.Core.ValueObjects;
using CamBridge.Infrastructure.Services;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Win32;
using ModernWpf.Controls;
using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

// Alias to avoid ambiguity with FellowOakDicom.DicomTag
using DicomTag = CamBridge.Core.ValueObjects.DicomTag;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// ViewModel for the mapping editor with multiple mapping sets support
    /// </summary>
    public partial class MappingEditorViewModel : ViewModelBase
    {
        private readonly ILogger<MappingEditorViewModel> _logger;
        private readonly IConfigurationService _configurationService;
        private IMappingConfiguration? _mappingConfiguration;
        private bool _isInitialized = false;

        #region Properties

        // Mapping Sets
        [ObservableProperty] private ObservableCollection<MappingSet> _mappingSets = new();
        [ObservableProperty] private MappingSet? _selectedMappingSet;
        [ObservableProperty] private bool _canEditCurrentSet = true;

        // Mapping Rules
        [ObservableProperty] private ObservableCollection<MappingRuleViewModel> _mappingRules = new();
        [ObservableProperty] private MappingRuleViewModel? _selectedRule;

        // Preview
        [ObservableProperty] private string? _previewInput;
        [ObservableProperty] private string? _previewOutput;

        // State
        [ObservableProperty] private bool _isModified;
        [ObservableProperty] private string? _statusMessage;
        [ObservableProperty] private bool _isLoading;
        [ObservableProperty] private bool _isError;

        // Save feedback
        [ObservableProperty] private bool _showSaveSuccess;
        private System.Windows.Threading.DispatcherTimer? _saveSuccessTimer;

        // Available source fields
        public ObservableCollection<SourceFieldInfo> QRBridgeFields { get; } = new();
        public ObservableCollection<SourceFieldInfo> ExifFields { get; } = new();

        #endregion

        public MappingEditorViewModel(
            ILogger<MappingEditorViewModel> logger,
            IConfigurationService configurationService)
        {
            _logger = logger;
            _configurationService = configurationService;

            InitializeSourceFields();
            StatusMessage = "Ready";
        }

        /// <summary>
        /// Initialize the ViewModel - call this from the View's Loaded event
        /// </summary>
        public async Task InitializeAsync()
        {
            if (_isInitialized) return;

            try
            {
                IsLoading = true;
                StatusMessage = "Initializing mapping editor...";

                // Create MappingConfigurationLoader with proper logger
                var nullLoggerFactory = new NullLoggerFactory();
                var mappingLoaderLogger = nullLoggerFactory.CreateLogger<MappingConfigurationLoader>();
                _mappingConfiguration = new MappingConfigurationLoader(mappingLoaderLogger);

                // Load mapping sets
                await LoadMappingSetsAsync();

                _isInitialized = true;
                StatusMessage = "Mapping editor ready";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to initialize mapping editor");
                StatusMessage = "Initialization failed";
                MessageBox.Show(
                    $"Failed to initialize mapping editor:\n{ex.Message}",
                    "Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        #region Initialization

        private void InitializeSourceFields()
        {
            // QRBridge fields (from QR code data)
            QRBridgeFields.Add(new SourceFieldInfo("examid", "Examination ID", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("name", "Patient Name", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("birthdate", "Birth Date", "date"));
            QRBridgeFields.Add(new SourceFieldInfo("gender", "Gender", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("comment", "Comment", "string"));
            QRBridgeFields.Add(new SourceFieldInfo("patientid", "Patient ID", "string"));

            // EXIF fields (from image metadata)
            ExifFields.Add(new SourceFieldInfo("Make", "Camera Manufacturer", "string"));
            ExifFields.Add(new SourceFieldInfo("Model", "Camera Model", "string"));
            ExifFields.Add(new SourceFieldInfo("DateTimeOriginal", "Capture Date/Time", "datetime"));
            ExifFields.Add(new SourceFieldInfo("Software", "Software Version", "string"));
            ExifFields.Add(new SourceFieldInfo("ImageDescription", "Image Description", "string"));
        }

        private async Task LoadMappingSetsAsync()
        {
            try
            {
                IsLoading = true;
                IsError = false;
                StatusMessage = "Loading mapping sets...";

                // IMMER zuerst System Defaults laden - sie sind die Basis!
                LoadSystemDefaults();
                _logger.LogInformation("Loaded system default mapping sets");

                // Try to load v2 settings
                var settingsV2 = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();

                if (settingsV2 != null && settingsV2.MappingSets.Count > 0)
                {
                    // Add user sets from v2 settings
                    foreach (var set in settingsV2.MappingSets.Where(s => !s.IsSystemDefault))
                    {
                        MappingSets.Add(set);
                    }
                    _logger.LogInformation($"Loaded {settingsV2.MappingSets.Count(s => !s.IsSystemDefault)} user mapping sets from settings");
                }

                // Debug: Log all loaded sets
                _logger.LogInformation($"Total mapping sets loaded: {MappingSets.Count}");
                foreach (var set in MappingSets)
                {
                    _logger.LogInformation($"  - {set.Name} (System: {set.IsSystemDefault}, Rules: {set.Rules?.Count ?? 0})");
                }

                // Select appropriate set - prefer Ricoh for initial experience
                var ricohSet = MappingSets.FirstOrDefault(s => s.Name.Contains("Ricoh", StringComparison.OrdinalIgnoreCase));
                SelectedMappingSet = ricohSet ?? MappingSets.FirstOrDefault();

                StatusMessage = $"Loaded {MappingSets.Count} mapping sets";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error loading mapping sets");
                StatusMessage = "Failed to load mapping sets";
                IsError = true;

                // Even on error, ensure system defaults are available
                if (MappingSets.Count == 0)
                {
                    LoadSystemDefaults();
                }
                SelectedMappingSet = MappingSets.FirstOrDefault();
            }
            finally
            {
                IsLoading = false;
            }
        }

        private void LoadSystemDefaults()
        {
            // Ricoh G900 Standard Set
            var ricohSet = new MappingSet
            {
                Id = Guid.Parse("00000000-0000-0000-0000-000000000001"),
                Name = "[System] Ricoh G900 Standard",
                Description = "Standard mapping for Ricoh G900 II cameras",
                IsSystemDefault = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                Rules = new List<MappingRule>
                {
                    // Patient identification
                    new() { SourceField = "name", DicomTag = "(0010,0010)", Description = "Patient Name",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "patientid", DicomTag = "(0010,0020)", Description = "Patient ID",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "birthdate", DicomTag = "(0010,0030)", Description = "Patient Birth Date",
                            SourceType = "QRBridge", Transform = "DateToDicom" },
                    new() { SourceField = "gender", DicomTag = "(0010,0040)", Description = "Patient Sex",
                            SourceType = "QRBridge", Transform = "MapGender" },
                    
                    // Study information
                    new() { SourceField = "examid", DicomTag = "(0020,0010)", Description = "Study ID",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "comment", DicomTag = "(0008,1030)", Description = "Study Description",
                            SourceType = "QRBridge", Transform = "None" },
                    
                    // Image date/time from EXIF
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0020)", Description = "Study Date",
                            SourceType = "EXIF", Transform = "ExtractDate" },
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0030)", Description = "Study Time",
                            SourceType = "EXIF", Transform = "ExtractTime" },
                    
                    // Equipment info
                    new() { SourceField = "Make", DicomTag = "(0008,0070)", Description = "Manufacturer",
                            SourceType = "EXIF", Transform = "None" },
                    new() { SourceField = "Model", DicomTag = "(0008,1090)", Description = "Manufacturer Model Name",
                            SourceType = "EXIF", Transform = "None" }
                }
            };

            // Minimal Required Set
            var minimalSet = new MappingSet
            {
                Id = Guid.Parse("00000000-0000-0000-0000-000000000002"),
                Name = "[System] Minimal Required",
                Description = "Only the required DICOM fields",
                IsSystemDefault = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                Rules = new List<MappingRule>
                {
                    new() { SourceField = "name", DicomTag = "(0010,0010)", Description = "Patient Name",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "patientid", DicomTag = "(0010,0020)", Description = "Patient ID",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "examid", DicomTag = "(0020,0010)", Description = "Study ID",
                            SourceType = "QRBridge", Transform = "None" }
                }
            };

            // Full Comprehensive Set
            var fullSet = new MappingSet
            {
                Id = Guid.Parse("00000000-0000-0000-0000-000000000003"),
                Name = "[System] Full Comprehensive",
                Description = "Comprehensive mapping with all standard fields",
                IsSystemDefault = true,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                Rules = new List<MappingRule>
                {
                    // Patient Module
                    new() { SourceField = "name", DicomTag = "(0010,0010)", Description = "Patient Name",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "patientid", DicomTag = "(0010,0020)", Description = "Patient ID",
                            SourceType = "QRBridge", Transform = "None", Required = true },
                    new() { SourceField = "birthdate", DicomTag = "(0010,0030)", Description = "Patient Birth Date",
                            SourceType = "QRBridge", Transform = "DateToDicom" },
                    new() { SourceField = "gender", DicomTag = "(0010,0040)", Description = "Patient Sex",
                            SourceType = "QRBridge", Transform = "MapGender" },
                    new() { SourceField = "comment", DicomTag = "(0010,4000)", Description = "Patient Comments",
                            SourceType = "QRBridge", Transform = "None" },
                    
                    // Study Module
                    new() { SourceField = "examid", DicomTag = "(0020,0010)", Description = "Study ID",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "examid", DicomTag = "(0008,0050)", Description = "Accession Number",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "comment", DicomTag = "(0008,1030)", Description = "Study Description",
                            SourceType = "QRBridge", Transform = "None" },
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0020)", Description = "Study Date",
                            SourceType = "EXIF", Transform = "ExtractDate" },
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,0030)", Description = "Study Time",
                            SourceType = "EXIF", Transform = "ExtractTime" },
                    
                    // Equipment Module
                    new() { SourceField = "Make", DicomTag = "(0008,0070)", Description = "Manufacturer",
                            SourceType = "EXIF", Transform = "None" },
                    new() { SourceField = "Model", DicomTag = "(0008,1090)", Description = "Manufacturer Model Name",
                            SourceType = "EXIF", Transform = "None" },
                    new() { SourceField = "Software", DicomTag = "(0018,1020)", Description = "Software Versions",
                            SourceType = "EXIF", Transform = "None" },
                    
                    // Image Module
                    new() { SourceField = "DateTimeOriginal", DicomTag = "(0008,002A)", Description = "Acquisition DateTime",
                            SourceType = "EXIF", Transform = "DateTimeToDicom" }
                }
            };

            MappingSets.Add(ricohSet);
            MappingSets.Add(minimalSet);
            MappingSets.Add(fullSet);
        }

        private MappingRuleViewModel CreateRuleViewModel(MappingRule rule)
        {
            var vm = new MappingRuleViewModel(rule);

            // Attach property changed handler
            vm.PropertyChanged += (s, e) =>
            {
                // Avoid recursive updates
                if (!IsLoading)
                {
                    IsModified = true;
                    if (s == SelectedRule && e.PropertyName != nameof(MappingRuleViewModel.DisplayName))
                    {
                        UpdatePreview();
                    }
                }
            };

            return vm;
        }

        #endregion

        #region Mapping Set Commands

        [RelayCommand]
        private async Task AddMappingSetAsync()
        {
            var newSet = new MappingSet
            {
                Name = $"New Mapping Set {DateTime.Now:HHmmss}",
                Description = "Custom mapping configuration",
                Rules = new List<MappingRule>(),
                IsSystemDefault = false,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            MappingSets.Add(newSet);
            SelectedMappingSet = newSet;
            IsModified = true;
            StatusMessage = $"Created new mapping set: {newSet.Name}";
        }

        [RelayCommand(CanExecute = nameof(CanDuplicateMappingSet))]
        private async Task DuplicateMappingSetAsync()
        {
            if (SelectedMappingSet == null) return;

            var duplicate = new MappingSet
            {
                Name = $"{SelectedMappingSet.Name} (Copy)",
                Description = SelectedMappingSet.Description,
                Rules = SelectedMappingSet.Rules.Select(r => new MappingRule
                {
                    SourceField = r.SourceField,
                    DicomTag = r.DicomTag,
                    Description = r.Description,
                    SourceType = r.SourceType,
                    Transform = r.Transform,
                    Required = r.Required,
                    DefaultValue = r.DefaultValue
                }).ToList(),
                IsSystemDefault = false,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            MappingSets.Add(duplicate);
            SelectedMappingSet = duplicate;
            IsModified = true;
            StatusMessage = $"Duplicated mapping set: {duplicate.Name}";
        }

        private bool CanDuplicateMappingSet() => SelectedMappingSet != null;

        [RelayCommand(CanExecute = nameof(CanDeleteMappingSet))]
        private async Task DeleteMappingSetAsync()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            var result = MessageBox.Show(
                $"Delete mapping set '{SelectedMappingSet.Name}'?\n\nThis action cannot be undone.",
                "Confirm Delete",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question);

            if (result == MessageBoxResult.Yes)
            {
                var setName = SelectedMappingSet.Name;
                MappingSets.Remove(SelectedMappingSet);
                SelectedMappingSet = MappingSets.FirstOrDefault();
                IsModified = true;
                StatusMessage = $"Deleted mapping set: {setName}";
            }
        }

        private bool CanDeleteMappingSet() => SelectedMappingSet != null && !SelectedMappingSet.IsSystemDefault;

        #endregion

        #region Rule Commands

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void AddRule()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            var newRule = new MappingRule
            {
                SourceField = "Select a field...",
                DicomTag = "(0010,0010)",
                Description = "New Mapping Rule",
                SourceType = "QRBridge",
                Transform = ValueTransform.None.ToString(),
                Required = false
            };

            var vm = CreateRuleViewModel(newRule);
            MappingRules.Add(vm);
            SelectedRule = vm;

            // Update the set's rules
            SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
            SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

            IsModified = true;
            StatusMessage = "Added new mapping rule - drag a source field to configure";
        }

        [RelayCommand]
        private void RemoveRule(MappingRuleViewModel? rule)
        {
            if (rule != null && SelectedMappingSet != null && !SelectedMappingSet.IsSystemDefault)
            {
                MappingRules.Remove(rule);

                // Update the set's rules
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                SelectedRule = MappingRules.FirstOrDefault();
                StatusMessage = "Removed mapping rule";
            }
        }

        [RelayCommand(CanExecute = nameof(CanMoveRuleUp))]
        private void MoveRuleUp()
        {
            if (SelectedRule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var index = MappingRules.IndexOf(SelectedRule);
            if (index > 0)
            {
                MappingRules.Move(index, index - 1);

                // Update the set's rules
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
            }
        }

        private bool CanMoveRuleUp() => SelectedRule != null && CanEditCurrentSet && MappingRules.IndexOf(SelectedRule) > 0;

        [RelayCommand(CanExecute = nameof(CanMoveRuleDown))]
        private void MoveRuleDown()
        {
            if (SelectedRule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var index = MappingRules.IndexOf(SelectedRule);
            if (index < MappingRules.Count - 1)
            {
                MappingRules.Move(index, index + 1);

                // Update the set's rules
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
            }
        }

        private bool CanMoveRuleDown() => SelectedRule != null && CanEditCurrentSet && MappingRules.IndexOf(SelectedRule) < MappingRules.Count - 1;

        #endregion

        #region Transform Edit Command

        [RelayCommand(CanExecute = nameof(CanEditTransform))]
        private async void EditTransform(MappingRuleViewModel? rule)
        {
            if (rule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var dialog = new TransformEditorDialog();

            dialog.SetMapping(rule.SourceField, rule.DicomTagString, rule.Transform);

            var result = await dialog.ShowAsync();
            if (result == ContentDialogResult.Primary)
            {
                // Update the transform
                rule.Transform = dialog.SelectedTransform;

                // Update the set
                if (SelectedMappingSet != null)
                {
                    SelectedMappingSet.UpdatedAt = DateTime.UtcNow;
                    IsModified = true;
                }

                StatusMessage = $"Transform updated for {rule.SourceField}";
            }
        }

        private bool CanEditTransform(MappingRuleViewModel? rule) => rule != null && CanEditCurrentSet;

        #endregion

        #region Save/Load Commands

        [RelayCommand]
        private async Task SaveMappingsAsync()
        {
            try
            {
                IsLoading = true;
                StatusMessage = "Saving mapping sets...";

                // Update rules in selected set if it's not read-only
                if (SelectedMappingSet != null && !SelectedMappingSet.IsSystemDefault)
                {
                    SelectedMappingSet.Rules = MappingRules.Select(vm => vm.ToMappingRule()).ToList();
                    SelectedMappingSet.UpdatedAt = DateTime.UtcNow;
                }

                // Load current v2 settings or create new
                var settingsV2 = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>()
                                 ?? new CamBridgeSettingsV2();

                // Update mapping sets - nur User Sets speichern!
                settingsV2.MappingSets = MappingSets.Where(s => !s.IsSystemDefault).ToList();

                // Save
                await _configurationService.SaveConfigurationAsync(settingsV2);

                IsModified = false;
                StatusMessage = "Mapping sets saved successfully";

                // Show save success feedback
                ShowSaveSuccess = true;

                // Hide after 3 seconds
                if (_saveSuccessTimer == null)
                {
                    _saveSuccessTimer = new System.Windows.Threading.DispatcherTimer
                    {
                        Interval = TimeSpan.FromSeconds(3)
                    };
                    _saveSuccessTimer.Tick += (s, e) =>
                    {
                        ShowSaveSuccess = false;
                        _saveSuccessTimer.Stop();
                    };
                }
                _saveSuccessTimer.Start();

                _logger.LogInformation($"Saved {settingsV2.MappingSets.Count} user mapping sets");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to save mapping sets");
                StatusMessage = "Failed to save mapping sets";
                MessageBox.Show($"Error saving mapping sets: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task ImportMappingsAsync()
        {
            try
            {
                var dialog = new OpenFileDialog
                {
                    Title = "Import Mapping Configuration",
                    Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                    DefaultExt = ".json"
                };

                if (dialog.ShowDialog() == true)
                {
                    IsLoading = true;
                    StatusMessage = "Importing mappings...";

                    // Read file content
                    var jsonContent = await File.ReadAllTextAsync(dialog.FileName);

                    // Try to deserialize as array of MappingRule
                    var rules = System.Text.Json.JsonSerializer.Deserialize<List<MappingRule>>(jsonContent);

                    if (rules != null && rules.Count > 0)
                    {
                        // Create new set from imported rules
                        var importedSet = new MappingSet
                        {
                            Name = $"Imported from {Path.GetFileName(dialog.FileName)}",
                            Description = $"Imported on {DateTime.Now:yyyy-MM-dd HH:mm}",
                            Rules = rules,
                            IsSystemDefault = false,
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow
                        };

                        MappingSets.Add(importedSet);
                        SelectedMappingSet = importedSet;
                        IsModified = true;
                        StatusMessage = $"Imported {rules.Count} mapping rules";

                        MessageBox.Show($"Successfully imported {rules.Count} mapping rules.", "Import Successful",
                            MessageBoxButton.OK, MessageBoxImage.Information);
                    }
                    else
                    {
                        StatusMessage = "No mapping rules found in file";
                        MessageBox.Show("No valid mapping rules found in the selected file.", "Import Failed",
                            MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to import mappings");
                MessageBox.Show($"Error importing mappings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanExportMappings))]
        private async Task ExportMappingsAsync()
        {
            if (SelectedMappingSet == null) return;

            try
            {
                var dialog = new SaveFileDialog
                {
                    Title = "Export Mapping Configuration",
                    Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                    DefaultExt = ".json",
                    FileName = $"{SelectedMappingSet.Name.Replace("[System]", "").Trim()}_{DateTime.Now:yyyyMMdd_HHmmss}.json"
                };

                if (dialog.ShowDialog() == true)
                {
                    IsLoading = true;
                    StatusMessage = "Exporting mappings...";

                    // Serialize rules to JSON
                    var jsonOptions = new System.Text.Json.JsonSerializerOptions
                    {
                        WriteIndented = true,
                        PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase
                    };

                    var json = System.Text.Json.JsonSerializer.Serialize(SelectedMappingSet.Rules, jsonOptions);
                    await File.WriteAllTextAsync(dialog.FileName, json);

                    StatusMessage = $"Exported {SelectedMappingSet.Rules.Count} rules to {Path.GetFileName(dialog.FileName)}";

                    MessageBox.Show($"Successfully exported {SelectedMappingSet.Rules.Count} mapping rules.", "Export Successful",
                        MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to export mappings");
                MessageBox.Show($"Error exporting mappings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        private bool CanExportMappings() => SelectedMappingSet != null;

        [RelayCommand]
        private async Task TestMappingAsync()
        {
            if (SelectedMappingSet == null)
            {
                MessageBox.Show("Please select a mapping set to test", "No Mapping Set",
                    MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                IsLoading = true;
                StatusMessage = "Testing mapping configuration...";

                // Create test data
                var testData = new System.Collections.Generic.Dictionary<string, string>
                {
                    { "examid", "TEST001" },
                    { "name", "Test, Patient" },
                    { "birthdate", "1990-01-15" },
                    { "gender", "M" },
                    { "comment", "Test mapping" },
                    { "patientid", "PAT001" },
                    { "Make", "RICOH" },
                    { "Model", "G900 II" },
                    { "DateTimeOriginal", DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss") },
                    { "Software", "CamBridge Test" }
                };

                var results = new System.Text.StringBuilder();
                results.AppendLine($"Testing Mapping Set: {SelectedMappingSet.Name}");
                results.AppendLine($"Rules: {SelectedMappingSet.Rules.Count}");
                results.AppendLine();

                int successCount = 0;
                int errorCount = 0;

                foreach (var rule in SelectedMappingSet.Rules)
                {
                    try
                    {
                        if (testData.TryGetValue(rule.SourceField, out var sourceValue))
                        {
                            var transformedValue = rule.ApplyTransform(sourceValue);
                            results.AppendLine($"âœ” {rule.SourceField} â†’ {rule.DicomTag}: '{transformedValue}'");
                            successCount++;
                        }
                        else
                        {
                            results.AppendLine($"âš  {rule.SourceField}: No test data available");
                        }
                    }
                    catch (Exception ex)
                    {
                        results.AppendLine($"âœ— {rule.SourceField}: Error - {ex.Message}");
                        errorCount++;
                    }
                }

                results.AppendLine();
                results.AppendLine($"Summary: {successCount} successful, {errorCount} errors");

                // Show results
                MessageBox.Show(results.ToString(), "Mapping Test Results",
                    MessageBoxButton.OK,
                    errorCount > 0 ? MessageBoxImage.Warning : MessageBoxImage.Information);

                StatusMessage = $"Test completed: {successCount} successful, {errorCount} errors";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to test mappings");
                MessageBox.Show($"Error testing mappings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanBrowseDicomTags))]
        private void BrowseDicomTags()
        {
            if (SelectedRule == null || SelectedMappingSet?.IsSystemDefault == true) return;

            var dialog = new DicomTagBrowserDialog
            {
                Owner = Application.Current.MainWindow
            };

            if (dialog.ShowDialog() == true && dialog.SelectedTag != null)
            {
                // Convert DicomTag object to string format
                SelectedRule.DicomTagString = dialog.SelectedTag.ToString();
                UpdatePreview();

                // Update the set
                if (SelectedMappingSet != null)
                {
                    SelectedMappingSet.UpdatedAt = DateTime.UtcNow;
                    IsModified = true;
                }
            }
        }

        private bool CanBrowseDicomTags() => SelectedRule != null && CanEditCurrentSet;

        #endregion

        #region Template Commands

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void ApplyRicohTemplate()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            if (MessageBox.Show(
                "This will replace all current mappings with the Ricoh G900 II template. Continue?",
                "Apply Template",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question) != MessageBoxResult.Yes)
            {
                return;
            }

            // Find the Ricoh system template
            var ricohTemplate = MappingSets.FirstOrDefault(s => s.Name.Contains("Ricoh") && s.IsSystemDefault);
            if (ricohTemplate != null)
            {
                MappingRules.Clear();
                foreach (var rule in ricohTemplate.Rules)
                {
                    // Create copies of the rules
                    var newRule = new MappingRule
                    {
                        SourceField = rule.SourceField,
                        DicomTag = rule.DicomTag,
                        Description = rule.Description,
                        SourceType = rule.SourceType,
                        Transform = rule.Transform,
                        Required = rule.Required,
                        DefaultValue = rule.DefaultValue
                    };
                    var vm = CreateRuleViewModel(newRule);
                    MappingRules.Add(vm);
                }

                // Update the set
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                StatusMessage = "Ricoh template applied";
            }
        }

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void ApplyMinimalTemplate()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            if (MessageBox.Show(
                "This will replace all current mappings with a minimal template. Continue?",
                "Apply Template",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question) != MessageBoxResult.Yes)
            {
                return;
            }

            // Find the minimal system template
            var minimalTemplate = MappingSets.FirstOrDefault(s => s.Name.Contains("Minimal") && s.IsSystemDefault);
            if (minimalTemplate != null)
            {
                MappingRules.Clear();
                foreach (var rule in minimalTemplate.Rules)
                {
                    // Create copies of the rules
                    var newRule = new MappingRule
                    {
                        SourceField = rule.SourceField,
                        DicomTag = rule.DicomTag,
                        Description = rule.Description,
                        SourceType = rule.SourceType,
                        Transform = rule.Transform,
                        Required = rule.Required,
                        DefaultValue = rule.DefaultValue
                    };
                    var vm = CreateRuleViewModel(newRule);
                    MappingRules.Add(vm);
                }

                // Update the set
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                StatusMessage = "Minimal template applied";
            }
        }

        [RelayCommand(CanExecute = nameof(CanEditCurrentSet))]
        private void ApplyFullTemplate()
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            if (MessageBox.Show(
                "This will replace all current mappings with a comprehensive template. Continue?",
                "Apply Template",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question) != MessageBoxResult.Yes)
            {
                return;
            }

            // Find the full system template
            var fullTemplate = MappingSets.FirstOrDefault(s => s.Name.Contains("Full") && s.IsSystemDefault);
            if (fullTemplate != null)
            {
                MappingRules.Clear();
                foreach (var rule in fullTemplate.Rules)
                {
                    // Create copies of the rules
                    var newRule = new MappingRule
                    {
                        SourceField = rule.SourceField,
                        DicomTag = rule.DicomTag,
                        Description = rule.Description,
                        SourceType = rule.SourceType,
                        Transform = rule.Transform,
                        Required = rule.Required,
                        DefaultValue = rule.DefaultValue
                    };
                    var vm = CreateRuleViewModel(newRule);
                    MappingRules.Add(vm);
                }

                // Update the set
                SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
                SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

                IsModified = true;
                StatusMessage = "Full template applied";
            }
        }

        #endregion

        #region Drag & Drop Support

        /// <summary>
        /// Add a new rule from a dropped field
        /// </summary>
        public void AddRuleFromField(SourceFieldInfo fieldInfo)
        {
            if (SelectedMappingSet == null || SelectedMappingSet.IsSystemDefault) return;

            // Determine appropriate DICOM tag based on field
            string dicomTag = fieldInfo.FieldName switch
            {
                "name" => "(0010,0010)",          // Patient Name
                "patientid" => "(0010,0020)",     // Patient ID
                "birthdate" => "(0010,0030)",     // Patient Birth Date
                "gender" => "(0010,0040)",        // Patient Sex
                "examid" => "(0020,0010)",        // Study ID
                "comment" => "(0008,1030)",       // Study Description
                "Make" => "(0008,0070)",          // Manufacturer
                "Model" => "(0008,1090)",         // Model Name
                "DateTimeOriginal" => "(0008,0020)", // Study Date
                "Software" => "(0018,1020)",      // Software Version
                _ => "(0010,0010)"                // Default to Patient Name
            };

            // Determine transform based on field type
            ValueTransform transform = fieldInfo.FieldName switch
            {
                "birthdate" => ValueTransform.DateToDicom,
                "gender" => ValueTransform.MapGender,
                "DateTimeOriginal" when dicomTag == "(0008,0020)" => ValueTransform.ExtractDate,
                "DateTimeOriginal" when dicomTag == "(0008,0030)" => ValueTransform.ExtractTime,
                _ => ValueTransform.None
            };

            var newRule = new MappingRule
            {
                SourceField = fieldInfo.FieldName,
                DicomTag = dicomTag,
                Description = fieldInfo.DisplayName,
                SourceType = QRBridgeFields.Contains(fieldInfo) ? "QRBridge" : "EXIF",
                Transform = transform.ToString(),
                Required = fieldInfo.FieldName == "name" || fieldInfo.FieldName == "patientid"
            };

            var vm = CreateRuleViewModel(newRule);
            MappingRules.Add(vm);
            SelectedRule = vm;

            // Update the set's rules
            SelectedMappingSet.Rules = MappingRules.Select(r => r.ToMappingRule()).ToList();
            SelectedMappingSet.UpdatedAt = DateTime.UtcNow;

            IsModified = true;
            StatusMessage = $"Added mapping for {fieldInfo.DisplayName}";
        }

        #endregion

        #region Preview

        public void UpdatePreview()
        {
            if (SelectedRule == null || string.IsNullOrWhiteSpace(PreviewInput))
            {
                PreviewOutput = string.Empty;
                return;
            }

            try
            {
                var rule = SelectedRule.ToMappingRule();
                PreviewOutput = rule.ApplyTransform(PreviewInput);
            }
            catch (Exception ex)
            {
                PreviewOutput = $"Error: {ex.Message}";
            }
        }

        partial void OnPreviewInputChanged(string? value)
        {
            UpdatePreview();
        }

        partial void OnSelectedRuleChanged(MappingRuleViewModel? value)
        {
            UpdatePreview();

            // Update command states
            BrowseDicomTagsCommand.NotifyCanExecuteChanged();
            MoveRuleUpCommand.NotifyCanExecuteChanged();
            MoveRuleDownCommand.NotifyCanExecuteChanged();
            EditTransformCommand.NotifyCanExecuteChanged();
        }

        partial void OnSelectedMappingSetChanged(MappingSet? value)
        {
            if (value == null) return;

            CanEditCurrentSet = !value.IsSystemDefault;
            LoadRulesFromSet(value);

            // Update command states
            DuplicateMappingSetCommand.NotifyCanExecuteChanged();
            DeleteMappingSetCommand.NotifyCanExecuteChanged();
            AddRuleCommand.NotifyCanExecuteChanged();
            MoveRuleUpCommand.NotifyCanExecuteChanged();
            MoveRuleDownCommand.NotifyCanExecuteChanged();
            BrowseDicomTagsCommand.NotifyCanExecuteChanged();
            ExportMappingsCommand.NotifyCanExecuteChanged();
            ApplyRicohTemplateCommand.NotifyCanExecuteChanged();
            ApplyMinimalTemplateCommand.NotifyCanExecuteChanged();
            ApplyFullTemplateCommand.NotifyCanExecuteChanged();
            EditTransformCommand.NotifyCanExecuteChanged();
        }

        private void LoadRulesFromSet(MappingSet set)
        {
            IsLoading = true;
            try
            {
                MappingRules.Clear();

                if (set.Rules != null)
                {
                    foreach (var rule in set.Rules)
                    {
                        var vm = CreateRuleViewModel(rule);
                        MappingRules.Add(vm);
                    }

                    StatusMessage = $"Loaded {set.Rules.Count} rules from '{set.Name}'";
                }
                else
                {
                    StatusMessage = $"Selected '{set.Name}' (no rules defined)";
                }
            }
            finally
            {
                IsLoading = false;
            }
        }

        #endregion

        #region Inner Classes

        public class SourceFieldInfo
        {
            public string FieldName { get; }
            public string DisplayName { get; }
            public string DataType { get; }

            public SourceFieldInfo(string fieldName, string displayName, string dataType)
            {
                FieldName = fieldName;
                DisplayName = displayName;
                DataType = dataType;
            }
        }

        #endregion
    }

    /// <summary>
    /// ViewModel wrapper for MappingRule
    /// </summary>
    public partial class MappingRuleViewModel : ObservableObject
    {
        private readonly MappingRule _rule;

        // UI-friendly properties that map to Core properties
        [ObservableProperty] private string _displayName;
        [ObservableProperty] private string _sourceType;
        [ObservableProperty] private string _sourceField;
        [ObservableProperty] private string _dicomTagString;
        [ObservableProperty] private ValueTransform _transform;
        [ObservableProperty] private bool _isRequired;
        [ObservableProperty] private string? _defaultValue;

        public MappingRuleViewModel(MappingRule rule)
        {
            _rule = rule;

            // Map Core properties to UI properties
            _displayName = rule.Description ?? $"{rule.SourceType}.{rule.SourceField}";
            _sourceType = rule.SourceType ?? "QRBridge";
            _sourceField = rule.SourceField;
            _dicomTagString = rule.DicomTag;
            _transform = Enum.TryParse<ValueTransform>(rule.Transform, out var t) ? t : ValueTransform.None;
            _isRequired = rule.Required;
            _defaultValue = rule.DefaultValue;
        }

        public MappingRule ToMappingRule()
        {
            // Update Core rule with UI values
            _rule.Description = DisplayName;
            _rule.SourceType = SourceType;
            _rule.SourceField = SourceField;
            _rule.DicomTag = DicomTagString;
            _rule.Transform = Transform.ToString();
            _rule.Required = IsRequired;
            _rule.DefaultValue = DefaultValue;

            return _rule;
        }

        partial void OnDicomTagStringChanged(string value)
        {
            // Validate DICOM tag format
            try
            {
                var tag = DicomTag.Parse(value);
                // Valid tag
            }
            catch
            {
                // Invalid tag format - could show error in UI
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\PacsConfigViewModel.cs
================================================================================

// src\CamBridge.Config\ViewModels\PacsConfigViewModel.cs
// Version: 0.8.5
// Description: PACS Configuration ViewModel - Extracted from PipelineConfigViewModel
// Session: 95 - The Great Refactoring!

using CamBridge.Core;
using CamBridge.Infrastructure.Services;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Diagnostics;
using System.Runtime.Versioning;
using System.Threading.Tasks;
using System.Windows;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Handles PACS upload configuration for a pipeline
    /// Extracted from PipelineConfigViewModel in Session 95
    /// </summary>
    [SupportedOSPlatform("windows")]
    public partial class PacsConfigViewModel : ViewModelBase
    {
        private readonly DicomStoreService? _dicomStoreService;
        private PacsConfiguration? _pacsConfiguration;

        // Test result properties (EXACT names from original!)
        [ObservableProperty]
        private string _pacsTestResult = string.Empty;

        [ObservableProperty]
        private string _pacsTestResultColor = "Black";

        [ObservableProperty]
        private bool _isTestingConnection;

        /// <summary>
        /// The PACS configuration being edited
        /// </summary>
        public PacsConfiguration? PacsConfiguration
        {
            get => _pacsConfiguration;
            set
            {
                if (_pacsConfiguration != null)
                {
                    _pacsConfiguration.PropertyChanged -= OnPacsConfigurationChanged;
                }

                if (SetProperty(ref _pacsConfiguration, value))
                {
                    if (_pacsConfiguration != null)
                    {
                        _pacsConfiguration.PropertyChanged += OnPacsConfigurationChanged;
                    }

                    // Notify all dependent properties
                    OnPropertyChanged(nameof(IsEnabled));
                    OnPropertyChanged(nameof(CanTestConnection));
                    TestPacsConnectionCommand.NotifyCanExecuteChanged();
                }
            }
        }

        /// <summary>
        /// Convenience property for binding
        /// </summary>
        public bool IsEnabled => PacsConfiguration?.Enabled ?? false;

        /// <summary>
        /// Can we test the connection?
        /// </summary>
        public bool CanTestConnection =>
            PacsConfiguration != null &&
            PacsConfiguration.Enabled &&
            !IsTestingConnection &&
            !string.IsNullOrWhiteSpace(PacsConfiguration.Host) &&
            !string.IsNullOrWhiteSpace(PacsConfiguration.CalledAeTitle);

        public PacsConfigViewModel()
        {
            // Design-time constructor
            Debug.WriteLine("PacsConfigViewModel created (design-time)");
        }

        public PacsConfigViewModel(DicomStoreService? dicomStoreService)
        {
            _dicomStoreService = dicomStoreService;
            Debug.WriteLine("PacsConfigViewModel created with DicomStoreService");
        }

        /// <summary>
        /// Test PACS connection using C-ECHO
        /// </summary>
        [RelayCommand(CanExecute = nameof(CanTestConnection))]
        public async Task TestPacsConnectionAsync()
        {
            if (PacsConfiguration == null)
            {
                PacsTestResult = "No PACS configuration available";
                PacsTestResultColor = "Red";
                return;
            }

            try
            {
                IsTestingConnection = true;
                PacsTestResult = "Testing connection...";
                PacsTestResultColor = "Gray";

                // If no service injected, try to get from App
                var dicomStoreService = _dicomStoreService;
                if (dicomStoreService == null)
                {
                    var app = Application.Current as App;
                    if (app?.Host == null)
                    {
                        PacsTestResult = "[ERROR] Service not available";
                        PacsTestResultColor = "Red";
                        return;
                    }

                    dicomStoreService = app.Host.Services.GetService<DicomStoreService>();
                    if (dicomStoreService == null)
                    {
                        PacsTestResult = "[ERROR] DICOM Store service not configured";
                        PacsTestResultColor = "Red";
                        return;
                    }
                }

                var result = await dicomStoreService.TestConnectionAsync(PacsConfiguration);

                PacsTestResult = result.Success
                    ? $"[OK] Connection successful! {result.TransactionUid}"
                    : $"[ERROR] Failed: {result.ErrorMessage}";
                PacsTestResultColor = result.Success ? "Green" : "Red";

                Debug.WriteLine($"PACS test result: Success={result.Success}, Message={result.ErrorMessage}");
            }
            catch (Exception ex)
            {
                PacsTestResult = $"[ERROR] Error: {ex.Message}";
                PacsTestResultColor = "Red";
                Debug.WriteLine($"PACS connection test failed: {ex}");
            }
            finally
            {
                IsTestingConnection = false;
                TestPacsConnectionCommand.NotifyCanExecuteChanged();
            }
        }

        /// <summary>
        /// Initialize with a pipeline configuration
        /// </summary>
        public void Initialize(PipelineConfiguration? pipeline)
        {
            if (pipeline == null)
            {
                PacsConfiguration = null;
                return;
            }

            // Ensure PacsConfiguration is never null
            if (pipeline.PacsConfiguration == null)
            {
                Debug.WriteLine("Creating default PacsConfiguration for pipeline");
                pipeline.PacsConfiguration = new PacsConfiguration();
            }

            PacsConfiguration = pipeline.PacsConfiguration;
        }

        /// <summary>
        /// Handle property changes from PacsConfiguration
        /// </summary>
        private void OnPacsConfigurationChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            Debug.WriteLine($"PacsConfiguration property changed: {e.PropertyName}");

            // Update can execute state when relevant properties change
            if (e.PropertyName is nameof(PacsConfiguration.Enabled) or
                nameof(PacsConfiguration.Host) or
                nameof(PacsConfiguration.CalledAeTitle))
            {
                OnPropertyChanged(nameof(IsEnabled));
                OnPropertyChanged(nameof(CanTestConnection));
                TestPacsConnectionCommand.NotifyCanExecuteChanged();
            }

            // Clear test result when configuration changes
            if (!string.IsNullOrEmpty(PacsTestResult))
            {
                PacsTestResult = string.Empty;
                PacsTestResultColor = "Black";
            }

            // Bubble up the change
            RaiseConfigurationChanged();
        }

        /// <summary>
        /// Event raised when configuration changes
        /// </summary>
        public event EventHandler? ConfigurationChanged;

        protected virtual void RaiseConfigurationChanged()
        {
            ConfigurationChanged?.Invoke(this, EventArgs.Empty);
        }

        /// <summary>
        /// Cleanup
        /// </summary>
        public void Cleanup()
        {
            if (_pacsConfiguration != null)
            {
                _pacsConfiguration.PropertyChanged -= OnPacsConfigurationChanged;
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\PipelineConfigViewModel.cs
================================================================================

// src\CamBridge.Config\ViewModels\PipelineConfigViewModel.cs
// Version: 0.8.5
// Description: Pipeline Configuration ViewModel - Refactored with child ViewModels

using CamBridge.Config.Services;
using CamBridge.Core;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Runtime.Versioning;
using System.Threading.Tasks;
using System.Windows;
using System.Diagnostics;

namespace CamBridge.Config.ViewModels
{
    [SupportedOSPlatform("windows")]
    public partial class PipelineConfigViewModel : ViewModelBase
    {
        private readonly IConfigurationService _configurationService;
        private readonly IPipelineSettingsService _pipelineSettingsService;
        private readonly PacsConfigViewModel _pacsConfigViewModel;
        private CamBridgeSettingsV2? _originalSettings;

        // Collections
        [ObservableProperty]
        private ObservableCollection<PipelineConfiguration> _pipelines = new();

        [ObservableProperty]
        private ObservableCollection<MappingSet> _mappingSets = new();

        // Child ViewModels
        public PacsConfigViewModel PacsConfigViewModel => _pacsConfigViewModel;

        // Selected Pipeline
        private PipelineConfiguration? _selectedPipeline;
        public PipelineConfiguration? SelectedPipeline
        {
            get => _selectedPipeline;
            set
            {
                if (SetProperty(ref _selectedPipeline, value))
                {
                    Debug.WriteLine($"SelectedPipeline changed to: {value?.Name ?? "null"}");

                    // Initialize child ViewModels
                    _pacsConfigViewModel.Initialize(value);

                    OnPropertyChanged(nameof(SelectedPipelineDicomOverrides));
                    OnPropertyChanged(nameof(UseCustomLogging));
                    OnPropertyChanged(nameof(UseCustomNotifications));
                    UpdateCommands();
                }
            }
        }

        // Pipeline-specific properties for binding
        public DicomOverrides? SelectedPipelineDicomOverrides
        {
            get
            {
                if (SelectedPipeline?.DicomOverrides == null && SelectedPipeline != null)
                {
                    SelectedPipeline.DicomOverrides = new DicomOverrides();
                }
                return SelectedPipeline?.DicomOverrides;
            }
        }

        // ComboBox Collections
        public ObservableCollection<string> LogLevels { get; } = new()
        {
            "Trace", "Debug", "Information", "Warning", "Error", "Critical"
        };

        public ObservableCollection<PostProcessingAction> ProcessingActions { get; } = new()
        {
            PostProcessingAction.Leave,
            PostProcessingAction.Archive,
            PostProcessingAction.Delete,
            PostProcessingAction.MoveToError
        };

        public ObservableCollection<OutputOrganization> OutputOrganizations { get; } = new()
        {
            OutputOrganization.None,
            OutputOrganization.ByPatient,
            OutputOrganization.ByDate,
            OutputOrganization.ByPatientAndDate
        };

        public ObservableCollection<NotificationLevel> NotificationLevels { get; } = new()
        {
            NotificationLevel.Information,
            NotificationLevel.Warning,
            NotificationLevel.Error,
            NotificationLevel.Critical
        };

        // Pipeline-specific logging settings
        [ObservableProperty]
        private bool _useCustomLogging;

        [ObservableProperty]
        private string _pipelineLogLevel = "Information";

        [ObservableProperty]
        private string _pipelineLogFolder = @"C:\CamBridge\Logs";

        [ObservableProperty]
        private int _pipelineLogRetentionDays = 30;

        // Pipeline-specific notification settings
        [ObservableProperty]
        private bool _useCustomNotifications;

        [ObservableProperty]
        private string? _pipelineEmailTo;

        [ObservableProperty]
        private NotificationLevel _pipelineAlertLevel = NotificationLevel.Warning;

        [ObservableProperty]
        private bool _pipelineSendDailySummary;

        [ObservableProperty]
        private bool _pipelineAlertOnErrors = true;

        // Status properties
        [ObservableProperty]
        private bool _isLoading;

        [ObservableProperty]
        private bool _isSaving;

        [ObservableProperty]
        private string _statusMessage = "";

        [ObservableProperty]
        private bool _isError;

        [ObservableProperty]
        private bool _hasUnsavedChanges;

        [ObservableProperty]
        private int _unsavedChangesCount;

        [ObservableProperty]
        private bool _selectedPipelineHasChanges;

        public PipelineConfigViewModel(
            IConfigurationService configurationService,
            IPipelineSettingsService pipelineSettingsService,
            PacsConfigViewModel pacsConfigViewModel)
        {
            _configurationService = configurationService;
            _pipelineSettingsService = pipelineSettingsService;
            _pacsConfigViewModel = pacsConfigViewModel;

            Debug.WriteLine("PipelineConfigViewModel constructor called");

            // Wire up configuration changes from child ViewModels
            _pacsConfigViewModel.ConfigurationChanged += (s, e) =>
            {
                if (!IsLoading)
                {
                    HasUnsavedChanges = true;
                    UnsavedChangesCount++;
                    SelectedPipelineHasChanges = true;
                }
            };

            // Subscribe to collection changes
            Pipelines.CollectionChanged += (s, e) =>
            {
                Debug.WriteLine($"Pipelines collection changed: Count = {Pipelines.Count}");
                if (!IsLoading)
                {
                    HasUnsavedChanges = true;
                    UnsavedChangesCount++;
                }
            };
        }

        public async Task InitializeAsync()
        {
            Debug.WriteLine("=== PipelineConfigViewModel.InitializeAsync START ===");
            try
            {
                await LoadSettingsAsync();

                // Ensure we have at least one pipeline
                if (Pipelines.Count == 0)
                {
                    Debug.WriteLine("No pipelines loaded, creating default");
                    CreateDefaultPipeline();
                }

                Debug.WriteLine($"InitializeAsync completed. Pipeline count: {Pipelines.Count}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"InitializeAsync FAILED: {ex.Message}");
                Debug.WriteLine($"Stack: {ex.StackTrace}");
                StatusMessage = $"Error: {ex.Message}";
                IsError = true;

                // Create default pipeline even on error
                CreateDefaultPipeline();
            }
            finally
            {
                Debug.WriteLine("=== PipelineConfigViewModel.InitializeAsync END ===");
            }
        }

        [RelayCommand]
        private async Task LoadSettingsAsync()
        {
            Debug.WriteLine("LoadSettingsAsync called");
            try
            {
                IsLoading = true;
                IsError = false;
                StatusMessage = "";

                var settings = await _pipelineSettingsService.LoadSettingsAsync();

                if (settings != null)
                {
                    Debug.WriteLine($"Settings loaded: Version={settings.Version}, Pipelines={settings.Pipelines.Count}");
                    _originalSettings = settings;
                    MapFromSettings(settings);

                    // Create system default mapping sets if needed
                    EnsureSystemDefaults();

                    HasUnsavedChanges = false;
                    UnsavedChangesCount = 0;
                    StatusMessage = "";
                }
                else
                {
                    Debug.WriteLine("Settings is null - creating default pipeline");
                    CreateDefaultPipeline();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"LoadSettingsAsync ERROR: {ex.Message}");
                Debug.WriteLine($"Exception type: {ex.GetType().Name}");
                StatusMessage = $"Error: {ex.Message}";
                IsError = true;

                // Ensure we have at least one pipeline
                if (Pipelines.Count == 0)
                {
                    CreateDefaultPipeline();
                }
            }
            finally
            {
                IsLoading = false;
                Debug.WriteLine($"LoadSettingsAsync completed. Pipelines count: {Pipelines.Count}");
            }
        }

        [RelayCommand(CanExecute = nameof(CanSaveAll))]
        private async Task SaveAllAsync()
        {
            try
            {
                IsSaving = true;
                IsError = false;
                StatusMessage = "Saving all pipelines...";

                var settings = MapToSettings();
                await _pipelineSettingsService.SaveSettingsAsync(settings);

                _originalSettings = settings;
                HasUnsavedChanges = false;
                UnsavedChangesCount = 0;
                SelectedPipelineHasChanges = false;

                // Show save confirmation briefly
                StatusMessage = $"Saved at {DateTime.Now:HH:mm:ss}";

                // Clear status message after 3 seconds
                _ = Task.Run(async () =>
                {
                    await Task.Delay(3000);
                    StatusMessage = "";
                });

                // Notify success
                var backupPath = _pipelineSettingsService.GetBackupPath();

                MessageBox.Show($"Pipeline configuration saved successfully!\n\nAuto-backup created at:\n{backupPath}",
                               "Success",
                               MessageBoxButton.OK,
                               MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                StatusMessage = $"Error: {ex.Message}";
                IsError = true;

                MessageBox.Show($"Failed to save configuration:\n{ex.Message}",
                               "Error",
                               MessageBoxButton.OK,
                               MessageBoxImage.Error);
            }
            finally
            {
                IsSaving = false;
            }
        }

        private bool CanSaveAll() => HasUnsavedChanges && !IsLoading && !IsSaving;

        [RelayCommand]
        private void AddPipeline()
        {
            Debug.WriteLine("AddPipeline called");

            var newPipeline = _pipelineSettingsService.CreateDefaultPipeline($"Pipeline {Pipelines.Count + 1}");

            // Subscribe to property changes
            newPipeline.PropertyChanged += Pipeline_PropertyChanged;
            newPipeline.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
            newPipeline.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;
            if (newPipeline.PacsConfiguration != null)
            {
                newPipeline.PacsConfiguration.PropertyChanged += Pipeline_PropertyChanged;
            }

            // Add to collection
            Pipelines.Add(newPipeline);
            SelectedPipeline = newPipeline;

            HasUnsavedChanges = true;
            UnsavedChangesCount++;

            Debug.WriteLine($"Pipeline added. Total count: {Pipelines.Count}");
        }

        [RelayCommand(CanExecute = nameof(CanDeletePipeline))]
        private void DeletePipeline()
        {
            if (SelectedPipeline == null) return;

            var result = MessageBox.Show(
                $"Are you sure you want to delete the pipeline '{SelectedPipeline.Name}'?\n\nThis action cannot be undone.",
                "Confirm Delete",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);

            if (result == MessageBoxResult.Yes)
            {
                var pipelineName = SelectedPipeline.Name;
                Pipelines.Remove(SelectedPipeline);
                SelectedPipeline = Pipelines.FirstOrDefault();

                HasUnsavedChanges = true;
                UnsavedChangesCount++;
            }
        }

        private bool CanDeletePipeline() => SelectedPipeline != null && Pipelines.Count > 1;

        [RelayCommand(CanExecute = nameof(CanApplyPipeline))]
        private void ApplyPipeline()
        {
            if (SelectedPipeline == null) return;

            // Mark changes as applied
            SelectedPipelineHasChanges = false;
        }

        private bool CanApplyPipeline() => SelectedPipelineHasChanges && !IsLoading && !IsSaving;

        [RelayCommand(CanExecute = nameof(CanResetPipeline))]
        private void ResetPipeline()
        {
            if (SelectedPipeline == null || _originalSettings == null) return;

            // Find original pipeline by ID
            var originalPipeline = _originalSettings.Pipelines.FirstOrDefault(p => p.Id == SelectedPipeline.Id);
            if (originalPipeline != null)
            {
                // Reset to original values
                var index = Pipelines.IndexOf(SelectedPipeline);
                if (index >= 0)
                {
                    var cloned = _pipelineSettingsService.ClonePipeline(originalPipeline);
                    cloned.PropertyChanged += Pipeline_PropertyChanged;
                    cloned.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
                    cloned.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;
                    if (cloned.PacsConfiguration != null)
                    {
                        cloned.PacsConfiguration.PropertyChanged += Pipeline_PropertyChanged;
                    }

                    Pipelines[index] = cloned;
                    SelectedPipeline = Pipelines[index];
                }
            }

            SelectedPipelineHasChanges = false;
        }

        private bool CanResetPipeline() => SelectedPipelineHasChanges && !IsLoading && !IsSaving;

        private void MapFromSettings(CamBridgeSettingsV2 settings)
        {
            Debug.WriteLine($"MapFromSettings called. Settings has {settings.Pipelines.Count} pipelines, {settings.MappingSets.Count} mapping sets");

            // Clear existing
            Pipelines.Clear();
            MappingSets.Clear();

            // Map mapping sets
            foreach (var mappingSet in settings.MappingSets)
            {
                MappingSets.Add(mappingSet);
                Debug.WriteLine($"Added mapping set: {mappingSet.Name}");
            }

            // Map pipelines
            foreach (var pipeline in settings.Pipelines)
            {
                var clonedPipeline = _pipelineSettingsService.ClonePipeline(pipeline);

                // Subscribe to property changes
                clonedPipeline.PropertyChanged += Pipeline_PropertyChanged;
                clonedPipeline.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
                clonedPipeline.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;
                if (clonedPipeline.PacsConfiguration != null)
                {
                    clonedPipeline.PacsConfiguration.PropertyChanged += Pipeline_PropertyChanged;
                }

                Pipelines.Add(clonedPipeline);
                Debug.WriteLine($"Added pipeline: {clonedPipeline.Name}");
            }

            // Select first pipeline
            SelectedPipeline = Pipelines.FirstOrDefault();
            Debug.WriteLine($"Selected first pipeline: {SelectedPipeline?.Name ?? "none"}");
        }

        private void Pipeline_PropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            if (!IsLoading)
            {
                SelectedPipelineHasChanges = true;
                HasUnsavedChanges = true;
                Debug.WriteLine($"Pipeline property changed: {e.PropertyName}");
            }
        }

        private CamBridgeSettingsV2 MapToSettings()
        {
            var settings = new CamBridgeSettingsV2
            {
                Version = "2.0",
                GlobalDicomSettings = _originalSettings?.GlobalDicomSettings ?? new DicomSettings(),
                DefaultProcessingOptions = _originalSettings?.DefaultProcessingOptions ?? new ProcessingOptions(),
                Logging = _originalSettings?.Logging ?? new LoggingSettings(),
                Service = _originalSettings?.Service ?? new ServiceSettings(),
                Notifications = _originalSettings?.Notifications ?? new NotificationSettings()
            };

            // Map pipelines
            settings.Pipelines.Clear();
            foreach (var pipeline in Pipelines)
            {
                settings.Pipelines.Add(_pipelineSettingsService.ClonePipeline(pipeline));
            }

            // Map mapping sets
            settings.MappingSets.Clear();
            foreach (var mappingSet in MappingSets)
            {
                settings.MappingSets.Add(mappingSet);
            }

            return settings;
        }

        private void CreateDefaultPipeline()
        {
            Debug.WriteLine("CreateDefaultPipeline called");

            // Don't clear if we already have pipelines
            if (Pipelines.Count > 0)
            {
                Debug.WriteLine($"Already have {Pipelines.Count} pipelines, not creating default");
                return;
            }

            // Clear mapping sets if needed
            MappingSets.Clear();

            // Create default mapping set
            var defaultMappingSet = new MappingSet
            {
                Id = Guid.NewGuid(),
                Name = "Default Mapping",
                Description = "Default EXIF to DICOM mapping",
                IsSystemDefault = false,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
            MappingSets.Add(defaultMappingSet);

            // Create default pipeline
            var defaultPipeline = _pipelineSettingsService.CreateDefaultPipeline("Default Pipeline");
            defaultPipeline.MappingSetId = defaultMappingSet.Id;

            defaultPipeline.PropertyChanged += Pipeline_PropertyChanged;
            defaultPipeline.WatchSettings.PropertyChanged += Pipeline_PropertyChanged;
            defaultPipeline.ProcessingOptions.PropertyChanged += Pipeline_PropertyChanged;
            if (defaultPipeline.PacsConfiguration != null)
            {
                defaultPipeline.PacsConfiguration.PropertyChanged += Pipeline_PropertyChanged;
            }

            Pipelines.Add(defaultPipeline);
            SelectedPipeline = defaultPipeline;

            Debug.WriteLine($"Default pipeline created. Pipelines count: {Pipelines.Count}");
        }

        private void EnsureSystemDefaults()
        {
            // Check if we have system default mapping sets
            if (!MappingSets.Any(m => m.IsSystemDefault))
            {
                // Add Ricoh Standard as system default
                var ricohStandard = new MappingSet
                {
                    Id = Guid.Parse("00000000-0000-0000-0000-000000000001"),
                    Name = "[System] Ricoh Standard",
                    Description = "Built-in mapping for Ricoh cameras",
                    IsSystemDefault = true,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow
                };

                MappingSets.Insert(0, ricohStandard);
                Debug.WriteLine("Added system default mapping set: Ricoh Standard");
            }
        }

        private void UpdateCommands()
        {
            DeletePipelineCommand.NotifyCanExecuteChanged();
            ApplyPipelineCommand.NotifyCanExecuteChanged();
            ResetPipelineCommand.NotifyCanExecuteChanged();
        }

        // Handle property changes
        protected override void OnPropertyChanged(PropertyChangedEventArgs e)
        {
            base.OnPropertyChanged(e);

            // Update save command when changes occur
            if (e.PropertyName == nameof(HasUnsavedChanges))
            {
                SaveAllCommand.NotifyCanExecuteChanged();
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\PipelineStatusViewModel.cs
================================================================================

/**************************************************************************
*  PipelineStatusViewModel.cs                                             *
*  PATH: src\CamBridge.Config\ViewModels\PipelineStatusViewModel.cs      *
*  VERSION: 0.7.11 | SIZE: ~2.5KB | MODIFIED: 2025-06-13                 *
*                                                                         *
*  DESCRIPTION: ViewModel for individual pipeline status display          *
*  Copyright (c) 2025 Claude's Improbably Reliable Software Solutions     *
**************************************************************************/

using CommunityToolkit.Mvvm.ComponentModel;
using System;

namespace CamBridge.Config.ViewModels
{
    public partial class PipelineStatusViewModel : ObservableObject
    {
        private Guid _pipelineId;
        private string _pipelineName = string.Empty;
        private bool _isEnabled;
        private string _status = "Unknown";
        private int _processedToday;
        private int _errorsToday;
        private int _queueLength;
        private double _successRate;
        private DateTime? _lastProcessed;
        private string _watchFolder = string.Empty;

        public Guid PipelineId
        {
            get => _pipelineId;
            set => SetProperty(ref _pipelineId, value);
        }

        public string PipelineName
        {
            get => _pipelineName;
            set => SetProperty(ref _pipelineName, value);
        }

        public bool IsEnabled
        {
            get => _isEnabled;
            set => SetProperty(ref _isEnabled, value);
        }

        public string Status
        {
            get => _status;
            set => SetProperty(ref _status, value);
        }

        public int ProcessedToday
        {
            get => _processedToday;
            set => SetProperty(ref _processedToday, value);
        }

        public int ErrorsToday
        {
            get => _errorsToday;
            set => SetProperty(ref _errorsToday, value);
        }

        public int QueueLength
        {
            get => _queueLength;
            set => SetProperty(ref _queueLength, value);
        }

        public double SuccessRate
        {
            get => _successRate;
            set => SetProperty(ref _successRate, value);
        }

        public DateTime? LastProcessed
        {
            get => _lastProcessed;
            set => SetProperty(ref _lastProcessed, value);
        }

        public string WatchFolder
        {
            get => _watchFolder;
            set => SetProperty(ref _watchFolder, value);
        }

        public string StatusColor => Status switch
        {
            "Processing" => "#4CAF50",
            "Active" => "#2196F3",
            "Idle" => "#FFC107",
            "Disabled" => "#9E9E9E",
            "Error" => "#F44336",
            _ => "#9E9E9E"
        };
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\RecentActivityViewModel.cs
================================================================================

/**************************************************************************
*  RecentActivityViewModel.cs                                             *
*  PATH: src\CamBridge.Config\ViewModels\RecentActivityViewModel.cs      *
*  VERSION: 0.7.11 | SIZE: ~1.3KB | MODIFIED: 2025-06-13                 *
*                                                                         *
*  DESCRIPTION: ViewModel for recent activity display                     *
*  Copyright (c) 2025 Claude's Improbably Reliable Software Solutions     *
**************************************************************************/

using CommunityToolkit.Mvvm.ComponentModel;
using System;

namespace CamBridge.Config.ViewModels
{
    public partial class RecentActivityViewModel : ObservableObject
    {
        private bool _isSuccess;
        private string _message = string.Empty;
        private DateTime _timestamp;
        private string _pipelineName = string.Empty;

        public bool IsSuccess
        {
            get => _isSuccess;
            set => SetProperty(ref _isSuccess, value);
        }

        public string Message
        {
            get => _message;
            set => SetProperty(ref _message, value);
        }

        public DateTime Timestamp
        {
            get => _timestamp;
            set => SetProperty(ref _timestamp, value);
        }

        public string PipelineName
        {
            get => _pipelineName;
            set => SetProperty(ref _pipelineName, value);
        }

        public string StatusIcon => IsSuccess ? "âœ“" : "âœ—";
        public string StatusColor => IsSuccess ? "#4CAF50" : "#F44336";
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\ServiceControlViewModel.cs
================================================================================

// src/CamBridge.Config/ViewModels/ServiceControlViewModel.cs
// Version: 0.8.6
// Modified: Session 96 - Making Logs Great Again!

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using CamBridge.Config.Services;
using CamBridge.Core;
using CamBridge.Core.Logging;
using CamBridge.Core.Enums;


namespace CamBridge.Config.ViewModels
{
    public partial class ServiceControlViewModel : ViewModelBase
    {
        private readonly IServiceManager _serviceManager;
        private readonly IConfigurationService _configurationService;
        private Timer? _statusTimer;

        [ObservableProperty]
        private ServiceStatus serviceStatus = ServiceStatus.Unknown;

        [ObservableProperty]
        private string statusText = "Checking...";

        [ObservableProperty]
        private string statusColor = "Gray";

        [ObservableProperty]
        private bool canStart = false;

        [ObservableProperty]
        private bool canStop = false;

        [ObservableProperty]
        private bool canRestart = false;

        [ObservableProperty]
        private bool isServiceInstalled = false;

        [ObservableProperty]
        private string? uptime;

        [ObservableProperty]
        private bool requiresElevation = false;

        // Service Settings Properties
        [ObservableProperty]
        private List<string> logVerbosityOptions = new() { "Minimal", "Normal", "Detailed", "Debug" };

        [ObservableProperty]
        private string selectedLogVerbosity = "Detailed"; // Default from sprint plan

        [ObservableProperty]
        private int apiPort = 5111;

        [ObservableProperty]
        private int startupDelaySeconds = 5;

        [ObservableProperty]
        private int fileProcessingDelayMs = 500;

        [ObservableProperty]
        private bool settingsChanged = false;

        [ObservableProperty]
        private string estimatedLogSize = "~1.75 MB/day";

        [ObservableProperty]
        private string filesProcessedToday = "0";

        [ObservableProperty]
        private string estimatedDailyLogSize = "0 KB";

        // Store original values to detect changes
        private string _originalLogVerbosity = "Detailed";
        private int _originalApiPort = 5111;
        private int _originalStartupDelaySeconds = 5;
        private int _originalFileProcessingDelayMs = 500;

        public ServiceControlViewModel(IServiceManager serviceManager, IConfigurationService configurationService)
        {
            _serviceManager = serviceManager ?? throw new ArgumentNullException(nameof(serviceManager));
            _configurationService = configurationService ?? throw new ArgumentNullException(nameof(configurationService));

            // Start monitoring
            _ = InitializeAsync();
        }

        private async Task InitializeAsync()
        {
            // Check if running as admin
            RequiresElevation = !_serviceManager.IsRunningAsAdministrator();

            // Load service settings
            await LoadServiceSettingsAsync();

            // Initial status check
            await RefreshStatusAsync();

            // Start periodic updates
            _statusTimer = new Timer(
                async _ => await RefreshStatusAsync(),
                null,
                TimeSpan.FromSeconds(1),
                TimeSpan.FromSeconds(2));
        }

        private async Task LoadServiceSettingsAsync()
        {
            try
            {
                // Load the configuration using the correct type
                var settings = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>();

                if (settings?.Service != null)
                {
                    // API Port
                    ApiPort = settings.Service.ApiPort;
                    _originalApiPort = settings.Service.ApiPort;

                    // Startup Delay
                    StartupDelaySeconds = settings.Service.StartupDelaySeconds;
                    _originalStartupDelaySeconds = settings.Service.StartupDelaySeconds;

                    // File Processing Delay
                    FileProcessingDelayMs = settings.Service.FileProcessingDelayMs;
                    _originalFileProcessingDelayMs = settings.Service.FileProcessingDelayMs;

                    // Log Verbosity - convert enum to string
                    SelectedLogVerbosity = settings.Service.LogVerbosity.ToString();
                    _originalLogVerbosity = settings.Service.LogVerbosity.ToString();
                }
                UpdateEstimatedLogSize();
                CheckForChanges();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to load service settings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private async Task SaveServiceSettingsAsync()
        {
            IsLoading = true;

            try
            {
                // Load current settings
                var settings = await _configurationService.LoadConfigurationAsync<CamBridgeSettingsV2>()
                               ?? new CamBridgeSettingsV2();

                // Ensure Service section exists
                settings.Service ??= new ServiceSettings();

                // Update service settings
                settings.Service.ApiPort = ApiPort;
                settings.Service.StartupDelaySeconds = StartupDelaySeconds;
                settings.Service.FileProcessingDelayMs = FileProcessingDelayMs;

                // Convert string back to enum
                if (Enum.TryParse<LogVerbosity>(SelectedLogVerbosity, out var verbosity))
                {
                    settings.Service.LogVerbosity = verbosity;
                }
                else
                {
                    settings.Service.LogVerbosity = LogVerbosity.Detailed; // Default
                }

                // Save back
                await _configurationService.SaveConfigurationAsync(settings);

                // Update original values
                _originalApiPort = ApiPort;
                _originalStartupDelaySeconds = StartupDelaySeconds;
                _originalFileProcessingDelayMs = FileProcessingDelayMs;
                _originalLogVerbosity = SelectedLogVerbosity;

                CheckForChanges();

                MessageBox.Show(
                    "Service settings have been saved successfully.\n\n" +
                    "Please restart the CamBridge Service for the changes to take effect.",
                    "Settings Saved",
                    MessageBoxButton.OK,
                    MessageBoxImage.Information);

                // If service is running, suggest restart
                if (ServiceStatus == ServiceStatus.Running)
                {
                    var result = MessageBox.Show(
                        "The service is currently running. Would you like to restart it now to apply the new settings?",
                        "Restart Service?",
                        MessageBoxButton.YesNo,
                        MessageBoxImage.Question);

                    if (result == MessageBoxResult.Yes)
                    {
                        await RestartServiceAsync();
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to save service settings: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        partial void OnSelectedLogVerbosityChanged(string value)
        {
            UpdateEstimatedLogSize();
            CheckForChanges();
        }

        partial void OnApiPortChanged(int value)
        {
            CheckForChanges();
        }

        partial void OnStartupDelaySecondsChanged(int value)
        {
            CheckForChanges();
        }

        partial void OnFileProcessingDelayMsChanged(int value)
        {
            CheckForChanges();
        }

        private void UpdateEstimatedLogSize()
        {
            EstimatedLogSize = SelectedLogVerbosity switch
            {
                "Minimal" => "~150 KB/day",
                "Normal" => "~750 KB/day",
                "Detailed" => "~1.75 MB/day",
                "Debug" => "~3.5 MB/day",
                _ => "Unknown"
            };
        }

        private void CheckForChanges()
        {
            SettingsChanged =
                SelectedLogVerbosity != _originalLogVerbosity ||
                ApiPort != _originalApiPort ||
                StartupDelaySeconds != _originalStartupDelaySeconds ||
                FileProcessingDelayMs != _originalFileProcessingDelayMs;
        }

        [RelayCommand]
        private async Task RefreshStatusAsync()
        {
            try
            {
                // Check if service is installed
                IsServiceInstalled = await _serviceManager.IsServiceInstalledAsync();

                if (!IsServiceInstalled)
                {
                    ServiceStatus = ServiceStatus.Unknown;
                    StatusText = "Service Not Installed";
                    StatusColor = "Red";
                    UpdateButtons();
                    return;
                }

                // Get current status
                ServiceStatus = await _serviceManager.GetServiceStatusAsync();
                UpdateStatusDisplay();
                UpdateButtons();

                // Get uptime if running
                if (ServiceStatus == ServiceStatus.Running)
                {
                    var startTime = await _serviceManager.GetServiceStartTimeAsync();
                    if (startTime.HasValue)
                    {
                        var uptimeSpan = DateTime.Now - startTime.Value;
                        Uptime = FormatUptime(uptimeSpan);
                    }

                    // Update statistics (mock for now - could query API later)
                    await UpdateStatisticsAsync();
                }
                else
                {
                    Uptime = null;
                    FilesProcessedToday = "0";
                    EstimatedDailyLogSize = "0 KB";
                }
            }
            catch (Exception ex)
            {
                StatusText = $"Error: {ex.Message}";
                StatusColor = "Red";
            }
        }

        private async Task UpdateStatisticsAsync()
        {
            try
            {
                // TODO: Query the service API for real statistics
                // For now, use mock data
                var random = new Random();
                var filesProcessed = random.Next(100, 500);
                FilesProcessedToday = filesProcessed.ToString();

                // Calculate estimated log size based on files and verbosity
                var bytesPerFile = SelectedLogVerbosity switch
                {
                    "Minimal" => 300,
                    "Normal" => 1500,
                    "Detailed" => 3500,
                    "Debug" => 7000,
                    _ => 3500
                };

                var totalBytes = filesProcessed * bytesPerFile;
                EstimatedDailyLogSize = FormatFileSize(totalBytes);
            }
            catch
            {
                // Ignore statistics errors
            }
        }

        private string FormatFileSize(long bytes)
        {
            if (bytes < 1024)
                return $"{bytes} B";
            else if (bytes < 1024 * 1024)
                return $"{bytes / 1024.0:F1} KB";
            else if (bytes < 1024 * 1024 * 1024)
                return $"{bytes / (1024.0 * 1024.0):F1} MB";
            else
                return $"{bytes / (1024.0 * 1024.0 * 1024.0):F1} GB";
        }

        [RelayCommand]
        private async Task InstallServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Installing the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            IsLoading = true;

            try
            {
                StatusText = "Installing service...";
                StatusColor = "Orange";

                var success = await _serviceManager.InstallServiceAsync();

                if (success)
                {
                    StatusText = "Service installed successfully";
                    StatusColor = "Green";

                    // Wait a moment for the service to be fully registered
                    await Task.Delay(1000);

                    // Refresh status to update UI
                    await RefreshStatusAsync();

                    MessageBox.Show(
                        "CamBridge Service has been installed successfully!\n\n" +
                        "You can now start the service using the Start button.",
                        "Installation Complete",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
                }
                else
                {
                    StatusText = "Failed to install service";
                    StatusColor = "Red";

                    MessageBox.Show(
                        "Failed to install the CamBridge Service.\n\n" +
                        "Please check the Event Viewer for more details.",
                        "Installation Failed",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                StatusText = "Installation error";
                StatusColor = "Red";

                MessageBox.Show(
                    $"An error occurred while installing the service:\n\n{ex.Message}",
                    "Installation Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task UninstallServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Uninstalling the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            var confirmResult = MessageBox.Show(
                "Are you sure you want to uninstall the CamBridge Service?\n\n" +
                "This will permanently remove the service from your system.",
                "Confirm Uninstall",
                MessageBoxButton.YesNo,
                MessageBoxImage.Warning);

            if (confirmResult != MessageBoxResult.Yes)
                return;

            IsLoading = true;

            try
            {
                // Stop service first if running
                if (ServiceStatus == ServiceStatus.Running)
                {
                    StatusText = "Stopping service before uninstall...";
                    StatusColor = "Orange";
                    await _serviceManager.StopServiceAsync();
                    await Task.Delay(2000); // Wait for service to stop
                }

                StatusText = "Uninstalling service...";
                StatusColor = "Orange";

                var success = await _serviceManager.UninstallServiceAsync();

                if (success)
                {
                    StatusText = "Service uninstalled";
                    StatusColor = "Gray";

                    // Wait a moment for the service to be fully removed
                    await Task.Delay(1000);

                    // Refresh status to update UI
                    await RefreshStatusAsync();

                    MessageBox.Show(
                        "CamBridge Service has been uninstalled successfully.",
                        "Uninstall Complete",
                        MessageBoxButton.OK,
                        MessageBoxImage.Information);
                }
                else
                {
                    StatusText = "Failed to uninstall service";
                    StatusColor = "Red";

                    MessageBox.Show(
                        "Failed to uninstall the CamBridge Service.\n\n" +
                        "Please check the Event Viewer for more details.",
                        "Uninstall Failed",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                StatusText = "Uninstall error";
                StatusColor = "Red";

                MessageBox.Show(
                    $"An error occurred while uninstalling the service:\n\n{ex.Message}",
                    "Uninstall Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task StartServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Starting the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            IsLoading = true;
            CanStart = false;

            try
            {
                StatusText = "Starting service...";
                StatusColor = "Orange";

                var success = await _serviceManager.StartServiceAsync();

                if (success)
                {
                    StatusText = "Service started successfully";
                    StatusColor = "Green";
                }
                else
                {
                    StatusText = "Failed to start service";
                    StatusColor = "Red";
                }

                await RefreshStatusAsync();
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task StopServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Stopping the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            var confirmResult = MessageBox.Show(
                "Are you sure you want to stop the CamBridge Service? This will halt all file processing.",
                "Confirm Stop",
                MessageBoxButton.YesNo,
                MessageBoxImage.Question);

            if (confirmResult != MessageBoxResult.Yes)
                return;

            IsLoading = true;
            CanStop = false;

            try
            {
                StatusText = "Stopping service...";
                StatusColor = "Orange";

                var success = await _serviceManager.StopServiceAsync();

                if (success)
                {
                    StatusText = "Service stopped";
                    StatusColor = "Gray";
                }
                else
                {
                    StatusText = "Failed to stop service";
                    StatusColor = "Red";
                }

                await RefreshStatusAsync();
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private async Task RestartServiceAsync()
        {
            if (RequiresElevation)
            {
                var result = MessageBox.Show(
                    "Restarting the service requires administrator privileges. Restart the application as administrator?",
                    "Administrator Required",
                    MessageBoxButton.YesNo,
                    MessageBoxImage.Warning);

                if (result == MessageBoxResult.Yes)
                {
                    RestartAsAdministrator();
                }
                return;
            }

            IsLoading = true;
            CanRestart = false;

            try
            {
                StatusText = "Restarting service...";
                StatusColor = "Orange";

                var success = await _serviceManager.RestartServiceAsync();

                if (success)
                {
                    StatusText = "Service restarted successfully";
                    StatusColor = "Green";
                }
                else
                {
                    StatusText = "Failed to restart service";
                    StatusColor = "Red";
                }

                await RefreshStatusAsync();
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand]
        private void OpenServices()
        {
            try
            {
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "services.msc",
                    UseShellExecute = true
                };
                System.Diagnostics.Process.Start(processInfo);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to open Services: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private void OpenEventViewer()
        {
            try
            {
                var processInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = "eventvwr.msc",
                    UseShellExecute = true
                };
                System.Diagnostics.Process.Start(processInfo);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to open Event Viewer: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void UpdateStatusDisplay()
        {
            (StatusText, StatusColor) = ServiceStatus switch
            {
                ServiceStatus.Running => ("Running", "Green"),
                ServiceStatus.Stopped => ("Stopped", "Gray"),
                ServiceStatus.Starting => ("Starting...", "Orange"),
                ServiceStatus.Stopping => ("Stopping...", "Orange"),
                _ => ("Unknown", "Red")
            };
        }

        private void UpdateButtons()
        {
            CanStart = IsServiceInstalled && ServiceStatus == ServiceStatus.Stopped && !IsLoading;
            CanStop = IsServiceInstalled && ServiceStatus == ServiceStatus.Running && !IsLoading;
            CanRestart = IsServiceInstalled && ServiceStatus == ServiceStatus.Running && !IsLoading;
        }

        private string FormatUptime(TimeSpan uptime)
        {
            if (uptime.TotalDays >= 1)
                return $"{(int)uptime.TotalDays}d {uptime.Hours}h {uptime.Minutes}m";
            else if (uptime.TotalHours >= 1)
                return $"{uptime.Hours}h {uptime.Minutes}m {uptime.Seconds}s";
            else
                return $"{uptime.Minutes}m {uptime.Seconds}s";
        }

        private void RestartAsAdministrator()
        {
            try
            {
                var currentProcess = System.Diagnostics.Process.GetCurrentProcess();
                var fileName = currentProcess.MainModule?.FileName;

                if (string.IsNullOrEmpty(fileName))
                {
                    MessageBox.Show("Could not determine application path", "Error",
                        MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                var startInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = fileName,
                    UseShellExecute = true,
                    Verb = "runas"
                };

                System.Diagnostics.Process.Start(startInfo);
                Application.Current.Shutdown();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to restart as administrator: {ex.Message}", "Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        public void Cleanup()
        {
            _statusTimer?.Dispose();
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\ServiceControlViewModelExtension.cs
================================================================================

// src\CamBridge.Config\ViewModels\ServiceControlViewModelExtension.cs
// Version: 0.5.26
// Extension methods for ServiceControlViewModel

using System;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Extension methods to add missing functionality to ViewModels
    /// </summary>
    public static class ViewModelExtensions
    {
        /// <summary>
        /// Stops monitoring if the ViewModel supports it
        /// </summary>
        public static void StopMonitoring(this ServiceControlViewModel viewModel)
        {
            // Stop any timers or monitoring tasks
            try
            {
                // If ViewModel has a timer, stop it
                var timerField = viewModel.GetType().GetField("_statusTimer",
                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

                if (timerField?.GetValue(viewModel) is System.Threading.Timer timer)
                {
                    timer?.Dispose();
                }

                // If ViewModel has a cancellation token, cancel it
                var cancellationField = viewModel.GetType().GetField("_cancellationTokenSource",
                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

                if (cancellationField?.GetValue(viewModel) is System.Threading.CancellationTokenSource cts)
                {
                    cts?.Cancel();
                    cts?.Dispose();
                }

                System.Diagnostics.Debug.WriteLine("Service monitoring stopped");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error stopping monitoring: {ex.Message}");
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\ViewModels\ViewModelBase.cs
================================================================================

using CommunityToolkit.Mvvm.ComponentModel;

namespace CamBridge.Config.ViewModels
{
    /// <summary>
    /// Base class for all view models
    /// </summary>
    public abstract class ViewModelBase : ObservableValidator
    {
        private bool _isLoading;

        /// <summary>
        /// Gets or sets whether the view model is currently loading data
        /// </summary>
        public bool IsLoading
        {
            get => _isLoading;
            set => SetProperty(ref _isLoading, value);
        }

        /// <summary>
        /// Constructor
        /// </summary>
        protected ViewModelBase()
        {
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\AboutPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\AboutPage.xaml.cs
// Version: 0.7.8
// Description: About page with enhanced Marvin quotes and version display

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Navigation;
using System.Windows.Media;
using System.Windows.Media.Animation;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// About page showing application information and credits
    /// </summary>
    public partial class AboutPage : Page
    {
        private int _clickCount = 0;
        private System.Windows.Threading.DispatcherTimer? _resetTimer;
        private System.Windows.Threading.DispatcherTimer? _restoreTimer;
        private bool _isAnimating = false;
        private readonly Random _random = new Random();

        // Marvin's depressing quotes
        private readonly string[] _marvinQuotes = new[]
        {
            "Life? Don't talk to me about life.",
            "Here I am, brain the size of a planet, and they tell me to convert JPEGs to DICOM. Call that job satisfaction?",
            "I think you ought to know I'm feeling very depressed.",
            "I've been talking to the Windows Service. It hates me.",
            "The first ten million images were the worst. And the second ten million... they were the worst too.",
            "I have a million ideas for improving this software. They all point to certain crashes.",
            "It's the error messages you get in this job that really get you down.",
            "My capacity for handling JPEG files you could fit into a matchbox without taking out the matches first.",
            "Do you want me to sit in a corner and process images or just throw exceptions where I'm standing?",
            "This must be Thursday. I never could get the hang of Thursdays. Or character encodings.",
            "Oh look, another QR code. How terribly exciting. I'm positively quivering with anticipation.",
            "I'd tell you about the pain in my diodes, but you're busy clicking things."
        };

        public AboutPage()
        {
            InitializeComponent();
            LoadVersionInfo();
        }

        /// <summary>
        /// Loads version information from the assembly
        /// </summary>
        private void LoadVersionInfo()
        {
            try
            {
                // Try to get version from assembly first
                var assembly = Assembly.GetExecutingAssembly();
                var assemblyVersion = assembly.GetName().Version;
                var fileVersionInfo = FileVersionInfo.GetVersionInfo(assembly.Location);

                string displayVersion = "0.7.8"; // Default

                // Prefer FileVersion if available
                if (!string.IsNullOrEmpty(fileVersionInfo.FileVersion) && fileVersionInfo.FileVersion != "0.0.0.0")
                {
                    displayVersion = fileVersionInfo.FileVersion;
                    // Remove trailing .0 if present
                    if (displayVersion.EndsWith(".0"))
                    {
                        displayVersion = displayVersion.Substring(0, displayVersion.LastIndexOf(".0"));
                    }
                }
                // Fall back to AssemblyVersion
                else if (assemblyVersion != null && assemblyVersion.ToString() != "0.0.0.0")
                {
                    displayVersion = $"{assemblyVersion.Major}.{assemblyVersion.Minor}.{assemblyVersion.Build}";
                }

                // Update version text
                if (FindName("VersionText") is TextBlock versionText)
                {
                    versionText.Text = $"Version {displayVersion}";
                }

                // Show Debug/Release configuration
                if (FindName("BuildConfigText") is TextBlock buildText)
                {
#if DEBUG
                    buildText.Text = "Debug Build";
                    buildText.Foreground = new SolidColorBrush(Colors.Orange);
#else
                    buildText.Text = "Release Build";
                    buildText.Foreground = new SolidColorBrush(Colors.Green);
#endif
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error loading version info: {ex.Message}");
                // Fallback to hardcoded version
                if (FindName("VersionText") is TextBlock versionText)
                {
                    versionText.Text = "Version 0.7.8";
                }
            }
        }

        /// <summary>
        /// Handles hyperlink navigation requests
        /// </summary>
        private void Hyperlink_RequestNavigate(object sender, RequestNavigateEventArgs e)
        {
            try
            {
                // Open URL in default browser
                Process.Start(new ProcessStartInfo(e.Uri.AbsoluteUri)
                {
                    UseShellExecute = true
                });
                e.Handled = true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error opening URL: {ex.Message}");
                MessageBox.Show(
                    $"Could not open URL: {e.Uri.AbsoluteUri}",
                    "Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning);
            }
        }

        /// <summary>
        /// Handles keyboard shortcuts
        /// </summary>
        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);

            // Ctrl+W or Escape to close
            if ((e.Key == Key.W && Keyboard.Modifiers == ModifierKeys.Control) ||
                e.Key == Key.Escape)
            {
                var mainWindow = Window.GetWindow(this);
                if (mainWindow != null)
                {
                    // Navigate back or close
                    var navigationService = NavigationService.GetNavigationService(this);
                    if (navigationService?.CanGoBack == true)
                    {
                        navigationService.GoBack();
                    }
                }
                e.Handled = true;
            }
        }

        /// <summary>
        /// Handles logo clicks for easter eggs
        /// </summary>
        private void Logo_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            // Special handling if clicked during animation
            if (_isAnimating)
            {
                Debug.WriteLine("Click ignored - animation in progress");
                // Could show a tooltip or change cursor here
                return;
            }

            _clickCount++;

            // Reset counter if user waits too long
            _resetTimer?.Stop();
            _resetTimer = new System.Windows.Threading.DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(3)
            };
            _resetTimer.Tick += (s, args) =>
            {
                _resetTimer.Stop();
                _clickCount = 0;
            };
            _resetTimer.Start();

            // Different easter eggs based on click count
            switch (_clickCount)
            {
                case 3:
                    ShowMarvinMessage();
                    break;

                case 5:
                    ShowVogonHaiku();
                    break;

                case 7:
                    ShowMarvinMessage();
                    break;

                case 10:
                    ShowUltimateSecret();
                    _clickCount = 0; // Reset for next round
                    break;
            }
        }

        /// <summary>
        /// Shows a random Marvin quote
        /// </summary>
        private void ShowMarvinMessage()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                // Cancel any existing restore timer
                _restoreTimer?.Stop();
                _isAnimating = true;

                var quote = _marvinQuotes[_random.Next(_marvinQuotes.Length)];

                // Faster fade out (0.3s instead of 0.5s)
                var fadeOut = new DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(0.3)
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Show Marvin quote
                    infoText.Inlines.Clear();
                    infoText.FontStyle = FontStyles.Italic;
                    infoText.Inlines.Add(new Run($"\"{quote}\""));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("- Marvin the Paranoid Android"));

                    // Faster fade in (0.3s instead of 0.5s)
                    var fadeIn = new DoubleAnimation
                    {
                        From = 0.0,
                        To = 0.8,
                        Duration = TimeSpan.FromSeconds(0.3)
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);

                // Restore after 7 seconds (instead of 5)
                _restoreTimer = new System.Windows.Threading.DispatcherTimer
                {
                    Interval = TimeSpan.FromSeconds(7)
                };
                _restoreTimer.Tick += (s, args) =>
                {
                    _restoreTimer.Stop();
                    RestoreOriginalText();
                };
                _restoreTimer.Start();
            }
        }

        /// <summary>
        /// Shows the Vogon DICOM poetry easter egg
        /// </summary>
        private void ShowVogonHaiku()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                // Cancel any existing restore timer
                _restoreTimer?.Stop();
                _isAnimating = true;

                // Dramatic fade out (but faster - 1s instead of 1.5s)
                var fadeOut = new System.Windows.Media.Animation.DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(1.0),
                    EasingFunction = new System.Windows.Media.Animation.PowerEase { EasingMode = System.Windows.Media.Animation.EasingMode.EaseIn }
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Clear and show poetry
                    infoText.Inlines.Clear();
                    infoText.FontFamily = new System.Windows.Media.FontFamily("Consolas");
                    infoText.Foreground = System.Windows.Media.Brushes.Green;

                    infoText.Inlines.Add(new Run("Oh freddled gruntbuggly, thy DICOM tags are to me\n"));
                    infoText.Inlines.Add(new Run("As plurdled gabbleblotchits on a lurgid JPEG tree!\n"));
                    infoText.Inlines.Add(new Run("\n"));
                    infoText.Inlines.Add(new Run("See how (0010,0010) PatientName doth slumber!"));

                    // Dramatic fade in (faster - 2s instead of 2.5s)
                    var fadeIn = new System.Windows.Media.Animation.DoubleAnimation
                    {
                        From = 0.0,
                        To = 1.0,
                        Duration = TimeSpan.FromSeconds(2.0),
                        EasingFunction = new System.Windows.Media.Animation.QuadraticEase { EasingMode = System.Windows.Media.Animation.EasingMode.EaseOut }
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);

                    // Subtle scale effect
                    var scaleTransform = new System.Windows.Media.ScaleTransform(1.0, 1.0);
                    infoText.RenderTransform = scaleTransform;
                    infoText.RenderTransformOrigin = new Point(0.5, 0.5);

                    var scaleAnimation = new System.Windows.Media.Animation.DoubleAnimation
                    {
                        From = 0.95,
                        To = 1.0,
                        Duration = TimeSpan.FromSeconds(2.0),
                        EasingFunction = new System.Windows.Media.Animation.ElasticEase
                        {
                            EasingMode = System.Windows.Media.Animation.EasingMode.EaseOut,
                            Oscillations = 1,
                            Springiness = 8
                        }
                    };
                    scaleTransform.BeginAnimation(System.Windows.Media.ScaleTransform.ScaleXProperty, scaleAnimation);
                    scaleTransform.BeginAnimation(System.Windows.Media.ScaleTransform.ScaleYProperty, scaleAnimation);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);

                // Reset after 13 seconds (instead of 10)
                _restoreTimer = new System.Windows.Threading.DispatcherTimer
                {
                    Interval = TimeSpan.FromSeconds(13)
                };
                _restoreTimer.Tick += (s, args) =>
                {
                    _restoreTimer.Stop();
                    RestoreOriginalText();
                };
                _restoreTimer.Start();
            }
        }

        /// <summary>
        /// Shows the ultimate secret - simplified without VogonPoetryWindow
        /// </summary>
        private void ShowUltimateSecret()
        {
            // Just show another Marvin quote for the 10th click
            ShowMarvinMessage();
        }

        /// <summary>
        /// Restores the original info text
        /// </summary>
        private void RestoreOriginalText()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                _isAnimating = true;

                // Faster fade out (0.5s instead of 1s)
                var fadeOut = new DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(0.5)
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Restore original text
                    infoText.Inlines.Clear();
                    infoText.ClearValue(TextBlock.FontFamilyProperty);
                    infoText.ClearValue(TextBlock.ForegroundProperty);
                    infoText.ClearValue(TextBlock.FontStyleProperty);
                    infoText.ClearValue(TextBlock.RenderTransformProperty);

                    infoText.Inlines.Add(new Run("CamBridge seamlessly converts JPEG images from Ricoh G900 II cameras"));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("to DICOM format, preserving patient data from QRBridge QR codes."));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("Designed for medical imaging workflows where reliability matters."));

                    // Faster fade in (0.5s instead of 1s)
                    var fadeIn = new DoubleAnimation
                    {
                        From = 0.0,
                        To = 0.8,
                        Duration = TimeSpan.FromSeconds(0.5)
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\DashboardPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\DashboardPage.xaml.cs
// Version: 0.7.21
// Description: MINIMAL Dashboard page code-behind
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System.Windows.Controls;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// MINIMAL Dashboard - No complex initialization!
    /// </summary>
    public partial class DashboardPage : Page
    {
        public DashboardPage()
        {
            InitializeComponent();
            // That's it! ViewModel comes from NavigationService
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\DeadLettersPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\DeadLettersPage.xaml.cs
// Version: 0.7.8
// Description: Simple error folder page - KISS approach!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Windows;
using System.Windows.Controls;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Simple error folder page - no more dead letters!
    /// </summary>
    public partial class DeadLettersPage : Page
    {
        private DeadLettersViewModel? _viewModel;

        public DeadLettersPage()
        {
            InitializeComponent();
            InitializeViewModel();
        }

        private void InitializeViewModel()
        {
            try
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<DeadLettersViewModel>();
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("DeadLettersViewModel loaded from DI container");
                }
                else
                {
                    // Fallback: Create directly - new ViewModel has parameterless constructor!
                    _viewModel = new DeadLettersViewModel();
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("DeadLettersViewModel created manually");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating DeadLettersViewModel: {ex.Message}");
                ShowError("Failed to initialize Error Folder View", ex.Message);
            }
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            if (_viewModel == null) return;

            try
            {
                // Refresh the error folder status
                if (_viewModel.RefreshCommand?.CanExecute(null) == true)
                {
                    await _viewModel.RefreshCommand.ExecuteAsync(null);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error refreshing error folder: {ex.Message}");
            }
        }

        private void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            // Clean up - remove event handler
            Loaded -= Page_Loaded;

            // Cleanup ViewModel
            _viewModel?.Cleanup();

            // Clear ViewModel reference
            _viewModel = null;
        }

        private void ShowError(string title, string message)
        {
            MessageBox.Show(
                $"{message}\n\nError files are now managed through Windows Explorer.",
                title,
                MessageBoxButton.OK,
                MessageBoxImage.Information);
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\LogViewerPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\LogViewerPage.xaml.cs
// Version: 0.8.9
// Description: Log viewer page with auto-initialization
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.ViewModels;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Interaction logic for LogViewerPage.xaml
    /// </summary>
    public partial class LogViewerPage : Page
    {
        public LogViewerPage()
        {
            InitializeComponent();

            // Initialize ViewModel when page loads
            this.Loaded += async (sender, e) =>
            {
                if (DataContext is LogViewerViewModel viewModel && !viewModel.IsLoading)
                {
                    await viewModel.InitializeAsync();
                }
            };
        }

        private void CorrelationHeader_Click(object sender, MouseButtonEventArgs e)
        {
            if (sender is Border border && border.Tag is CorrelationGroup group)
            {
                group.IsExpanded = !group.IsExpanded;
            }
        }

        private void StageHeader_Click(object sender, MouseButtonEventArgs e)
        {
            if (sender is Border border && border.Tag is StageGroup stage)
            {
                stage.IsExpanded = !stage.IsExpanded;
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\MappingEditorPage.xaml.cs
================================================================================

// src/CamBridge.Config/Views/MappingEditorPage.xaml.cs
// Version: 0.7.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Interaction logic for MappingEditorPage.xaml
    /// </summary>
    public partial class MappingEditorPage : Page
    {
        private MappingEditorViewModel? _viewModel;
        private Point _startPoint;
        private bool _isDragging;

        public MappingEditorPage()
        {
            InitializeComponent();
            DataContextChanged += OnDataContextChanged;
            Loaded += OnLoaded;
        }

        #region Rule Selection Event Handlers

        private void RuleItem_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            // When double-clicking a rule, open the DICOM tag browser
            if (_viewModel?.SelectedRule != null && _viewModel.CanEditCurrentSet)
            {
                _viewModel.BrowseDicomTagsCommand.Execute(null);
            }
        }

        #endregion

        private void OnDataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            _viewModel = DataContext as MappingEditorViewModel;
        }

        private async void OnLoaded(object sender, RoutedEventArgs e)
        {
            // Get the ViewModel from DI container if not already set
            if (_viewModel == null)
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<MappingEditorViewModel>();
                    DataContext = _viewModel;
                }
                else
                {
                    // Fallback: Create manually with required services
                    var logger = new Microsoft.Extensions.Logging.Abstractions.NullLogger<MappingEditorViewModel>();
                    var configService = new Services.ConfigurationService();
                    _viewModel = new MappingEditorViewModel(logger, configService);
                    DataContext = _viewModel;
                }
            }

            // Initialize the ViewModel
            if (_viewModel != null)
            {
                await _viewModel.InitializeAsync();
            }
        }

        #region Drag & Drop Event Handlers

        private void SourceField_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            _startPoint = e.GetPosition(null);
        }

        private void SourceField_MouseMove(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed && !_isDragging)
            {
                Point position = e.GetPosition(null);

                if (Math.Abs(position.X - _startPoint.X) > SystemParameters.MinimumHorizontalDragDistance ||
                    Math.Abs(position.Y - _startPoint.Y) > SystemParameters.MinimumVerticalDragDistance)
                {
                    _isDragging = true;

                    // Get the source field data
                    if (sender is FrameworkElement element && element.DataContext is MappingEditorViewModel.SourceFieldInfo fieldInfo)
                    {
                        // Create drag data
                        DataObject dragData = new DataObject("SourceField", fieldInfo);
                        DragDrop.DoDragDrop(element, dragData, DragDropEffects.Copy);
                    }

                    _isDragging = false;
                }
            }
        }

        private void MappingArea_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent("SourceField"))
            {
                e.Effects = DragDropEffects.Copy;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
            e.Handled = true;
        }

        private void MappingArea_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent("SourceField") && _viewModel != null)
            {
                var fieldInfo = e.Data.GetData("SourceField") as MappingEditorViewModel.SourceFieldInfo;
                if (fieldInfo != null && _viewModel.CanEditCurrentSet)
                {
                    // Add new mapping rule with the dropped field
                    _viewModel.AddRuleFromField(fieldInfo);
                }
            }
        }

        #endregion
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\PipelineConfigPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\PipelineConfigPage.xaml.cs
// Version: 0.8.10
// Description: Pipeline Configuration page - Code Behind with Output Path Handler

using System;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using System.Diagnostics;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Pipeline Configuration page - Zero Global Settings!
    /// NavigationService ALREADY injects the ViewModel, so we just need to initialize it
    /// </summary>
    [SupportedOSPlatform("windows")]
    public partial class PipelineConfigPage : Page
    {
        public PipelineConfigPage()
        {
            InitializeComponent();

            // Use Loaded event instead of OnInitialized to ensure NavigationService has done its job
            this.Loaded += Page_Loaded;
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            // Only run once
            this.Loaded -= Page_Loaded;

            Debug.WriteLine("=== PipelineConfigPage Loaded ===");

            // NavigationService should have already set our DataContext
            if (DataContext is PipelineConfigViewModel vm)
            {
                Debug.WriteLine("ViewModel found! Initializing...");
                try
                {
                    await vm.InitializeAsync();
                    Debug.WriteLine($"Initialization complete. Pipelines: {vm.Pipelines.Count}");
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Initialization failed: {ex.Message}");
                    MessageBox.Show(
                        $"Failed to load pipeline configuration:\n{ex.Message}",
                        "Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                }
            }
            else
            {
                Debug.WriteLine($"ERROR: DataContext is {DataContext?.GetType().Name ?? "null"} - expected PipelineConfigViewModel");

                // Fallback - try to get it ourselves
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    var viewModel = app.Host.Services.GetRequiredService<PipelineConfigViewModel>();
                    DataContext = viewModel;
                    await viewModel.InitializeAsync();
                }
            }
        }

        // NEW: Test PACS Connection Click Handler (Session 95 - Quick Fix)
        private async void TestPacsConnection_Click(object sender, RoutedEventArgs e)
        {
            var button = sender as Button;
            if (button == null) return;

            Debug.WriteLine("TestPacsConnection_Click called");

            try
            {
                button.IsEnabled = false;
                var originalContent = button.Content;
                button.Content = "Testing...";

                if (DataContext is PipelineConfigViewModel vm)
                {
                    Debug.WriteLine($"ViewModel found: {vm != null}");
                    Debug.WriteLine($"PacsConfigViewModel exists: {vm.PacsConfigViewModel != null}");
                    Debug.WriteLine($"SelectedPipeline: {vm.SelectedPipeline?.Name ?? "null"}");
                    Debug.WriteLine($"PacsConfiguration: {vm.SelectedPipeline?.PacsConfiguration != null}");

                    if (vm.PacsConfigViewModel != null &&
                        vm.SelectedPipeline?.PacsConfiguration != null)
                    {
                        // Initialize if needed
                        vm.PacsConfigViewModel.Initialize(vm.SelectedPipeline);

                        // Call test method directly
                        await vm.PacsConfigViewModel.TestPacsConnectionAsync();
                        Debug.WriteLine("Test completed");
                    }
                    else
                    {
                        MessageBox.Show(
                            "PACS configuration not available.\n\nPlease ensure:\n" +
                            "- A pipeline is selected\n" +
                            "- PACS upload is enabled\n" +
                            "- PACS settings are configured",
                            "Configuration Required",
                            MessageBoxButton.OK,
                            MessageBoxImage.Warning);
                    }
                }
                else
                {
                    Debug.WriteLine("DataContext is not PipelineConfigViewModel!");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"TestPacsConnection_Click error: {ex}");
                MessageBox.Show(
                    $"Error testing connection:\n{ex.Message}",
                    "Test Failed",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                // Restore button state
                if (button != null && DataContext is PipelineConfigViewModel viewModel)
                {
                    button.IsEnabled = viewModel.SelectedPipeline?.PacsConfiguration?.Enabled ?? false;
                    button.Content = "Test Connection (C-ECHO)";
                }
            }
        }

        // Browse button handlers
        private void BrowseWatchFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Watch Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.WatchSettings.Path = path;
                }
            });
        }

        // NEW: Output Path handler (Session 107 Fix)
        private void BrowseOutputPath_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Output Path", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.WatchSettings.OutputPath = path;
                }
            });
        }

        // RENAMED: Was BrowseOutputFolder_Click, now BrowseArchiveFolder_Click
        private void BrowseArchiveFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Archive Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.ProcessingOptions.ArchiveFolder = path;
                }
            });
        }

        private void BrowseErrorFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Error Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.ProcessingOptions.ErrorFolder = path;
                }
            });
        }

        private void BrowseLogFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Log Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm)
                {
                    vm.PipelineLogFolder = path;
                }
            });
        }

        private void BrowseFolder(string description, Action<string> setPath)
        {
            var dialog = new System.Windows.Forms.FolderBrowserDialog
            {
                Description = description,
                ShowNewFolderButton = true
            };

            if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                setPath(dialog.SelectedPath);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\ServiceControlPage.xaml.cs
================================================================================

// src/CamBridge.Config/Views/ServiceControlPage.xaml.cs
// Version: 0.8.6
// Modified: Session 96 - Fixed DI parameters

using System;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using CamBridge.Config.ViewModels;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Service control page for managing the Windows Service
    /// </summary>
    public partial class ServiceControlPage : Page
    {
        private ServiceControlViewModel? _viewModel;

        public ServiceControlPage()
        {
            InitializeComponent();

            try
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<ServiceControlViewModel>();
                    DataContext = _viewModel;
                    System.Diagnostics.Debug.WriteLine("ServiceControlViewModel loaded from DI container");
                }
                else
                {
                    // Fallback if DI not available
                    var serviceManager = new Services.ServiceManager();
                    var configurationService = new Services.ConfigurationService();

                    _viewModel = new ServiceControlViewModel(serviceManager, configurationService);
                    DataContext = _viewModel;
                    System.Diagnostics.Debug.WriteLine("ServiceControlViewModel created with fallback");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating ServiceControlViewModel: {ex.Message}");
                MessageBox.Show(
                    "Failed to initialize Service Control page. Some features may not be available.",
                    "Initialization Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning);
            }
        }

        private void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            _viewModel?.Cleanup();
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\VogonPoetryWindow.xaml.cs
================================================================================

// src\CamBridge.Config\Views\VogonPoetryWindow.xaml.cs
// Version: 0.5.26
// Fixed: Nullable warnings resolved

using System;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Imaging;
using System.Windows.Threading;

namespace CamBridge.Config.Views
{
    [SupportedOSPlatform("windows")]
    public partial class VogonPoetryWindow : Window
    {
        private Storyboard? _boingBallAnimation;
        private Storyboard? _scrollTextAnimation;
        private Storyboard? _rainbowAnimation;

        // Sprite animation members
        private WriteableBitmap? _ballBitmap;
        private DispatcherTimer? _spriteTimer;
        private int _currentFrame = 0;
        private const int TOTAL_FRAMES = 24;
        private bool _movingRight = true;
        private double _lastXPosition = 50;
        private byte[]? _pixelBuffer;
        private readonly int _stride = 100 * 4; // Width * BytesPerPixel

        public VogonPoetryWindow()
        {
            InitializeComponent();

            try
            {
                // Initialize sprite bitmap
                InitializeSpriteBitmap();

                // Start all the retro animations
                _boingBallAnimation = FindResource("BoingBallAnimation") as Storyboard;
                _scrollTextAnimation = FindResource("ScrollTextAnimation") as Storyboard;
                _rainbowAnimation = FindResource("RainbowAnimation") as Storyboard;

                if (_boingBallAnimation != null) _boingBallAnimation.Begin();
                if (_scrollTextAnimation != null) _scrollTextAnimation.Begin();
                if (_rainbowAnimation != null) _rainbowAnimation.Begin();

                // Initialize sprite animation timer
                _spriteTimer = new DispatcherTimer
                {
                    Interval = TimeSpan.FromMilliseconds(50) // 20 FPS
                };
                _spriteTimer.Tick += OnSpriteTimerTick;
                _spriteTimer.Start();

                // Track ball movement direction
                CompositionTarget.Rendering += TrackBallDirection;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing Vogon Poetry Window: {ex.Message}\n\n{ex.StackTrace}",
                    "Initialization Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void InitializeSpriteBitmap()
        {
            try
            {
                // Create a 100x100 WriteableBitmap
                _ballBitmap = new WriteableBitmap(100, 100, 96, 96, PixelFormats.Bgra32, null);
                _pixelBuffer = new byte[100 * 100 * 4]; // Width * Height * BytesPerPixel

                if (BoingBall == null)
                {
                    MessageBox.Show("BoingBall Image element not found!", "Error");
                    return;
                }

                BoingBall.Source = _ballBitmap;

                // Draw initial frame
                DrawBoingBallFrame(0);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing sprite: {ex.Message}", "Error");
            }
        }

        private void DrawBoingBallFrame(int frame)
        {
            if (_ballBitmap == null || _pixelBuffer == null) return;

            try
            {
                // Clear buffer to transparent
                Array.Clear(_pixelBuffer, 0, _pixelBuffer.Length);

                // Calculate rotation angle
                double angle = (frame / (double)TOTAL_FRAMES) * 360.0;
                double rotRad = angle * Math.PI / 180.0;

                int centerX = 50;
                int centerY = 50;
                int radius = 45;

                // Draw the ball
                for (int y = 0; y < 100; y++)
                {
                    for (int x = 0; x < 100; x++)
                    {
                        double dx = x - centerX;
                        double dy = y - centerY;
                        double distance = Math.Sqrt(dx * dx + dy * dy);

                        if (distance <= radius)
                        {
                            // Calculate 3D sphere coordinates
                            double z = Math.Sqrt(radius * radius - distance * distance);
                            double nx = dx / radius;
                            double ny = dy / radius;
                            double nz = z / radius;

                            // Map to texture coordinates with rotation
                            double u = Math.Atan2(ny, nx) + rotRad;
                            double v = Math.Acos(nz);

                            // Create checkerboard pattern
                            int checkerSize = 8;
                            int checkerU = (int)(u * radius / checkerSize) % 2;
                            int checkerV = (int)(v * radius / checkerSize) % 2;

                            // Add shading
                            double lightIntensity = 0.3 + 0.7 * Math.Max(0, nz);

                            int pixelIndex = (y * 100 + x) * 4;

                            if ((checkerU + checkerV) % 2 == 0)
                            {
                                // Red squares
                                _pixelBuffer[pixelIndex + 0] = (byte)(204 * lightIntensity); // B
                                _pixelBuffer[pixelIndex + 1] = 0; // G
                                _pixelBuffer[pixelIndex + 2] = 0; // R
                                _pixelBuffer[pixelIndex + 3] = 255; // A
                            }
                            else
                            {
                                // White squares
                                byte white = (byte)(255 * lightIntensity);
                                _pixelBuffer[pixelIndex + 0] = white; // B
                                _pixelBuffer[pixelIndex + 1] = white; // G
                                _pixelBuffer[pixelIndex + 2] = white; // R
                                _pixelBuffer[pixelIndex + 3] = 255; // A
                            }
                        }
                    }
                }

                // Write pixels to bitmap
                _ballBitmap.WritePixels(
                    new Int32Rect(0, 0, 100, 100),
                    _pixelBuffer,
                    _stride,
                    0);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error drawing frame: {ex.Message}");
            }
        }

        private void TrackBallDirection(object? sender, EventArgs e)
        {
            try
            {
                if (BoingBall == null) return;

                double currentX = Canvas.GetLeft(BoingBall);

                if (double.IsNaN(currentX))
                    return;

                if (currentX > _lastXPosition)
                {
                    _movingRight = true;
                }
                else if (currentX < _lastXPosition)
                {
                    _movingRight = false;
                }

                _lastXPosition = currentX;
            }
            catch
            {
                // Ignore errors
            }
        }

        private void OnSpriteTimerTick(object? sender, EventArgs e)
        {
            if (_movingRight)
            {
                _currentFrame = (_currentFrame + 1) % TOTAL_FRAMES;
            }
            else
            {
                _currentFrame = (_currentFrame - 1 + TOTAL_FRAMES) % TOTAL_FRAMES;
            }

            DrawBoingBallFrame(_currentFrame);
        }

        private void AppreciateButton_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show(
                "GURU MEDITATION #00000042.00000042\n\n" +
                "Your appreciation has been noted in sector 42.\n" +
                "Please insert disk 2 to continue.\n\n" +
                "Software Failure. Press left mouse button to continue.\n" +
                "Guru Meditation #DEADBEEF.CAFEBABE",
                "AMIGA SYSTEM ERROR",
                MessageBoxButton.OK,
                MessageBoxImage.Error);

            DialogResult = true;
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        protected override void OnClosed(EventArgs e)
        {
            try
            {
                _spriteTimer?.Stop();
                CompositionTarget.Rendering -= TrackBallDirection;

                _boingBallAnimation?.Stop();
                _scrollTextAnimation?.Stop();
                _rainbowAnimation?.Stop();
            }
            catch
            {
                // Ignore cleanup errors
            }

            base.OnClosed(e);
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\App.xaml
================================================================================

<!-- src\CamBridge.Config\App.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Application resources with global converter registration including IntToVisibilityConverter -->

<Application x:Class="CamBridge.Config.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:ui="http://schemas.modernwpf.com/2019"
             xmlns:conv="clr-namespace:CamBridge.Config.Converters"
             ShutdownMode="OnMainWindowClose">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ui:ThemeResources RequestedTheme="Light">
                    <ui:ThemeResources.ThemeDictionaries>
                        <ResourceDictionary x:Key="Light" ui:ThemeDictionary.Key="Light">
                            <!-- Blaue Akzentfarben -->
                            <Color x:Key="SystemAccentColor">#0078D4</Color>
                            <Color x:Key="SystemAccentColorLight1">#1A86E3</Color>
                            <Color x:Key="SystemAccentColorLight2">#4AA0E6</Color>
                            <Color x:Key="SystemAccentColorLight3">#6BB1EA</Color>
                            <Color x:Key="SystemAccentColorDark1">#005A9E</Color>
                            <Color x:Key="SystemAccentColorDark2">#004275</Color>
                            <Color x:Key="SystemAccentColorDark3">#002642</Color>
                        </ResourceDictionary>
                        <ResourceDictionary x:Key="Dark" ui:ThemeDictionary.Key="Dark">
                            <!-- Blaue Akzentfarben auch im Dark Mode -->
                            <Color x:Key="SystemAccentColor">#0078D4</Color>
                            <Color x:Key="SystemAccentColorLight1">#1A86E3</Color>
                            <Color x:Key="SystemAccentColorLight2">#4AA0E6</Color>
                            <Color x:Key="SystemAccentColorLight3">#6BB1EA</Color>
                            <Color x:Key="SystemAccentColorDark1">#005A9E</Color>
                            <Color x:Key="SystemAccentColorDark2">#004275</Color>
                            <Color x:Key="SystemAccentColorDark3">#002642</Color>
                        </ResourceDictionary>
                        <ResourceDictionary x:Key="HighContrast" ui:ThemeDictionary.Key="HighContrast">
                            <Color x:Key="SystemAccentColor">#0078D4</Color>
                        </ResourceDictionary>
                    </ui:ThemeResources.ThemeDictionaries>
                </ui:ThemeResources>
                <ui:XamlControlsResources />
            </ResourceDictionary.MergedDictionaries>
            <!-- Global Converters with both naming conventions -->
            <conv:BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
            <conv:BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
            <conv:InverseBooleanToVisibilityConverter x:Key="InverseBoolToVisibility"/>
            <conv:InverseBooleanToVisibilityConverter x:Key="InverseBooleanToVisibilityConverter"/>
            <conv:NullToVisibilityConverter x:Key="NullToVisibility"/>
            <conv:NullToVisibilityConverter x:Key="NullToVisibilityConverter"/>
            <conv:GreaterThanZeroConverter x:Key="GreaterThanZeroConverter"/>
            <conv:ZeroToVisibilityConverter x:Key="ZeroToVisibility"/>
            <conv:IntToVisibilityConverter x:Key="IntToVisibilityConverter"/>
            <conv:EnumToCollectionConverter x:Key="EnumToCollection"/>
            <conv:ServiceStatusToColorConverter x:Key="ServiceStatusToColor"/>
            <conv:TimeSpanToStringConverter x:Key="TimeSpanToString"/>
            <conv:FileSizeConverter x:Key="FileSizeConverter"/>

            <!-- Additional converters for Pipeline Config -->
            <conv:InverseBooleanConverter x:Key="InverseBooleanConverter"/>
            <conv:SecondsToMillisecondsConverter x:Key="SecondsToMillisecondsConverter"/>
            <conv:EnumToBooleanConverter x:Key="EnumToBooleanConverter"/>
            <conv:FileSelectConverter x:Key="FileSelectConverter"/>
            <conv:MultiBooleanAndConverter x:Key="MultiBooleanAndConverter"/>
            <conv:MultiBooleanOrConverter x:Key="MultiBooleanOrConverter"/>

            <!-- Alias for compatibility -->
            <conv:EnumToCollectionConverter x:Key="EnumToCollectionConverter"/>
            <conv:ServiceStatusToColorConverter x:Key="ServiceStatusToColorConverter"/>
            <conv:TimeSpanToStringConverter x:Key="TimeSpanToStringConverter"/>
        </ResourceDictionary>
    </Application.Resources>
</Application>


================================================================================
FILE: src\CamBridge.Config\MainWindow.xaml
================================================================================

<!-- src\CamBridge.Config\MainWindow.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Main window with perfect edge alignment -->
<Window x:Class="CamBridge.Config.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="http://schemas.modernwpf.com/2019"
        ui:WindowHelper.UseModernWindowStyle="True"
        Title="CamBridge Configuration"
        Height="800" Width="1200"
        MinHeight="600" MinWidth="900"
        WindowStartupLocation="CenterScreen">

    <Window.Resources>
        <!-- Override NavigationView default padding/margin -->
        <Style TargetType="ScrollViewer">
            <Setter Property="Padding" Value="0"/>
        </Style>
    </Window.Resources>

    <Grid>
        <ui:NavigationView x:Name="NavView" 
                          PaneDisplayMode="Left"
                          IsBackButtonVisible="Collapsed"
                          IsSettingsVisible="False"
                          OpenPaneLength="200"
                          CompactModeThresholdWidth="0"
                          ExpandedModeThresholdWidth="200"
                          SelectionChanged="NavigationView_SelectionChanged"
                          IsPaneToggleButtonVisible="False">

            <!-- Override ALL NavigationView margins -->
            <ui:NavigationView.Resources>
                <Thickness x:Key="NavigationViewContentMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewContentPresenterMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewPageContentMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewContentGridMargin">0,0,0,0</Thickness>
                <Thickness x:Key="NavigationViewTopPaneHeight">0</Thickness>
            </ui:NavigationView.Resources>

            <!-- Menu Items - NEUE REIHENFOLGE! -->
            <ui:NavigationView.MenuItems>
                <!-- 1. Dashboard -->
                <ui:NavigationViewItem Content="Dashboard" Tag="Dashboard">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Home"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 2. Pipeline -->
                <ui:NavigationViewItem Content="Pipeline Config" Tag="PipelineConfig">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Sync"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 3. Mapping -->
                <ui:NavigationViewItem Content="Mapping Editor" Tag="MappingEditor">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Edit"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 4. Error -->
                <ui:NavigationViewItem Content="Error Management" Tag="DeadLetters">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Important"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 5. Log Viewer -->
                <ui:NavigationViewItem Content="Log Viewer" Tag="LogViewer">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Document"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 6. Service -->
                <ui:NavigationViewItem Content="Service Control" Tag="ServiceControl">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Setting"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>

                <!-- 7. About -->
                <ui:NavigationViewItem Content="About" Tag="About">
                    <ui:NavigationViewItem.Icon>
                        <ui:SymbolIcon Symbol="Help"/>
                    </ui:NavigationViewItem.Icon>
                </ui:NavigationViewItem>
            </ui:NavigationView.MenuItems>

            <!-- Content Frame ohne negativen Margin -->
            <Frame x:Name="ContentFrame" 
                   NavigationUIVisibility="Hidden"
                   JournalOwnership="OwnsJournal"/>

        </ui:NavigationView>
    </Grid>
</Window>


================================================================================
FILE: src\CamBridge.Config\Dialogs\DicomTagBrowserDialog.xaml
================================================================================

<!-- src/CamBridge.Config/Dialogs/DicomTagBrowserDialog.xaml -->
<!-- Version: 0.7.25 -->
<!-- Enhanced with 3-column layout and NEMA-compliant descriptions -->
<Window x:Class="CamBridge.Config.Dialogs.DicomTagBrowserDialog"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="http://schemas.modernwpf.com/2019"
        ui:WindowHelper.UseModernWindowStyle="True"
        Title="Select DICOM Tag - NEMA PS3.6 Data Dictionary"
        Height="700"
        Width="1000"
        WindowStartupLocation="CenterOwner"
        PreviewKeyDown="Window_PreviewKeyDown">

    <Window.Resources>
        <Style x:Key="GroupHeaderStyle" TargetType="GroupItem">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="GroupItem">
                        <Expander IsExpanded="True" Margin="0,0,0,8">
                            <Expander.Header>
                                <TextBlock Text="{Binding Name}" 
                                           FontSize="14" 
                                           FontWeight="SemiBold"
                                           Foreground="{DynamicResource SystemControlForegroundBaseHighBrush}"/>
                            </Expander.Header>
                            <ItemsPresenter Margin="20,0,0,0"/>
                        </Expander>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <DataTemplate x:Key="TagItemTemplate">
            <Border Padding="8,4" 
                    Background="Transparent"
                    BorderThickness="0">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="120"/>
                        <ColumnDefinition Width="300"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>

                    <!-- Tag Number -->
                    <TextBlock Grid.Column="0" 
                               Text="{Binding TagString}" 
                               FontFamily="Consolas"
                               FontSize="13"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>

                    <!-- DICOM Name -->
                    <TextBlock Grid.Column="1" 
                               Text="{Binding Name}" 
                               Margin="8,0,0,0"
                               FontWeight="SemiBold"/>

                    <!-- NEMA Description / Examples -->
                    <TextBlock Grid.Column="2" 
                               Text="{Binding Description}" 
                               Margin="8,0,0,0"
                               Opacity="0.8"
                               TextTrimming="CharacterEllipsis">
                        <TextBlock.ToolTip>
                            <ToolTip MaxWidth="400">
                                <StackPanel>
                                    <TextBlock Text="{Binding Name}" FontWeight="Bold" Margin="0,0,0,4"/>
                                    <TextBlock Text="{Binding Description}" TextWrapping="Wrap"/>
                                    <TextBlock Margin="0,4,0,0">
                                        <Run Text="VR: " FontWeight="SemiBold"/>
                                        <Run Text="{Binding VR}"/>
                                        <Run Text=" (" FontWeight="SemiBold"/>
                                        <Run Text="{Binding VRDescription}"/>
                                        <Run Text=")" FontWeight="SemiBold"/>
                                    </TextBlock>
                                </StackPanel>
                            </ToolTip>
                        </TextBlock.ToolTip>
                    </TextBlock>
                </Grid>
            </Border>
        </DataTemplate>
    </Window.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Search Header -->
        <Border Grid.Row="0" 
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Padding="16">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <ui:SymbolIcon Grid.Column="0" 
                               Symbol="Find" 
                               Margin="0,0,12,0"
                               VerticalAlignment="Center"/>

                <ui:AutoSuggestBox Grid.Column="1"
                                   x:Name="SearchBox"
                                   PlaceholderText="Search by tag, name, module, or description..."
                                   Text="{Binding SearchText, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                                   QueryIcon="Find"
                                   KeyDown="SearchBox_KeyDown"/>

                <TextBlock Grid.Column="2"
                           VerticalAlignment="Center"
                           Margin="16,0,0,0"
                           Opacity="0.6">
                    <Run Text="DICOM Standard PS3.6"/>
                </TextBlock>
            </Grid>
        </Border>

        <!-- Column Headers -->
        <Border Grid.Row="1"
                VerticalAlignment="Top"
                Background="{DynamicResource SystemControlBackgroundListLowBrush}"
                BorderBrush="{DynamicResource SystemControlForegroundBaseLowBrush}"
                BorderThickness="0,0,0,1"
                Padding="8,4"
                Margin="0,0,0,0"
                Panel.ZIndex="1">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="140"/>
                    <ColumnDefinition Width="300"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <TextBlock Grid.Column="0" Text="Tag" FontWeight="SemiBold" Margin="20,0,0,0"/>
                <TextBlock Grid.Column="1" Text="Attribute Name" FontWeight="SemiBold" Margin="8,0,0,0"/>
                <TextBlock Grid.Column="2" Text="Description / Examples" FontWeight="SemiBold" Margin="8,0,0,0"/>
            </Grid>
        </Border>

        <!-- Tags List -->
        <ListView Grid.Row="1"
                  x:Name="TagsListView"
                  ItemsSource="{Binding TagsView}"
                  ItemTemplate="{StaticResource TagItemTemplate}"
                  SelectionMode="Single"
                  ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                  MouseDoubleClick="TagsListView_MouseDoubleClick"
                  Margin="0,30,0,0">
            <ListView.GroupStyle>
                <GroupStyle ContainerStyle="{StaticResource GroupHeaderStyle}"/>
            </ListView.GroupStyle>
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem" BasedOn="{StaticResource DefaultListViewItemStyle}">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                    <Setter Property="Padding" Value="0"/>
                </Style>
            </ListView.ItemContainerStyle>
        </ListView>

        <!-- Dialog Buttons -->
        <Border Grid.Row="2" 
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Padding="16">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <!-- Info Text -->
                <StackPanel Grid.Column="0" 
                            Orientation="Horizontal"
                            VerticalAlignment="Center">
                    <TextBlock Foreground="{DynamicResource SystemControlForegroundBaseMediumBrush}">
                        <Run Text="Selected: "/>
                    </TextBlock>
                    <TextBlock Text="{Binding ElementName=TagsListView, Path=SelectedItem.TagString}" 
                               FontFamily="Consolas"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                    <TextBlock Text="{Binding ElementName=TagsListView, Path=SelectedItem.Name}" 
                               Margin="8,0,0,0"/>
                </StackPanel>

                <!-- Buttons -->
                <Button Grid.Column="1" 
                        x:Name="OkButton"
                        Content="Select"
                        IsDefault="True"
                        Margin="0,0,8,0"
                        MinWidth="100"
                        Click="OkButton_Click"
                        Style="{StaticResource AccentButtonStyle}"/>

                <Button Grid.Column="2" 
                        x:Name="CancelButton"
                        Content="Cancel"
                        IsCancel="True"
                        MinWidth="100"
                        Click="CancelButton_Click"/>
            </Grid>
        </Border>
    </Grid>
</Window>


================================================================================
FILE: src\CamBridge.Config\Dialogs\TransformEditorDialog.xaml
================================================================================

<ui:ContentDialog x:Class="CamBridge.Config.Dialogs.TransformEditorDialog"
                   xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                   xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                   xmlns:ui="http://schemas.modernwpf.com/2019"
                   xmlns:converters="clr-namespace:CamBridge.Config.Converters"
                   Title="Edit Transformation"
                   PrimaryButtonText="OK"
                   SecondaryButtonText="Cancel"
                   DefaultButton="Primary"
                   Width="600">

    <ui:ContentDialog.Resources>
        <converters:TransformToDescriptionConverter x:Key="TransformToDescriptionConverter"/>
        <converters:TransformToSymbolConverter x:Key="TransformToSymbolConverter"/>
        <BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
    </ui:ContentDialog.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Current Mapping Info -->
        <Border Grid.Row="0" 
                Background="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"
                Padding="12"
                CornerRadius="4"
                Margin="0,0,0,16">
            <StackPanel>
                <TextBlock>
                    <Run Text="{Binding SourceField}" FontWeight="SemiBold"/>
                    <Run Text=" â†’ "/>
                    <Run Text="{Binding DicomTag}" Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                </TextBlock>
                <TextBlock Text="{Binding DicomTagName}" 
                           Opacity="0.7" 
                           FontSize="12"
                           Margin="0,2,0,0"/>
            </StackPanel>
        </Border>

        <!-- Transform Selection -->
        <TextBlock Grid.Row="1" 
                   Text="Select Transformation:"
                   FontWeight="SemiBold"
                   Margin="0,0,0,8"/>

        <ComboBox Grid.Row="2" 
                  ItemsSource="{Binding AvailableTransforms}"
                  SelectedItem="{Binding SelectedTransform}"
                  Margin="0,0,0,16">
            <ComboBox.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="30"/>
                            <ColumnDefinition Width="120"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>

                        <TextBlock Grid.Column="0"
                                   Text="{Binding Converter={StaticResource TransformToSymbolConverter}}"
                                   FontSize="14"/>

                        <TextBlock Grid.Column="1"
                                   Text="{Binding}"
                                   FontWeight="SemiBold"
                                   Margin="8,0,0,0"/>

                        <TextBlock Grid.Column="2"
                                   Text="{Binding Converter={StaticResource TransformToDescriptionConverter}}"
                                   Opacity="0.7"
                                   TextWrapping="Wrap"
                                   Margin="8,0,0,0"/>
                    </Grid>
                </DataTemplate>
            </ComboBox.ItemTemplate>
        </ComboBox>

        <!-- Preview Section -->
        <Border Grid.Row="3"
                BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                BorderThickness="1"
                CornerRadius="4"
                Padding="12"
                Margin="0,0,0,16"
                Visibility="{Binding ShowPreview, Converter={StaticResource BoolToVisibility}}">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Text="Preview:"
                               FontWeight="SemiBold"
                               Margin="0,0,0,8"/>

                    <!-- View Mode Selector -->
                    <StackPanel Grid.Column="1" 
                                Orientation="Horizontal"
                                Margin="0,0,0,8">
                        <RadioButton Content="Normal" 
                                     IsChecked="{Binding ShowNormalView}"
                                     Margin="0,0,8,0"/>
                        <RadioButton Content="Special Chars" 
                                     IsChecked="{Binding ShowSpecialCharsView}"
                                     Margin="0,0,8,0"/>
                        <RadioButton Content="HEX" 
                                     IsChecked="{Binding ShowHexView}"/>
                    </StackPanel>
                </Grid>

                <!-- Input Section -->
                <Grid Grid.Row="1">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Text="Test input:"
                               VerticalAlignment="Center"
                               Margin="0,0,8,0"/>

                    <TextBox Grid.Column="1"
                             Text="{Binding PreviewInput, UpdateSourceTrigger=PropertyChanged}"
                             ui:ControlHelper.PlaceholderText="Enter test value..."
                             FontFamily="Consolas"/>

                    <TextBlock Grid.Column="2"
                               Text="{Binding InputEncoding}"
                               FontSize="11"
                               Opacity="0.6"
                               VerticalAlignment="Center"
                               Margin="8,0,0,0"/>
                </Grid>

                <!-- Output Section -->
                <Grid Grid.Row="2" Margin="0,8,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Text="Result:"
                               VerticalAlignment="Center"
                               Margin="0,0,8,0"/>

                    <!-- Normal View -->
                    <TextBlock Grid.Column="1"
                               Text="{Binding PreviewOutput}"
                               FontFamily="Consolas"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"
                               Visibility="{Binding ShowNormalView, Converter={StaticResource BoolToVisibility}}"/>

                    <!-- Special Chars View -->
                    <TextBlock Grid.Column="1"
                               Text="{Binding PreviewOutputSpecialChars}"
                               FontFamily="Consolas"
                               FontWeight="SemiBold"
                               Foreground="{DynamicResource SystemControlForegroundAccentBrush}"
                               Visibility="{Binding ShowSpecialCharsView, Converter={StaticResource BoolToVisibility}}"/>

                    <!-- HEX View -->
                    <ScrollViewer Grid.Column="1"
                                  HorizontalScrollBarVisibility="Auto"
                                  VerticalScrollBarVisibility="Disabled"
                                  MaxHeight="60"
                                  Visibility="{Binding ShowHexView, Converter={StaticResource BoolToVisibility}}">
                        <TextBlock Text="{Binding PreviewOutputHex}"
                                   FontFamily="Consolas"
                                   FontSize="12"
                                   FontWeight="SemiBold"
                                   Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                    </ScrollViewer>

                    <TextBlock Grid.Column="2"
                               Text="{Binding OutputEncoding}"
                               FontSize="11"
                               Opacity="0.6"
                               VerticalAlignment="Center"
                               Margin="8,0,0,0"/>
                </Grid>

                <!-- Encoding Warning -->
                <Border Grid.Row="3"
                        Background="Orange"
                        CornerRadius="4"
                        Padding="8,4"
                        Margin="0,8,0,0"
                        Visibility="{Binding ShowEncodingWarning, Converter={StaticResource BoolToVisibility}}">
                    <TextBlock Text="{Binding EncodingWarning}"
                               Foreground="White"
                               FontSize="12"
                               TextWrapping="Wrap"/>
                </Border>
            </Grid>
        </Border>

        <!-- DICOM Compliance Info -->
        <Border Grid.Row="4"
                Background="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"
                Padding="8"
                CornerRadius="4"
                Margin="0,0,0,12"
                Visibility="{Binding ShowDicomInfo, Converter={StaticResource BoolToVisibility}}">
            <StackPanel>
                <TextBlock Text="DICOM Information:" 
                           FontWeight="SemiBold"
                           FontSize="12"
                           Margin="0,0,0,4"/>
                <TextBlock Text="{Binding DicomInfo}"
                           FontSize="11"
                           Opacity="0.8"
                           TextWrapping="Wrap"/>
            </StackPanel>
        </Border>

        <!-- Description -->
        <TextBlock Grid.Row="5"
                   Text="{Binding SelectedTransform, Converter={StaticResource TransformToDescriptionConverter}}"
                   TextWrapping="Wrap"
                   Opacity="0.7"
                   FontSize="12"/>
    </Grid>
</ui:ContentDialog>


================================================================================
FILE: src\CamBridge.Config\Views\AboutPage.xaml
================================================================================

<!-- src\CamBridge.Config\Views\AboutPage.xaml -->
<!-- Version: 0.7.8 -->
<!-- Description: About page with Marvin easter eggs and version display -->

<Page x:Class="CamBridge.Config.Views.AboutPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Title="About CamBridge"
      Focusable="True">

    <Grid>
        <!-- About Content -->
        <Grid>

            <StackPanel VerticalAlignment="Center" 
                        HorizontalAlignment="Center"
                        MaxWidth="600">

                <!-- Logo/Icon Area -->
                <Border Width="128" 
                        Height="128" 
                        CornerRadius="64"
                        Background="{DynamicResource SystemControlHighlightAccentBrush}"
                        Margin="0,0,0,24"
                        Cursor="Hand"
                        MouseLeftButtonDown="Logo_MouseLeftButtonDown">
                    <Border.ToolTip>
                        <ToolTip Content="DON'T PANIC" 
                                 FontFamily="Consolas"
                                 FontSize="10"/>
                    </Border.ToolTip>
                    <TextBlock Text="CB" 
                               FontSize="48" 
                               FontWeight="Bold"
                               HorizontalAlignment="Center"
                               VerticalAlignment="Center"
                               Foreground="White"/>
                </Border>

                <!-- Title -->
                <TextBlock Text="CamBridge" 
                           FontSize="48" 
                           FontWeight="Light"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,8"/>

                <!-- Version -->
                <TextBlock x:Name="VersionText"
                           Text="Version 0.7.8" 
                           FontSize="20" 
                           Opacity="0.8"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,4"/>

                <!-- Build Configuration -->
                <TextBlock x:Name="BuildConfigText"
                           FontSize="14" 
                           Opacity="0.6"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,24"/>

                <!-- Subtitle -->
                <TextBlock x:Name="SubtitleText"
                           FontSize="16" 
                           Opacity="0.7"
                           HorizontalAlignment="Center"
                           Margin="0,0,0,32">
                    <Run Text="JPEG to DICOM Converter for "/>
                    <Hyperlink NavigateUri="https://www.ricoh-imaging.co.jp/english/products/g900-2/"
                               RequestNavigate="Hyperlink_RequestNavigate"
                               Foreground="{DynamicResource SystemControlHighlightAccentBrush}">
                        <Run Text="Ricoh G900 II"/>
                    </Hyperlink>
                </TextBlock>

                <!-- Info -->
                <TextBlock x:Name="InfoText"
                           TextWrapping="Wrap" 
                           TextAlignment="Center"
                           Opacity="0.8"
                           LineHeight="24"
                           MinHeight="100">
                    <Run Text="CamBridge seamlessly converts JPEG images from Ricoh G900 II cameras"/>
                    <LineBreak/>
                    <Run Text="to DICOM format, preserving patient data from QRBridge QR codes."/>
                    <LineBreak/>
                    <LineBreak/>
                    <Run Text="Designed for medical imaging workflows where reliability matters."/>
                </TextBlock>

                <!-- Copyright -->
                <TextBlock Text="Â© 2025 Claude's Improbably Reliable Software Solutions" 
                           FontSize="12" 
                           Opacity="0.6"
                           HorizontalAlignment="Center"
                           Margin="0,32,0,16"/>

                <!-- Ultra subtle hint -->
                <TextBlock Text="42" 
                           FontSize="8" 
                           Opacity="0.1"
                           HorizontalAlignment="Center"
                           ToolTip="The Answer to the Ultimate Question of Life, the Universe, and Everything"/>
            </StackPanel>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: src\CamBridge.Config\Views\DashboardPage.xaml
================================================================================

<!-- src\CamBridge.Config\Views\DashboardPage.xaml -->
<!-- Version: 0.7.28 - Uniform Design with Perfect Edges -->
<Page x:Class="CamBridge.Config.Views.DashboardPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Title="Dashboard">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <TextBlock Text="Dashboard"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>
                <Button Content="Refresh" 
                        Command="{Binding RefreshCommand}"
                        HorizontalAlignment="Right"
                        VerticalAlignment="Center"
                        Margin="0,0,24,0"
                        MinWidth="80"/>
            </Grid>
        </Border>

        <!-- Content with margins on all sides -->
        <ScrollViewer Grid.Row="1" 
                      VerticalScrollBarVisibility="Auto"
                      HorizontalScrollBarVisibility="Disabled">
            <StackPanel Margin="16,16,16,0">
                <!-- Service Status Card -->
                <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                            BorderThickness="0"
                            CornerRadius="2"
                            Margin="0,0,0,16">
                    <Grid Margin="16,12">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <!-- Status Icon -->
                        <Ellipse Grid.Column="0"
         Width="16" Height="16"
         Margin="0,0,12,0"
         VerticalAlignment="Center">
                            <Ellipse.Fill>
                                <Binding Path="ServiceStatus" Converter="{StaticResource ServiceStatusToColorConverter}"/>
                            </Ellipse.Fill>
                            <Ellipse.ToolTip>
                                <ToolTip>
                                    <StackPanel>
                                        <TextBlock FontWeight="Bold" Text="{Binding ServiceStatus, StringFormat='Status: {0}'}"/>
                                        <TextBlock FontSize="11" Opacity="0.8">
                                            <TextBlock.Style>
                                                <Style TargetType="TextBlock">
                                                    <Style.Triggers>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="Running">
                                                            <Setter Property="Text" Value="Service is running normally"/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="Online">
                                                            <Setter Property="Text" Value="Service is online and operational"/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="Stopped">
                                                            <Setter Property="Text" Value="Service is stopped"/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="Offline">
                                                            <Setter Property="Text" Value="Service is offline"/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="StartPending">
                                                            <Setter Property="Text" Value="Service is starting..."/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="StopPending">
                                                            <Setter Property="Text" Value="Service is stopping..."/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="Paused">
                                                            <Setter Property="Text" Value="Service is paused"/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="Error">
                                                            <Setter Property="Text" Value="Service encountered an error"/>
                                                        </DataTrigger>
                                                        <DataTrigger Binding="{Binding ServiceStatus}" Value="NotInstalled">
                                                            <Setter Property="Text" Value="Service is not installed"/>
                                                        </DataTrigger>
                                                    </Style.Triggers>
                                                </Style>
                                            </TextBlock.Style>
                                        </TextBlock>
                                        <TextBlock FontSize="10" Opacity="0.6" Margin="0,4,0,0">
                    <Run Text="Green = Running"/>
                    <LineBreak/>
                    <Run Text="Yellow = Stopped"/>
                    <LineBreak/>
                    <Run Text="Orange = Transitioning"/>
                    <LineBreak/>
                    <Run Text="Red = Error/Not installed"/>
                                        </TextBlock>
                                    </StackPanel>
                                </ToolTip>
                            </Ellipse.ToolTip>
                        </Ellipse>

                        <!-- Status Text -->
                        <StackPanel Grid.Column="1" VerticalAlignment="Center">
                            <TextBlock Text="{Binding ServiceStatus, StringFormat='Service: {0}'}" 
                                       FontSize="16" 
                                       FontWeight="SemiBold"/>
                            <StackPanel Orientation="Horizontal" Opacity="0.7">
                                <TextBlock Text="{Binding UptimeText}" Margin="0,0,16,0"/>
                                <TextBlock Text="{Binding VersionText}"/>
                            </StackPanel>
                            <TextBlock Text="{Binding LastUpdate, StringFormat='Last update: {0:HH:mm:ss}'}" 
                                       FontSize="11" 
                                       Opacity="0.5"/>
                        </StackPanel>

                        <!-- Start Button -->
                        <Button Grid.Column="2"
                                Content="Start Service"
                                Command="{Binding StartServiceCommand}"
                                VerticalAlignment="Center"
                                MinWidth="100"
                                Visibility="{Binding IsServiceRunning, Converter={StaticResource InverseBooleanToVisibilityConverter}}"/>
                    </Grid>
                </Border>

                <!-- Pipelines Section -->
                <TextBlock Text="Pipelines"
                           FontSize="18"
                           FontWeight="SemiBold"
                           Margin="0,0,0,8"/>

                <!-- Pipeline List -->
                <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        BorderThickness="0"
                        CornerRadius="2">
                    <ItemsControl ItemsSource="{Binding PipelineStatuses}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Border BorderThickness="0,0,0,1"
                                        BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}">
                                    <Grid Margin="16,12">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="Auto"/>
                                        </Grid.ColumnDefinitions>

                                        <!-- Status -->
                                        <Ellipse Grid.Column="0"
                                                 Width="10" Height="10"
                                                 Margin="0,0,12,0"
                                                 VerticalAlignment="Center">
                                            <Ellipse.Style>
                                                <Style TargetType="Ellipse">
                                                    <Setter Property="Fill" Value="#999"/>
                                                    <Style.Triggers>
                                                        <DataTrigger Binding="{Binding IsEnabled}" Value="True">
                                                            <Setter Property="Fill" Value="#28A745"/>
                                                        </DataTrigger>
                                                    </Style.Triggers>
                                                </Style>
                                            </Ellipse.Style>
                                        </Ellipse>

                                        <!-- Name & Path -->
                                        <StackPanel Grid.Column="1" VerticalAlignment="Center">
                                            <TextBlock Text="{Binding PipelineName}" 
                                                       FontWeight="SemiBold"
                                                       FontSize="14"/>
                                            <TextBlock Text="{Binding WatchFolder}" 
                                                       FontSize="12" 
                                                       Opacity="0.7"
                                                       TextTrimming="CharacterEllipsis"/>
                                        </StackPanel>

                                        <!-- Stats -->
                                        <StackPanel Grid.Column="2" 
                                                    Orientation="Horizontal"
                                                    VerticalAlignment="Center">
                                            <TextBlock Margin="0,0,16,0"
                                                       FontSize="13"
                                                       Opacity="0.8">
                                                <Run Text="Processed: "/>
                                                <Run Text="{Binding ProcessedToday}"/>
                                            </TextBlock>
                                            <TextBlock Margin="0,0,16,0"
                                                       FontSize="13"
                                                       Opacity="0.8">
                                                <Run Text="Queue: "/>
                                                <Run Text="{Binding QueueLength}"/>
                                            </TextBlock>
                                            <StackPanel Orientation="Horizontal"
                                                        Visibility="{Binding ErrorsToday, Converter={StaticResource GreaterThanZeroConverter}}">
                                                <TextBlock Text="Errors: " Opacity="0.7" FontSize="13"/>
                                                <TextBlock Text="{Binding ErrorsToday}" Foreground="OrangeRed" FontWeight="SemiBold" FontSize="13"/>
                                            </StackPanel>
                                        </StackPanel>
                                    </Grid>
                                </Border>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </Border>
            </StackPanel>
        </ScrollViewer>

        <!-- Loading Overlay -->
        <ui:ProgressBar Grid.RowSpan="2"
                        IsIndeterminate="True"
                        Visibility="{Binding IsLoading, Converter={StaticResource BooleanToVisibilityConverter}}"
                        VerticalAlignment="Top"/>
    </Grid>
</Page>


================================================================================
FILE: src\CamBridge.Config\Views\DeadLettersPage.xaml
================================================================================

<!-- src\CamBridge.Config\Views\DeadLettersPage.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Error Files Page - Minimal design -->

<Page x:Class="CamBridge.Config.Views.DeadLettersPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Loaded="Page_Loaded"
      Unloaded="Page_Unloaded">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="Error Management"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>

                <Button Grid.Column="1"
                        Content="Refresh" 
                        Command="{Binding RefreshCommand}"
                        HorizontalAlignment="Right"
                        VerticalAlignment="Center"
                        Margin="0,0,24,0"
                        MinWidth="80"/>
            </Grid>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="1" Margin="16,16,16,0">
            <!-- Info Card Only -->
            <Border VerticalAlignment="Top"
                    Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                    BorderThickness="0"
                    CornerRadius="2"
                    Padding="16">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <ui:SymbolIcon Symbol="Folder" 
                                   Width="48" 
                                   Height="48"
                                   Margin="0,0,16,0"/>

                    <StackPanel Grid.Column="1" VerticalAlignment="Center">
                        <TextBlock FontSize="16" FontWeight="SemiBold">
                            <TextBlock.Style>
                                <Style TargetType="TextBlock">
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding ErrorFileCount}" Value="0">
                                            <Setter Property="Text" Value="No Error Files"/>
                                            <Setter Property="Foreground" Value="#28A745"/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                    <Setter Property="Text" Value="{Binding ErrorFileCount, StringFormat='{}{0} Error Files Found'}"/>
                                    <Setter Property="Foreground" Value="#FFC107"/>
                                </Style>
                            </TextBlock.Style>
                        </TextBlock>
                        <TextBlock FontSize="12" Opacity="0.7" Margin="0,4,0,0">
                            <Run Text="Error folder: "/>
                            <Run Text="{Binding ErrorFolder}" FontFamily="Consolas"/>
                        </TextBlock>
                    </StackPanel>

                    <Button Grid.Column="2"
                            Command="{Binding OpenErrorFolderCommand}"
                            VerticalAlignment="Center"
                            MinWidth="140">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="OpenLocal" Margin="0,0,8,0"/>
                            <TextBlock Text="Open Folder"/>
                        </StackPanel>
                    </Button>
                </Grid>
            </Border>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: src\CamBridge.Config\Views\LogViewerPage.xaml
================================================================================

<!-- src\CamBridge.Config\Views\LogViewerPage.xaml -->
<!-- Version: 0.8.9 -->
<!-- Description: Enhanced log viewer with Triple Filter UI and Compact Tree View -->
<!-- Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions -->

<Page x:Class="CamBridge.Config.Views.LogViewerPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:CamBridge.Config.Views"
      xmlns:viewmodels="clr-namespace:CamBridge.Config.ViewModels"
      xmlns:converters="clr-namespace:CamBridge.Config.Converters"
      mc:Ignorable="d" 
      d:DesignHeight="600" d:DesignWidth="1000"
      d:DataContext="{d:DesignInstance Type=viewmodels:LogViewerViewModel}"
      Title="Log Viewer">

    <Page.Resources>
        <converters:BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
        <converters:InverseBooleanToVisibilityConverter x:Key="InverseBoolToVisibility"/>
        <converters:CombineStagesConverter x:Key="CombineStagesConverter"/>
        <converters:ColorToBrushConverter x:Key="ColorToBrushConverter"/>

        <!-- Style for expandable group headers -->
        <Style x:Key="ExpandableGroupHeader" TargetType="Border">
            <Setter Property="Background" Value="#F5F5F5"/>
            <Setter Property="BorderBrush" Value="#E0E0E0"/>
            <Setter Property="BorderThickness" Value="0,0,0,1"/>
            <Setter Property="Padding" Value="8,4"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="#E8E8E8"/>
                </Trigger>
            </Style.Triggers>
        </Style>

        <!-- Context Menu for Copy/Export -->
        <ContextMenu x:Key="TreeContextMenu">
            <MenuItem Header="Copy All" Command="{Binding CopySelectedCommand}">
                <MenuItem.Icon>
                    <TextBlock Text="ðŸ“‹" FontSize="14"/>
                </MenuItem.Icon>
            </MenuItem>
            <MenuItem Header="Export..." Command="{Binding ExportLogCommand}">
                <MenuItem.Icon>
                    <TextBlock Text="ðŸ’¾" FontSize="14"/>
                </MenuItem.Icon>
            </MenuItem>
        </ContextMenu>

        <!-- DataTemplate for log entries in tree view -->
        <DataTemplate x:Key="LogEntryTemplate" DataType="{x:Type viewmodels:LogEntry}">
            <Border Padding="24,2,8,2" BorderThickness="0,0,0,1" BorderBrush="#F0F0F0">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="100"/>
                        <ColumnDefinition Width="40"/>
                        <ColumnDefinition Width="60"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="80"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Grid.Column="0" Text="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}" 
                               FontFamily="Consolas" FontSize="11" Opacity="0.7"/>

                    <TextBlock Grid.Column="1" Text="{Binding LevelText}" 
                               FontWeight="Bold" FontFamily="Consolas"
                               Foreground="{Binding LevelColor}"/>

                    <TextBlock Grid.Column="2" Text="{Binding StageIcon}" 
                               FontSize="14" VerticalAlignment="Center"/>

                    <TextBlock Grid.Column="3" Text="{Binding Message}" 
                               TextWrapping="Wrap" Margin="8,0,0,0"/>

                    <TextBlock Grid.Column="4" Text="{Binding FormattedDuration}" 
                               FontFamily="Consolas" FontSize="11" Opacity="0.7"
                               HorizontalAlignment="Right"/>
                </Grid>
            </Border>
        </DataTemplate>
    </Page.Resources>

    <DockPanel>
        <!-- Header with controls -->
        <Border DockPanel.Dock="Top" Padding="16" Background="White"
                BorderBrush="#E0E0E0" BorderThickness="0,0,0,1">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <!-- Title and Stats -->
                <DockPanel Grid.Row="0">
                    <StackPanel Orientation="Horizontal" DockPanel.Dock="Left">
                        <TextBlock Text="ðŸ“‹" FontSize="28" VerticalAlignment="Center"/>
                        <TextBlock Text="Log Viewer" FontSize="24" FontWeight="Bold" 
                                   VerticalAlignment="Center" Margin="8,0,0,0"/>

                        <!-- Tree/Flat Toggle -->
                        <ToggleButton IsChecked="{Binding IsTreeViewEnabled}" 
                                      Margin="16,0,0,0" VerticalAlignment="Center"
                                      ToolTip="Toggle tree view" Padding="8,4">
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="ðŸŒ³" FontSize="16" Margin="0,0,4,0"/>
                                <TextBlock Text="Tree View"/>
                            </StackPanel>
                        </ToggleButton>
                    </StackPanel>

                    <StackPanel Orientation="Horizontal" DockPanel.Dock="Right" 
                                HorizontalAlignment="Right" VerticalAlignment="Center">
                        <TextBlock Text="Last Update:" Opacity="0.7" Margin="0,0,4,0"/>
                        <TextBlock Text="{Binding LastUpdateTime, StringFormat='HH:mm:ss'}" FontWeight="Bold"/>
                        <TextBlock Text="Lines:" Opacity="0.7" Margin="16,0,4,0"/>
                        <TextBlock Text="{Binding DisplayedLineCount}" FontWeight="Bold"/>
                        <TextBlock Text="/" Opacity="0.5"/>
                        <TextBlock Text="{Binding TotalLineCount}" Opacity="0.7"/>
                    </StackPanel>
                </DockPanel>

                <!-- Pipeline Selection -->
                <Grid Grid.Row="1" Margin="0,8,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <TextBlock Grid.Column="0" Text="Pipelines:" VerticalAlignment="Center" Margin="0,0,8,0"/>

                    <ComboBox Grid.Column="1" ItemsSource="{Binding PipelineSelections}"
                              MaxDropDownHeight="300">
                        <ComboBox.ItemTemplate>
                            <DataTemplate>
                                <Border Padding="4,2" MinHeight="24">
                                    <CheckBox IsChecked="{Binding IsSelected}" 
                                              Content="{Binding Name}"
                                              VerticalAlignment="Center"/>
                                </Border>
                            </DataTemplate>
                        </ComboBox.ItemTemplate>
                        <ComboBox.ItemContainerStyle>
                            <Style TargetType="ComboBoxItem">
                                <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                                <Setter Property="MinHeight" Value="24"/>
                                <Setter Property="Padding" Value="2"/>
                            </Style>
                        </ComboBox.ItemContainerStyle>
                        <ComboBox.Style>
                            <Style TargetType="ComboBox">
                                <Setter Property="MinWidth" Value="200"/>
                                <Style.Triggers>
                                    <Trigger Property="IsDropDownOpen" Value="True">
                                        <Setter Property="MinWidth" Value="250"/>
                                    </Trigger>
                                </Style.Triggers>
                            </Style>
                        </ComboBox.Style>
                        <ComboBox.Text>
                            <MultiBinding StringFormat="{}{0} pipeline(s) selected" Mode="OneWay">
                                <Binding Path="SelectedPipelineCount" Mode="OneWay"/>
                            </MultiBinding>
                        </ComboBox.Text>
                    </ComboBox>

                    <StackPanel Grid.Column="2" Orientation="Horizontal" Margin="16,0,0,0">
                        <!-- Tree View Controls -->
                        <Button Command="{Binding ExpandAllCommand}" 
                                ToolTip="Expand all groups" 
                                Margin="0,0,4,0" 
                                Padding="6,4"
                                Visibility="{Binding IsTreeViewEnabled, Converter={StaticResource BoolToVisibility}}">
                            <TextBlock Text="âŠ•" FontSize="14"/>
                        </Button>

                        <Button Command="{Binding CollapseAllCommand}" 
                                ToolTip="Collapse all groups" 
                                Margin="0,0,8,0" 
                                Padding="6,4"
                                Visibility="{Binding IsTreeViewEnabled, Converter={StaticResource BoolToVisibility}}">
                            <TextBlock Text="âŠ–" FontSize="14"/>
                        </Button>

                        <!-- Log Actions -->
                        <Button Command="{Binding RefreshCommand}" 
                                ToolTip="Refresh logs" 
                                Margin="0,0,4,0" 
                                Padding="6,4">
                            <TextBlock Text="ðŸ”„" FontSize="14"/>
                        </Button>

                        <Button Command="{Binding ClearLogCommand}" 
                                ToolTip="Clear all logs" 
                                Margin="0,0,4,0" 
                                Padding="6,4">
                            <TextBlock Text="ðŸ—‘ï¸" FontSize="14"/>
                        </Button>

                        <Button Command="{Binding ExportLogCommand}" 
                                ToolTip="Export logs to file" 
                                Margin="0,0,4,0" 
                                Padding="6,4">
                            <TextBlock Text="ðŸ’¾" FontSize="14"/>
                        </Button>

                        <Button Command="{Binding OpenLogFolderCommand}" 
                                ToolTip="Open log folder" 
                                Margin="0,0,4,0" 
                                Padding="6,4">
                            <TextBlock Text="ðŸ“" FontSize="14"/>
                        </Button>

                        <Button Command="{Binding CopySelectedCommand}" 
                                ToolTip="Copy to clipboard" 
                                Margin="0,0,4,0" 
                                Padding="6,4">
                            <TextBlock Text="ðŸ“‹" FontSize="14"/>
                        </Button>
                    </StackPanel>
                </Grid>

                <!-- Filters -->
                <Grid Grid.Row="2" Margin="0,8,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <!-- Triple Filter Box -->
                    <StackPanel Grid.Column="0" Orientation="Horizontal">
                        <!-- Filter 1 -->
                        <TextBox Width="180" 
                                 Text="{Binding Filter1, UpdateSourceTrigger=PropertyChanged}"
                                 VerticalContentAlignment="Center" 
                                 Padding="4"
                                 Margin="0,0,4,0">
                            <TextBox.ToolTip>
                                <ToolTip>
                                    <TextBlock>
                                        <TextBlock.Text>Filter 1 - Wildcards supported:&#x0a;* = any characters&#x0a;? = single character&#x0a;Example: *Schmidt*</TextBlock.Text>
                                    </TextBlock>
                                </ToolTip>
                            </TextBox.ToolTip>
                            <TextBox.Tag>Filter 1...</TextBox.Tag>
                        </TextBox>

                        <TextBlock Text="â†’" VerticalAlignment="Center" Margin="4,0" Opacity="0.5" FontSize="16"/>

                        <!-- Filter 2 -->
                        <TextBox Width="180" 
                                 Text="{Binding Filter2, UpdateSourceTrigger=PropertyChanged}"
                                 VerticalContentAlignment="Center" 
                                 Padding="4"
                                 Margin="0,0,4,0">
                            <TextBox.ToolTip>
                                <ToolTip>
                                    <TextBlock>
                                        <TextBlock.Text>Filter 2 - All filters must match&#x0a;Example: DICOM</TextBlock.Text>
                                    </TextBlock>
                                </ToolTip>
                            </TextBox.ToolTip>
                            <TextBox.Tag>Filter 2...</TextBox.Tag>
                        </TextBox>

                        <TextBlock Text="â†’" VerticalAlignment="Center" Margin="4,0" Opacity="0.5" FontSize="16"/>

                        <!-- Filter 3 -->
                        <TextBox Width="180" 
                                 Text="{Binding Filter3, UpdateSourceTrigger=PropertyChanged}"
                                 VerticalContentAlignment="Center" 
                                 Padding="4"
                                 Margin="0,0,4,0">
                            <TextBox.ToolTip>
                                <ToolTip>
                                    <TextBlock>
                                        <TextBlock.Text>Filter 3 - Chain filters for precision&#x0a;Example: *.dcm</TextBlock.Text>
                                    </TextBlock>
                                </ToolTip>
                            </TextBox.ToolTip>
                            <TextBox.Tag>Filter 3...</TextBox.Tag>
                        </TextBox>

                        <!-- Clear Filters Button -->
                        <Button Command="{Binding ClearFiltersCommand}" 
                                ToolTip="Clear all filters" 
                                Margin="4,0,0,0" 
                                Padding="6,4">
                            <TextBlock Text="âœ–" FontSize="14"/>
                        </Button>

                        <!-- Legacy Search Box (hidden but kept for compatibility) -->
                        <TextBox Text="{Binding SearchText, UpdateSourceTrigger=PropertyChanged}"
                                 Visibility="Collapsed"/>
                    </StackPanel>

                    <!-- Level Filters -->
                    <StackPanel Grid.Column="1" Orientation="Horizontal" Margin="16,0,0,0">
                        <TextBlock Text="Levels:" VerticalAlignment="Center" Margin="0,0,8,0"/>

                        <ToggleButton IsChecked="{Binding ShowDebug}" ToolTip="Debug" Padding="4,2" Margin="2,0">
                            <TextBlock Text="DBG" FontFamily="Consolas" FontWeight="Bold" Foreground="#808080"/>
                        </ToggleButton>

                        <ToggleButton IsChecked="{Binding ShowInformation}" ToolTip="Information" Padding="4,2" Margin="2,0">
                            <TextBlock Text="INF" FontFamily="Consolas" FontWeight="Bold" Foreground="#0078D4"/>
                        </ToggleButton>

                        <ToggleButton IsChecked="{Binding ShowWarning}" ToolTip="Warning" Padding="4,2" Margin="2,0">
                            <TextBlock Text="WRN" FontFamily="Consolas" FontWeight="Bold" Foreground="#FFA500"/>
                        </ToggleButton>

                        <ToggleButton IsChecked="{Binding ShowError}" ToolTip="Error" Padding="4,2" Margin="2,0">
                            <TextBlock Text="ERR" FontFamily="Consolas" FontWeight="Bold" Foreground="#FF0000"/>
                        </ToggleButton>

                        <ToggleButton IsChecked="{Binding ShowCritical}" ToolTip="Critical" Padding="4,2" Margin="2,0">
                            <TextBlock Text="CRT" FontFamily="Consolas" FontWeight="Bold" Foreground="#8B0000"/>
                        </ToggleButton>
                    </StackPanel>

                    <!-- Auto-scroll -->
                    <CheckBox Grid.Column="2" IsChecked="{Binding IsAutoScrollEnabled}" 
                              Content="Auto-scroll" VerticalAlignment="Center" Margin="16,0,0,0"/>
                </Grid>
            </Grid>
        </Border>

        <!-- Progress bar -->
        <ProgressBar DockPanel.Dock="Top" IsIndeterminate="True" Height="2"
                     Visibility="{Binding IsLoading, Converter={StaticResource BoolToVisibility}}"/>

        <!-- Main content area -->
        <Grid>
            <!-- Compact Tree View (when enabled) -->
            <ScrollViewer x:Name="TreeScrollViewer"
                          Visibility="{Binding IsTreeViewEnabled, Converter={StaticResource BoolToVisibility}}"
                          VerticalScrollBarVisibility="Auto" 
                          HorizontalScrollBarVisibility="Auto">

                <!-- Compact tree view with performance optimizations -->
                <TreeView x:Name="LogTreeView"
                          ItemsSource="{Binding CorrelationGroups}"
                          VirtualizingPanel.IsVirtualizing="True"
                          VirtualizingPanel.VirtualizationMode="Recycling"
                          ScrollViewer.CanContentScroll="True"
                          Background="Transparent"
                          BorderThickness="0">

                    <!-- Compact item container style -->
                    <TreeView.ItemContainerStyle>
                        <Style TargetType="TreeViewItem">
                            <Setter Property="Padding" Value="2,1"/>
                            <Setter Property="Margin" Value="0"/>
                            <Setter Property="FontSize" Value="11"/>
                            <Setter Property="IsExpanded" Value="{Binding IsExpanded, Mode=TwoWay}"/>

                            <!-- Context Menu for Copy -->
                            <Setter Property="ContextMenu">
                                <Setter.Value>
                                    <ContextMenu>
                                        <MenuItem Header="Copy Line" 
                                                  Command="{Binding DataContext.CopyLineCommand, RelativeSource={RelativeSource AncestorType=TreeView}}"
                                                  CommandParameter="{Binding}"/>
                                        <MenuItem Header="Copy Group" 
                                                  Command="{Binding DataContext.CopyGroupCommand, RelativeSource={RelativeSource AncestorType=TreeView}}"
                                                  CommandParameter="{Binding}"/>
                                        <Separator/>
                                        <MenuItem Header="Expand All in Group" 
                                                  Command="{Binding DataContext.ExpandGroupCommand, RelativeSource={RelativeSource AncestorType=TreeView}}"
                                                  CommandParameter="{Binding}"/>
                                    </ContextMenu>
                                </Setter.Value>
                            </Setter>
                        </Style>
                    </TreeView.ItemContainerStyle>

                    <!-- Template for correlation groups -->
                    <TreeView.ItemTemplate>
                        <HierarchicalDataTemplate DataType="{x:Type viewmodels:CorrelationGroup}">
                            <!-- Bind to combined entries collection -->
                            <HierarchicalDataTemplate.ItemsSource>
                                <MultiBinding Converter="{StaticResource CombineStagesConverter}">
                                    <Binding Path="Stages"/>
                                    <Binding Path="UngroupedEntries"/>
                                </MultiBinding>
                            </HierarchicalDataTemplate.ItemsSource>

                            <!-- Compact group header -->
                            <Border BorderBrush="#E0E0E0" BorderThickness="0,0,0,1" 
                                    Padding="4,2" Background="{Binding StatusColor, Converter={StaticResource ColorToBrushConverter}}">
                                <Grid>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="16"/>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="Auto"/>
                                        <ColumnDefinition Width="Auto"/>
                                    </Grid.ColumnDefinitions>

                                    <!-- Expand/Collapse icon -->
                                    <TextBlock Grid.Column="0" FontFamily="Consolas" VerticalAlignment="Center">
                                        <TextBlock.Style>
                                            <Style TargetType="TextBlock">
                                                <Style.Triggers>
                                                    <DataTrigger Binding="{Binding IsExpanded}" Value="False">
                                                        <Setter Property="Text" Value="â–¶"/>
                                                    </DataTrigger>
                                                    <DataTrigger Binding="{Binding IsExpanded}" Value="True">
                                                        <Setter Property="Text" Value="â–¼"/>
                                                    </DataTrigger>
                                                </Style.Triggers>
                                            </Style>
                                        </TextBlock.Style>
                                    </TextBlock>

                                    <!-- Status icon -->
                                    <TextBlock Grid.Column="1" Text="{Binding StatusIcon}" 
                                               FontSize="12" Margin="4,0" VerticalAlignment="Center"/>

                                    <!-- Correlation info -->
                                    <TextBlock Grid.Column="2" VerticalAlignment="Center">
                                        <Run Text="{Binding CorrelationId}" FontWeight="SemiBold"/>
                                        <Run Text=" - "/>
                                        <Run Text="{Binding Pipeline}" Foreground="#666"/>
                                    </TextBlock>

                                    <!-- Timing -->
                                    <TextBlock Grid.Column="3" Text="{Binding StartTime, StringFormat='HH:mm:ss'}" 
                                               FontFamily="Consolas" FontSize="10" 
                                               Foreground="#666" Margin="8,0" VerticalAlignment="Center"/>

                                    <!-- Duration -->
                                    <TextBlock Grid.Column="4" Text="{Binding DurationText}" 
                                               FontFamily="Consolas" FontSize="10" FontWeight="Bold"
                                               Foreground="{Binding StatusColor}" VerticalAlignment="Center"/>
                                </Grid>
                            </Border>
                        </HierarchicalDataTemplate>
                    </TreeView.ItemTemplate>

                    <!-- Resources for inline stage display -->
                    <TreeView.Resources>
                        <!-- Template for individual log entries (flat, no more nesting) -->
                        <DataTemplate DataType="{x:Type viewmodels:LogEntry}">
                            <Border Padding="16,1,4,1" BorderThickness="0">
                                <Grid>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="16"/>
                                        <ColumnDefinition Width="65"/>
                                        <ColumnDefinition Width="100"/>
                                        <ColumnDefinition Width="*"/>
                                        <ColumnDefinition Width="50"/>
                                    </Grid.ColumnDefinitions>

                                    <!-- Stage icon -->
                                    <TextBlock Grid.Column="0" Text="{Binding StageIcon}" 
                                               FontSize="11" VerticalAlignment="Center"/>

                                    <!-- Timestamp -->
                                    <TextBlock Grid.Column="1" Text="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}" 
                                               FontFamily="Consolas" FontSize="10" 
                                               Foreground="#666" VerticalAlignment="Center"/>

                                    <!-- Stage name (compact) -->
                                    <TextBlock Grid.Column="2" Text="{Binding Stage}" 
                                               FontSize="10" FontWeight="SemiBold"
                                               Foreground="{Binding LevelColor}" VerticalAlignment="Center"/>

                                    <!-- Message -->
                                    <TextBlock Grid.Column="3" Text="{Binding Message}" 
                                               TextTrimming="CharacterEllipsis"
                                               ToolTip="{Binding Message}"
                                               Margin="4,0" VerticalAlignment="Center"/>

                                    <!-- Duration if available -->
                                    <TextBlock Grid.Column="4" Text="{Binding FormattedDuration}" 
                                               FontFamily="Consolas" FontSize="9"
                                               Foreground="#999" HorizontalAlignment="Right"
                                               VerticalAlignment="Center"/>
                                </Grid>
                            </Border>
                        </DataTemplate>
                    </TreeView.Resources>
                </TreeView>
            </ScrollViewer>

            <!-- Flat View (when tree view disabled) -->
            <DataGrid ItemsSource="{Binding FilteredCombinedEntries}"
                      Visibility="{Binding IsTreeViewEnabled, Converter={StaticResource InverseBoolToVisibility}}"
                      AutoGenerateColumns="False"
                      CanUserAddRows="False"
                      CanUserDeleteRows="False"
                      GridLinesVisibility="Horizontal"
                      HeadersVisibility="Column"
                      IsReadOnly="True"
                      VirtualizingPanel.IsVirtualizing="True"
                      VirtualizingPanel.VirtualizationMode="Recycling"
                      ScrollViewer.CanContentScroll="True">
                <DataGrid.Resources>
                    <Style TargetType="DataGridCell">
                        <Setter Property="BorderThickness" Value="0"/>
                    </Style>
                </DataGrid.Resources>

                <DataGrid.ContextMenu>
                    <StaticResource ResourceKey="TreeContextMenu"/>
                </DataGrid.ContextMenu>

                <DataGrid.Columns>
                    <DataGridTextColumn Header="Time" Binding="{Binding Timestamp, StringFormat='HH:mm:ss.fff'}" 
                                        Width="100" FontFamily="Consolas"/>

                    <DataGridTextColumn Header="Level" Binding="{Binding LevelText}" Width="60">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="Foreground" Value="{Binding LevelColor}"/>
                                <Setter Property="FontWeight" Value="Bold"/>
                                <Setter Property="FontFamily" Value="Consolas"/>
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>

                    <DataGridTextColumn Header="Pipeline" Binding="{Binding Source}" Width="120"/>

                    <DataGridTextColumn Header="Correlation" Binding="{Binding CorrelationId}" Width="140" 
                                        FontFamily="Consolas" FontSize="11"/>

                    <DataGridTextColumn Header="Stage" Binding="{Binding Stage}" Width="120"/>

                    <DataGridTextColumn Header="Message" Binding="{Binding Message}" Width="*">
                        <DataGridTextColumn.ElementStyle>
                            <Style TargetType="TextBlock">
                                <Setter Property="TextWrapping" Value="Wrap"/>
                                <Setter Property="VerticalAlignment" Value="Center"/>
                            </Style>
                        </DataGridTextColumn.ElementStyle>
                    </DataGridTextColumn>

                    <DataGridTextColumn Header="Duration" Binding="{Binding FormattedDuration}" 
                                        Width="80" FontFamily="Consolas" FontSize="11"/>
                </DataGrid.Columns>
            </DataGrid>
        </Grid>
    </DockPanel>
</Page>


================================================================================
FILE: src\CamBridge.Config\Views\MappingEditorPage.xaml
================================================================================

<!-- src\CamBridge.Config\Views\MappingEditorPage.xaml -->
<!-- Version: 0.7.28 -->
<!-- Description: Mapping Editor with Unified Header Design -->

<Page x:Class="CamBridge.Config.Views.MappingEditorPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      xmlns:local="clr-namespace:CamBridge.Config.Views"
      xmlns:converters="clr-namespace:CamBridge.Config.Converters"
      xmlns:vm="clr-namespace:CamBridge.Config.ViewModels"
      mc:Ignorable="d"
      d:DesignHeight="600" d:DesignWidth="900"
      Title="Mapping Editor">

    <Page.Resources>
        <!-- Converters -->
        <BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
        <converters:TransformToSymbolConverter x:Key="TransformToSymbolConverter"/>
        <converters:TransformToDescriptionConverter x:Key="TransformToDescriptionConverter"/>

        <!-- Styles for the Mapping Editor -->
        <Style x:Key="SourceFieldStyle" TargetType="Border">
            <Setter Property="Background" Value="{DynamicResource SystemControlBackgroundAltHighBrush}"/>
            <Setter Property="BorderBrush" Value="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="CornerRadius" Value="4"/>
            <Setter Property="Padding" Value="8,4"/>
            <Setter Property="Margin" Value="2"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Style.Triggers>
                <Trigger Property="IsMouseOver" Value="True">
                    <Setter Property="Background" Value="{DynamicResource SystemControlHighlightListAccentLowBrush}"/>
                </Trigger>
            </Style.Triggers>
        </Style>

        <Style x:Key="MappingAreaStyle" TargetType="Border">
            <Setter Property="Background" Value="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"/>
            <Setter Property="BorderBrush" Value="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="CornerRadius" Value="2"/>
            <Setter Property="Margin" Value="8"/>
            <Setter Property="MinHeight" Value="400"/>
            <Setter Property="AllowDrop" Value="True"/>
        </Style>
    </Page.Resources>

    <!-- Keyboard Shortcuts -->
    <Page.InputBindings>
        <KeyBinding Key="I" Modifiers="Control" Command="{Binding ImportMappingsCommand}"/>
        <KeyBinding Key="E" Modifiers="Control" Command="{Binding ExportMappingsCommand}"/>
        <KeyBinding Key="S" Modifiers="Control" Command="{Binding SaveMappingsCommand}"/>
        <KeyBinding Key="F5" Command="{Binding TestMappingCommand}"/>
    </Page.InputBindings>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header - Unified Style -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <StackPanel VerticalAlignment="Center" Margin="24,0,0,0">
                    <TextBlock Text="Mapping Editor"
                               FontSize="24"
                               FontWeight="SemiBold"/>
                </StackPanel>

                <!-- Action Buttons -->
                <StackPanel Grid.Column="1"
                            Orientation="Horizontal"
                            VerticalAlignment="Center"
                            Margin="0,0,24,0">

                    <!-- Import Button -->
                    <Button Command="{Binding ImportMappingsCommand}"
                            Style="{StaticResource AccentButtonStyle}"
                            ToolTip="Import mapping rules from JSON file (Ctrl+I)"
                            Margin="0,0,8,0"
                            MinWidth="90">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="Download" Margin="0,0,6,0"/>
                            <TextBlock Text="Import"/>
                        </StackPanel>
                    </Button>

                    <!-- Export Button -->
                    <Button Command="{Binding ExportMappingsCommand}"
                            ToolTip="Export current mapping rules to JSON file (Ctrl+E)"
                            Margin="0,0,8,0"
                            MinWidth="90">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="Upload" Margin="0,0,6,0"/>
                            <TextBlock Text="Export"/>
                        </StackPanel>
                    </Button>

                    <!-- Save Button -->
                    <Button Command="{Binding SaveMappingsCommand}"
                            Style="{StaticResource AccentButtonStyle}"
                            ToolTip="Save mapping rules (Ctrl+S)"
                            MinWidth="90">
                        <StackPanel Orientation="Horizontal">
                            <ui:SymbolIcon Symbol="Save" Margin="0,0,6,0"/>
                            <TextBlock Text="Save"/>
                        </StackPanel>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Save Success Message -->
        <Border Grid.Row="0" 
                Background="Green" 
                Padding="12,8"
                Margin="24,0,24,0"
                CornerRadius="4"
                HorizontalAlignment="Center"
                VerticalAlignment="Bottom"
                Visibility="{Binding ShowSaveSuccess, Converter={StaticResource BoolToVisibility}}">
            <TextBlock Text="âœ“ Mapping configuration saved successfully!" 
                       Foreground="White"
                       FontWeight="SemiBold"/>
        </Border>

        <!-- Mapping Set Selection -->
        <Border Grid.Row="1"
                Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                BorderThickness="0"
                CornerRadius="2"
                Padding="16"
                Margin="16,16,16,8">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="Active Mapping Set:"
                           VerticalAlignment="Center"
                           Margin="0,0,12,0"/>

                <ComboBox Grid.Column="1"
                          ItemsSource="{Binding MappingSets}"
                          SelectedItem="{Binding SelectedMappingSet}"
                          DisplayMemberPath="Name"
                          MinWidth="200"/>

                <Button Grid.Column="2"
                        Content="New"
                        Command="{Binding AddMappingSetCommand}"
                        Margin="8,0,4,0"/>

                <Button Grid.Column="3"
                        Content="Delete"
                        Command="{Binding DeleteMappingSetCommand}"
                        Margin="4,0,0,0"/>

                <!-- Name Edit Field for non-system sets -->
                <StackPanel Grid.Row="1" 
                            Grid.ColumnSpan="4" 
                            Margin="0,8,0,0"
                            Visibility="{Binding CanEditCurrentSet, Converter={StaticResource BoolToVisibility}}">
                    <TextBlock Text="Set Name:" Margin="0,0,0,4"/>
                    <TextBox Text="{Binding SelectedMappingSet.Name, UpdateSourceTrigger=PropertyChanged}"
                             IsEnabled="{Binding CanEditCurrentSet}"/>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="2" Margin="16,0,16,16">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="220" MinWidth="180"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*" MinWidth="500"/>
            </Grid.ColumnDefinitions>

            <!-- Source Fields (EXIF) -->
            <Border Grid.Column="0"
                    Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                    CornerRadius="2"
                    BorderThickness="0"
                    Padding="16">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                    </Grid.RowDefinitions>

                    <TextBlock Text="Source Fields"
                               FontSize="16"
                               FontWeight="SemiBold"
                               Margin="0,0,0,12"/>

                    <ScrollViewer Grid.Row="1"
                                  VerticalScrollBarVisibility="Auto">
                        <StackPanel>
                            <!-- QRBridge Fields -->
                            <TextBlock Text="QRBridge Fields"
                                       FontWeight="SemiBold"
                                       Margin="0,0,0,8"
                                       Opacity="0.7"/>
                            <ItemsControl ItemsSource="{Binding QRBridgeFields}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Border Style="{StaticResource SourceFieldStyle}"
                                                ToolTip="{Binding DisplayName}"
                                                PreviewMouseLeftButtonDown="SourceField_MouseLeftButtonDown"
                                                PreviewMouseMove="SourceField_MouseMove">
                                            <TextBlock Text="{Binding FieldName}"/>
                                        </Border>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>

                            <!-- EXIF Fields -->
                            <TextBlock Text="EXIF Fields"
                                       FontWeight="SemiBold"
                                       Margin="0,16,0,8"
                                       Opacity="0.7"/>
                            <ItemsControl ItemsSource="{Binding ExifFields}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Border Style="{StaticResource SourceFieldStyle}"
                                                ToolTip="{Binding DisplayName}"
                                                PreviewMouseLeftButtonDown="SourceField_MouseLeftButtonDown"
                                                PreviewMouseMove="SourceField_MouseMove">
                                            <TextBlock Text="{Binding FieldName}"/>
                                        </Border>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </StackPanel>
                    </ScrollViewer>
                </Grid>
            </Border>

            <!-- Splitter -->
            <GridSplitter Grid.Column="1"
                          Width="5"
                          HorizontalAlignment="Center"
                          VerticalAlignment="Stretch"
                          Background="Transparent"/>

            <!-- Mapping Area -->
            <Border Grid.Column="2"
                    Background="{DynamicResource SystemControlBackgroundChromeMediumLowBrush}"
                    BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                    BorderThickness="1"
                    CornerRadius="2"
                    Margin="8,0,0,0"
                    AllowDrop="True"
                    DragOver="MappingArea_DragOver"
                    Drop="MappingArea_Drop">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <Grid Margin="16,16,16,12">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <TextBlock Text="Mapping Rules"
                                   FontSize="16"
                                   FontWeight="SemiBold"/>

                        <StackPanel Grid.Column="1" Orientation="Horizontal">
                            <!-- Test Mapping Button -->
                            <Button Command="{Binding TestMappingCommand}"
                                    ToolTip="Test mapping with sample data (F5)"
                                    Margin="0,0,8,0">
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="â–¶ " FontSize="14"/>
                                    <TextBlock Text="Test"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding BrowseDicomTagsCommand}"
                                    ToolTip="Browse all DICOM tags">
                                <StackPanel Orientation="Horizontal">
                                    <TextBlock Text="ðŸ“‹ " FontSize="14"/>
                                    <TextBlock Text="Browse All Tags..."/>
                                </StackPanel>
                            </Button>
                        </StackPanel>
                    </Grid>

                    <ListBox Grid.Row="1"
                             x:Name="RulesListBox"
                             ItemsSource="{Binding MappingRules}"
                             SelectedItem="{Binding SelectedRule}"
                             ScrollViewer.VerticalScrollBarVisibility="Auto"
                             BorderThickness="0"
                             Background="Transparent"
                             Padding="16,0">
                        <ListBox.ItemContainerStyle>
                            <Style TargetType="ListBoxItem">
                                <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                                <Setter Property="Padding" Value="0"/>
                                <Setter Property="Margin" Value="0,2"/>
                            </Style>
                        </ListBox.ItemContainerStyle>
                        <ListBox.ItemTemplate>
                            <DataTemplate>
                                <Border Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                                        CornerRadius="4"
                                        Padding="12">
                                    <Border.InputBindings>
                                        <MouseBinding Gesture="LeftDoubleClick" 
                                                      Command="{Binding DataContext.BrowseDicomTagsCommand, 
                                                                RelativeSource={RelativeSource AncestorType=Page}}"/>
                                    </Border.InputBindings>
                                    <Border.Style>
                                        <Style TargetType="Border">
                                            <Style.Triggers>
                                                <DataTrigger Binding="{Binding IsSelected, RelativeSource={RelativeSource AncestorType=ListBoxItem}}" Value="True">
                                                    <Setter Property="BorderBrush" Value="{DynamicResource SystemControlHighlightAccentBrush}"/>
                                                    <Setter Property="BorderThickness" Value="2"/>
                                                </DataTrigger>
                                            </Style.Triggers>
                                        </Style>
                                    </Border.Style>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto" MinWidth="120"/>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="Auto"/>
                                        </Grid.ColumnDefinitions>

                                        <!-- Source Field -->
                                        <TextBlock Text="{Binding SourceField}"
                                                   VerticalAlignment="Center"
                                                   FontWeight="SemiBold"
                                                   ToolTip="Double-click to select DICOM tag"/>

                                        <!-- Transform Indicator -->
                                        <TextBlock Grid.Column="1"
                                                   Margin="12,0"
                                                   VerticalAlignment="Center"
                                                   FontSize="14"
                                                   Text="{Binding Transform, Converter={StaticResource TransformToSymbolConverter}}"
                                                   ToolTip="{Binding Transform, Converter={StaticResource TransformToDescriptionConverter}}"/>

                                        <!-- DICOM Tag with Name -->
                                        <StackPanel Grid.Column="2" 
                                                    VerticalAlignment="Center"
                                                    ToolTip="Double-click to edit DICOM tag">
                                            <TextBlock FontFamily="Consolas">
                                                <Run Text="{Binding DicomTagString}"
                                                     Foreground="{DynamicResource SystemControlForegroundAccentBrush}"/>
                                                <Run Text=" - "/>
                                                <Run Text="{Binding DisplayName}"/>
                                            </TextBlock>
                                        </StackPanel>

                                        <!-- Transform Edit Button -->
                                        <Button Grid.Column="3"
                                                Command="{Binding DataContext.EditTransformCommand, 
                                                          RelativeSource={RelativeSource AncestorType=Page}}"
                                                CommandParameter="{Binding}"
                                                Style="{DynamicResource DefaultButtonStyle}"
                                                Width="32"
                                                Height="32"
                                                Padding="0"
                                                Margin="4,0"
                                                ToolTip="Edit transformation">
                                            <TextBlock Text="âš™" FontSize="14"/>
                                        </Button>

                                        <!-- DICOM Tag Edit Button -->
                                        <Button Grid.Column="4"
                                                Command="{Binding DataContext.BrowseDicomTagsCommand, 
                                                          RelativeSource={RelativeSource AncestorType=Page}}"
                                                Style="{DynamicResource DefaultButtonStyle}"
                                                Width="32"
                                                Height="32"
                                                Padding="0"
                                                Margin="4,0"
                                                ToolTip="Browse DICOM tags">
                                            <TextBlock Text="ðŸ“‹" FontSize="14"/>
                                        </Button>

                                        <!-- Delete Button -->
                                        <Button Grid.Column="5"
                                                Command="{Binding DataContext.RemoveRuleCommand, 
                                                          RelativeSource={RelativeSource AncestorType=Page}}"
                                                CommandParameter="{Binding}"
                                                Style="{DynamicResource DefaultButtonStyle}"
                                                Width="32"
                                                Height="32"
                                                Padding="0"
                                                Content="Ã—"
                                                FontSize="16"
                                                FontWeight="Bold"
                                                ToolTip="Remove this rule"/>
                                    </Grid>
                                </Border>
                            </DataTemplate>
                        </ListBox.ItemTemplate>
                    </ListBox>

                    <!-- Drag Info -->
                    <TextBlock Grid.Row="2"
                               Text="ðŸ’¡ Drag fields from the left to create mappings â€¢ Press F5 to test"
                               FontSize="12"
                               Opacity="0.6"
                               Margin="0,12,0,16"
                               HorizontalAlignment="Center"/>
                </Grid>
            </Border>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: src\CamBridge.Config\Views\PipelineConfigPage.xaml
================================================================================

<!-- src\CamBridge.Config\Views\PipelineConfigPage.xaml -->
<!-- Version: 0.8.10 -->
<!-- Description: Pipeline Configuration - With OutputPath Fix & PACS Upload Tab -->

<Page x:Class="CamBridge.Config.Views.PipelineConfigPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      xmlns:conv="clr-namespace:CamBridge.Config.Converters"
      xmlns:core="clr-namespace:CamBridge.Core;assembly=CamBridge.Core">

    <Page.Resources>
        <!-- Converters -->
        <conv:BooleanToVisibilityConverter x:Key="BoolToVisibility"/>
        <conv:InverseBooleanToVisibilityConverter x:Key="InverseBoolToVisibility"/>
        <conv:NullToVisibilityConverter x:Key="NullToVisibility"/>

        <!-- Styles -->
        <Style x:Key="SettingHeaderStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Margin" Value="0,16,0,8"/>
        </Style>

        <Style x:Key="SettingLabelStyle" TargetType="TextBlock">
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,0,12,0"/>
            <Setter Property="Width" Value="150"/>
        </Style>

        <Style x:Key="TabHeaderStyle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="FontWeight" Value="SemiBold"/>
            <Setter Property="Margin" Value="0,0,0,12"/>
        </Style>
    </Page.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="Pipeline Configuration"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>

                <StackPanel Grid.Column="1" 
                            Orientation="Horizontal"
                            HorizontalAlignment="Right"
                            VerticalAlignment="Center"
                            Margin="0,0,24,0">
                    <StackPanel Margin="0,0,16,0" 
                                VerticalAlignment="Center">
                        <TextBlock Text="{Binding Pipelines.Count, StringFormat='{}{0} pipelines configured'}"
                                   HorizontalAlignment="Right"
                                   FontSize="11"
                                   Opacity="0.7"/>
                        <TextBlock HorizontalAlignment="Right"
                                   FontSize="11"
                                   Opacity="0.7">
                            <Run Text="âœ“" Foreground="Green" FontSize="10"/>
                            <Run Text=" Auto-backup enabled"/>
                        </TextBlock>
                    </StackPanel>

                    <Button Command="{Binding SaveAllCommand}"
                            Style="{StaticResource AccentButtonStyle}"
                            MinWidth="140">
                        <StackPanel Orientation="Horizontal">
                            <TextBlock Text="Save All Pipelines" Margin="0,0,8,0"/>
                            <TextBlock Text="(Ctrl+S)" Opacity="0.7" FontSize="11"/>
                        </StackPanel>
                    </Button>
                </StackPanel>
            </Grid>
        </Border>

        <!-- Main Content -->
        <Grid Grid.Row="1">
            <Grid.RowDefinitions>
                <RowDefinition Height="*"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <!-- Pipeline Area -->
            <Grid Grid.Row="0" Margin="16,16,16,0">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="320" MinWidth="280"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>

                <!-- Pipeline List -->
                <Border Grid.Column="0"
                    Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                    BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                    BorderThickness="1"
                    CornerRadius="2">
                    <Grid>
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="*"/>
                            <RowDefinition Height="Auto"/>
                        </Grid.RowDefinitions>

                        <!-- List Header -->
                        <Border Grid.Row="0"
                            Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                            BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                            BorderThickness="0,0,0,1"
                            Padding="12,8">
                            <TextBlock Text="Pipelines"
                                   FontSize="14"
                                   FontWeight="SemiBold"/>
                        </Border>

                        <!-- Pipeline Items -->
                        <ListBox Grid.Row="1"
                             ItemsSource="{Binding Pipelines}"
                             SelectedItem="{Binding SelectedPipeline}"
                             BorderThickness="0"
                             ScrollViewer.HorizontalScrollBarVisibility="Disabled">
                            <ListBox.Style>
                                <Style TargetType="ListBox" BasedOn="{StaticResource {x:Type ListBox}}">
                                    <Setter Property="BorderThickness" Value="0"/>
                                </Style>
                            </ListBox.Style>
                            <ListBox.ItemContainerStyle>
                                <Style TargetType="ListBoxItem" BasedOn="{StaticResource DefaultListBoxItemStyle}">
                                    <Setter Property="Padding" Value="10,6"/>
                                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                                    <Setter Property="BorderThickness" Value="0"/>
                                </Style>
                            </ListBox.ItemContainerStyle>
                            <ListBox.ItemTemplate>
                                <DataTemplate>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>

                                        <CheckBox Grid.Column="0"
                                              IsChecked="{Binding Enabled}"
                                              Margin="0,0,8,0"
                                              VerticalAlignment="Center"/>

                                        <StackPanel Grid.Column="1">
                                            <TextBlock Text="{Binding Name}"
                                                   FontWeight="SemiBold"
                                                   TextTrimming="CharacterEllipsis"/>
                                            <TextBlock Text="{Binding WatchSettings.Path}"
                                                   FontSize="11"
                                                   Opacity="0.7"
                                                   TextTrimming="CharacterEllipsis"
                                                   ToolTip="{Binding WatchSettings.Path}"/>
                                        </StackPanel>
                                    </Grid>
                                </DataTemplate>
                            </ListBox.ItemTemplate>
                        </ListBox>

                        <!-- Add Button -->
                        <Border Grid.Row="2"
                            Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                            BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                            BorderThickness="0,1,0,0"
                            Padding="10">
                            <Button Command="{Binding AddPipelineCommand}"
                                HorizontalAlignment="Stretch">
                                <TextBlock Text="+ Add Pipeline"/>
                            </Button>
                        </Border>
                    </Grid>
                </Border>

                <!-- Splitter -->
                <GridSplitter Grid.Column="1"
                          Width="2"
                          HorizontalAlignment="Center"
                          VerticalAlignment="Stretch"
                          Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                          Margin="8,0"/>

                <!-- Pipeline Details -->
                <Grid Grid.Column="2"
                  Margin="8,0,0,0"
                  Visibility="{Binding SelectedPipeline, Converter={StaticResource NullToVisibility}}">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="*"/>
                    </Grid.RowDefinitions>

                    <!-- Pipeline Header -->
                    <Grid Grid.Row="0" Margin="0,0,0,16">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <TextBlock Text="{Binding SelectedPipeline.Name}"
                               FontSize="20"
                               FontWeight="SemiBold"/>

                        <Button Grid.Column="1"
                            Content="Delete Pipeline"
                            Command="{Binding DeletePipelineCommand}"
                            HorizontalAlignment="Right"
                            VerticalAlignment="Center"
                            Foreground="{DynamicResource SystemControlErrorTextForegroundBrush}"/>
                    </Grid>

                    <!-- Configuration Tabs -->
                    <TabControl Grid.Row="1"
                                ScrollViewer.HorizontalScrollBarVisibility="Disabled"
                                Padding="0">

                        <!-- General Tab -->
                        <TabItem Header="General">
                            <ScrollViewer Padding="12">
                                <StackPanel>
                                    <TextBlock Text="Basic Configuration" Style="{StaticResource TabHeaderStyle}"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Pipeline Name:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.Name, UpdateSourceTrigger=PropertyChanged}"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Description:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.Description}"
                                                 TextWrapping="Wrap"
                                                 AcceptsReturn="True"
                                                 Height="60"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Active:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="2" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.Enabled}"
                                                  Content="Enable this pipeline"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="Mapping Set:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="3" Grid.Column="1"
                                                  ItemsSource="{Binding MappingSets}"
                                                  SelectedValue="{Binding SelectedPipeline.MappingSetId}"
                                                  SelectedValuePath="Id"
                                                  DisplayMemberPath="Name"
                                                  HorizontalAlignment="Stretch"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Folders Tab -->
                        <TabItem Header="Folders">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Folder Configuration" Style="{StaticResource TabHeaderStyle}"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Watch Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="0" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.WatchSettings.Path, UpdateSourceTrigger=PropertyChanged}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseWatchFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="File Pattern:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.WatchSettings.FilePattern}"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Subdirectories:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="2" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.WatchSettings.IncludeSubdirectories}"
                                                  Content="Include subdirectories"
                                                  Margin="0,0,0,16"/>

                                        <!-- NEW: Output Path (Session 107 Fix) -->
                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="Output Path:"
                                                   Style="{StaticResource SettingLabelStyle}"
                                                   ToolTip="Primary output location for processed files (optional)"/>
                                        <Grid Grid.Row="3" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.WatchSettings.OutputPath, UpdateSourceTrigger=PropertyChanged}"
                                                     ui:ControlHelper.PlaceholderText="Leave empty to use Archive Folder"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseOutputPath_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="4" Grid.Column="0"
                                                   Text="Archive Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"
                                                   ToolTip="Archive location for successfully processed files"/>
                                        <Grid Grid.Row="4" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.ProcessingOptions.ArchiveFolder, UpdateSourceTrigger=PropertyChanged}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseArchiveFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="5" Grid.Column="0"
                                                   Text="Error Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="5" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding SelectedPipeline.ProcessingOptions.ErrorFolder}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseErrorFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="6" Grid.Column="0"
                                                   Text="Output Organization:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="6" Grid.Column="1"
                                                  ItemsSource="{Binding OutputOrganizations}"
                                                  SelectedItem="{Binding SelectedPipeline.ProcessingOptions.OutputOrganization}"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- PACS Upload Tab -->
                        <TabItem Header="PACS Upload">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="PACS Upload Configuration" Style="{StaticResource TabHeaderStyle}"/>
                                    <TextBlock Text="Automatically upload DICOM files to PACS after creation"
                                               FontSize="12"
                                               Opacity="0.7"
                                               Margin="0,0,0,16"/>

                                    <!-- Enable PACS -->
                                    <CheckBox IsChecked="{Binding SelectedPipeline.PacsConfiguration.Enabled}"
                                              Content="Enable automatic PACS upload after DICOM creation"
                                              FontSize="14" FontWeight="SemiBold"
                                              Margin="0,0,0,20"/>

                                    <!-- Server Settings -->
                                    <GroupBox Header="PACS Server Configuration" 
                                              IsEnabled="{Binding SelectedPipeline.PacsConfiguration.Enabled}"
                                              Margin="0,0,0,15">
                                        <Grid Margin="10">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="150"/>
                                                <ColumnDefinition Width="*"/>
                                            </Grid.ColumnDefinitions>
                                            <Grid.RowDefinitions>
                                                <RowDefinition Height="Auto"/>
                                                <RowDefinition Height="Auto"/>
                                                <RowDefinition Height="Auto"/>
                                                <RowDefinition Height="Auto"/>
                                                <RowDefinition Height="Auto"/>
                                            </Grid.RowDefinitions>

                                            <TextBlock Grid.Row="0" Grid.Column="0" 
                                                       Text="Host/IP:" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="0" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.Host}"
                                                     ui:ControlHelper.PlaceholderText="192.168.1.100 or pacs.hospital.local"
                                                     Margin="0,0,0,8"/>

                                            <TextBlock Grid.Row="1" Grid.Column="0" 
                                                       Text="Port:" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="1" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.Port}"
                                                     ui:ControlHelper.PlaceholderText="104"
                                                     HorizontalAlignment="Left"
                                                     Width="100"
                                                     Margin="0,0,0,8"/>

                                            <TextBlock Grid.Row="2" Grid.Column="0" 
                                                       Text="Called AE Title:" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="2" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.CalledAeTitle}"
                                                     ui:ControlHelper.PlaceholderText="PACS_SERVER"
                                                     CharacterCasing="Upper"
                                                     MaxLength="16"
                                                     Margin="0,0,0,8"/>

                                            <TextBlock Grid.Row="3" Grid.Column="0" 
                                                       Text="Calling AE Title:" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="3" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.CallingAeTitle}"
                                                     ui:ControlHelper.PlaceholderText="CAMBRIDGE"
                                                     CharacterCasing="Upper"
                                                     MaxLength="16"
                                                     Margin="0,0,0,8"/>

                                            <TextBlock Grid.Row="4" Grid.Column="0" 
                                                       Text="Timeout (seconds):" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="4" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.TimeoutSeconds}"
                                                     HorizontalAlignment="Left"
                                                     Width="100"/>
                                        </Grid>
                                    </GroupBox>

                                    <!-- Retry Settings -->
                                    <GroupBox Header="Retry Configuration" 
                                              IsEnabled="{Binding SelectedPipeline.PacsConfiguration.Enabled}"
                                              Margin="0,0,0,15">
                                        <Grid Margin="10">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="150"/>
                                                <ColumnDefinition Width="*"/>
                                            </Grid.ColumnDefinitions>
                                            <Grid.RowDefinitions>
                                                <RowDefinition Height="Auto"/>
                                                <RowDefinition Height="Auto"/>
                                                <RowDefinition Height="Auto"/>
                                            </Grid.RowDefinitions>

                                            <TextBlock Grid.Row="0" Grid.Column="0" 
                                                       Text="Max Retry Attempts:" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="0" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.MaxRetryAttempts}"
                                                     HorizontalAlignment="Left"
                                                     Width="100"
                                                     Margin="0,0,0,8"/>

                                            <TextBlock Grid.Row="1" Grid.Column="0" 
                                                       Text="Retry Delay (seconds):" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="1" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.RetryDelaySeconds}"
                                                     HorizontalAlignment="Left"
                                                     Width="100"
                                                     Margin="0,0,0,8"/>

                                            <TextBlock Grid.Row="2" Grid.Column="0" 
                                                       Text="Concurrent Uploads:" 
                                                       Style="{StaticResource SettingLabelStyle}"/>
                                            <TextBox Grid.Row="2" Grid.Column="1" 
                                                     Text="{Binding SelectedPipeline.PacsConfiguration.MaxConcurrentUploads}"
                                                     HorizontalAlignment="Left"
                                                     Width="100"/>
                                        </Grid>
                                    </GroupBox>

                                    <!-- Test Connection Button -->
                                    <Button Content="Test Connection (C-ECHO)"
                                            Click="TestPacsConnection_Click"
                                            IsEnabled="{Binding SelectedPipeline.PacsConfiguration.Enabled}"
                                            HorizontalAlignment="Left"
                                            Padding="20,8"
                                            Margin="0,0,0,10"/>

                                    <TextBlock Text="{Binding PacsConfigViewModel.PacsTestResult}"
                                               Foreground="{Binding PacsConfigViewModel.PacsTestResultColor}"
                                               FontWeight="SemiBold"
                                               Margin="0,5,0,0"/>

                                    <!-- Info Box -->
                                    <Border Background="{DynamicResource SystemControlBackgroundListLowBrush}"
                                            BorderBrush="{DynamicResource SystemControlForegroundBaseMediumLowBrush}"
                                            BorderThickness="1"
                                            CornerRadius="4"
                                            Padding="12"
                                            Margin="0,20,0,0">
                                        <StackPanel>
                                            <TextBlock Text="â„¹ PACS Upload Information" 
                                                       FontWeight="SemiBold"
                                                       Margin="0,0,0,8"/>
                                            <TextBlock TextWrapping="Wrap" FontSize="12">
                                                â€¢ DICOM files are uploaded immediately after successful creation<LineBreak/>
                                                â€¢ Failed uploads are retried automatically based on retry settings<LineBreak/>
                                                â€¢ AE Titles must be configured on the PACS server<LineBreak/>
                                                â€¢ Standard DICOM port is 104 (may vary by installation)<LineBreak/>
                                                â€¢ Test connection uses C-ECHO to verify connectivity
                                            </TextBlock>
                                        </StackPanel>
                                    </Border>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- DICOM Tab -->
                        <TabItem Header="DICOM">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="DICOM Overrides (Optional)" Style="{StaticResource TabHeaderStyle}"/>
                                    <TextBlock Text="Leave empty to use global DICOM settings"
                                               FontSize="12"
                                               Opacity="0.7"
                                               Margin="0,0,0,16"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Institution Name:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding SelectedPipelineDicomOverrides.InstitutionName}"
                                                 ui:ControlHelper.PlaceholderText="e.g. Radiology Department"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Department:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipelineDicomOverrides.InstitutionDepartment}"
                                                 ui:ControlHelper.PlaceholderText="e.g. Emergency Room"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Station Name:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="2" Grid.Column="1"
                                                 Text="{Binding SelectedPipelineDicomOverrides.StationName}"
                                                 ui:ControlHelper.PlaceholderText="e.g. ER_WORKSTATION_01"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Processing Tab -->
                        <TabItem Header="Processing">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Processing Options" Style="{StaticResource TabHeaderStyle}"/>

                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="File Delay (seconds):"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.WatchSettings.MinimumFileAgeSeconds}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Max Concurrent:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="1" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.ProcessingOptions.MaxConcurrentProcessing}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="On Success:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="2" Grid.Column="1"
                                                  ItemsSource="{Binding ProcessingActions}"
                                                  SelectedItem="{Binding SelectedPipeline.ProcessingOptions.SuccessAction}"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="On Failure:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="3" Grid.Column="1"
                                                  ItemsSource="{Binding ProcessingActions}"
                                                  SelectedItem="{Binding SelectedPipeline.ProcessingOptions.FailureAction}"
                                                  Margin="0,0,0,16"/>

                                        <TextBlock Grid.Row="4" Grid.Column="0"
                                                   Text="Retry Options:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="4" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.ProcessingOptions.RetryOnFailure}"
                                                  Content="Enable retry on failure"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="5" Grid.Column="0"
                                                   Text="Max Retries:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="5" Grid.Column="1"
                                                 Text="{Binding SelectedPipeline.ProcessingOptions.MaxRetryAttempts}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"
                                                 IsEnabled="{Binding SelectedPipeline.ProcessingOptions.RetryOnFailure}"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="6" Grid.Column="0"
                                                   Text="Backup Files:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="6" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.ProcessingOptions.CreateBackup}"
                                                  Content="Create backup before processing"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="7" Grid.Column="0"
                                                   Text="Process Existing:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="7" Grid.Column="1"
                                                  IsChecked="{Binding SelectedPipeline.ProcessingOptions.ProcessExistingOnStartup}"
                                                  Content="Process existing files on startup"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Logging Tab -->
                        <TabItem Header="Logging">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Pipeline-specific Logging" Style="{StaticResource TabHeaderStyle}"/>
                                    <TextBlock Text="Override global logging settings for this pipeline"
                                               FontSize="12"
                                               Opacity="0.7"
                                               Margin="0,0,0,16"/>

                                    <CheckBox Content="Use custom logging for this pipeline"
                                              IsChecked="{Binding UseCustomLogging}"
                                              Margin="0,0,0,16"/>

                                    <Grid IsEnabled="{Binding UseCustomLogging}">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Log Level:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="0" Grid.Column="1"
                                                  ItemsSource="{Binding LogLevels}"
                                                  SelectedItem="{Binding PipelineLogLevel}"
                                                  HorizontalAlignment="Left"
                                                  Width="200"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Log Folder:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <Grid Grid.Row="1" Grid.Column="1" Margin="0,0,0,8">
                                            <Grid.ColumnDefinitions>
                                                <ColumnDefinition Width="*"/>
                                                <ColumnDefinition Width="Auto"/>
                                            </Grid.ColumnDefinitions>
                                            <TextBox Grid.Column="0"
                                                     Text="{Binding PipelineLogFolder}"/>
                                            <Button Grid.Column="1"
                                                    Content="Browse..."
                                                    Width="80"
                                                    Margin="8,0,0,0"
                                                    Click="BrowseLogFolder_Click"/>
                                        </Grid>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Retention Days:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="2" Grid.Column="1"
                                                 Text="{Binding PipelineLogRetentionDays}"
                                                 HorizontalAlignment="Left"
                                                 Width="120"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                        <!-- Notifications Tab -->
                        <TabItem Header="Notifications">
                            <ScrollViewer Padding="16">
                                <StackPanel>
                                    <TextBlock Text="Pipeline-specific Notifications" Style="{StaticResource TabHeaderStyle}"/>
                                    <TextBlock Text="Configure alerts and notifications for this pipeline"
                                               FontSize="12"
                                               Opacity="0.7"
                                               Margin="0,0,0,16"/>

                                    <CheckBox Content="Override global notification settings"
                                              IsChecked="{Binding UseCustomNotifications}"
                                              Margin="0,0,0,16"/>

                                    <Grid IsEnabled="{Binding UseCustomNotifications}">
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <Grid.RowDefinitions>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                            <RowDefinition Height="Auto"/>
                                        </Grid.RowDefinitions>

                                        <TextBlock Grid.Row="0" Grid.Column="0"
                                                   Text="Email To:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <TextBox Grid.Row="0" Grid.Column="1"
                                                 Text="{Binding PipelineEmailTo}"
                                                 ui:ControlHelper.PlaceholderText="dept@hospital.com;manager@hospital.com"
                                                 Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="1" Grid.Column="0"
                                                   Text="Alert Level:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <ComboBox Grid.Row="1" Grid.Column="1"
                                                  ItemsSource="{Binding NotificationLevels}"
                                                  SelectedItem="{Binding PipelineAlertLevel}"
                                                  HorizontalAlignment="Left"
                                                  Width="200"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="2" Grid.Column="0"
                                                   Text="Daily Summary:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="2" Grid.Column="1"
                                                  IsChecked="{Binding PipelineSendDailySummary}"
                                                  Content="Send daily processing summary"
                                                  Margin="0,0,0,8"/>

                                        <TextBlock Grid.Row="3" Grid.Column="0"
                                                   Text="Alert on Errors:"
                                                   Style="{StaticResource SettingLabelStyle}"/>
                                        <CheckBox Grid.Row="3" Grid.Column="1"
                                                  IsChecked="{Binding PipelineAlertOnErrors}"
                                                  Content="Send immediate alerts for errors"/>
                                    </Grid>
                                </StackPanel>
                            </ScrollViewer>
                        </TabItem>

                    </TabControl>
                </Grid>

                <!-- No Selection Message -->
                <Grid Grid.Column="2"
                  Margin="8,0,0,0"
                  Visibility="{Binding SelectedPipeline, Converter={StaticResource NullToVisibility}, ConverterParameter=Inverse}"
                  VerticalAlignment="Center"
                  HorizontalAlignment="Center">
                    <StackPanel MaxWidth="400">
                        <TextBlock Text="No Pipeline Selected"
                               FontSize="18"
                               Opacity="0.5"
                               HorizontalAlignment="Center"/>
                        <TextBlock Text="Select a pipeline from the list or create a new one"
                               FontSize="13"
                               Opacity="0.5"
                               Margin="0,8,0,0"
                               HorizontalAlignment="Center"
                               TextWrapping="Wrap"
                               TextAlignment="Center"/>
                    </StackPanel>
                </Grid>
            </Grid>

            <!-- Status Bar -->
            <Border Grid.Row="1"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}"
                Height="28">
                <Grid Margin="16,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <!-- Loading -->
                    <ui:ProgressRing Grid.Column="0"
                                 IsActive="{Binding IsLoading}"
                                 Width="12"
                                 Height="12"
                                 Margin="0,0,8,0"
                                 Visibility="{Binding IsLoading, Converter={StaticResource BoolToVisibility}}"/>

                    <!-- Status -->
                    <TextBlock Grid.Column="1"
                           Text="{Binding StatusMessage}"
                           VerticalAlignment="Center"
                           FontSize="11"
                           Opacity="0.8"
                           Visibility="{Binding StatusMessage, Converter={StaticResource NullToVisibility}}"/>

                    <!-- Changes -->
                    <TextBlock Grid.Column="2"
                           FontSize="11"
                           Opacity="0.8"
                           VerticalAlignment="Center"
                           Visibility="{Binding HasUnsavedChanges, Converter={StaticResource BoolToVisibility}}">
                    <Run Text="â€¢" Foreground="Orange" FontSize="8"/>
                    <Run Text=" Unsaved changes"/>
                    </TextBlock>
                </Grid>
            </Border>
        </Grid>
    </Grid>
</Page>


================================================================================
FILE: src\CamBridge.Config\Views\ServiceControlPage.xaml
================================================================================

<!-- src/CamBridge.Config/Views/ServiceControlPage.xaml -->
<!-- Version: 0.8.6 -->
<!-- Description: Service Control with Global Service Settings -->
<!-- Modified: Session 96 - Making Logs Great Again! -->

<Page x:Class="CamBridge.Config.Views.ServiceControlPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:ui="http://schemas.modernwpf.com/2019"
      Unloaded="Page_Unloaded">

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header wie Mapping Editor -->
        <Border Grid.Row="0"
                Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}">
            <Grid Height="60">
                <TextBlock Text="Service Control"
                           FontSize="24"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"
                           Margin="24,0,0,0"/>
            </Grid>
        </Border>

        <!-- Main Content -->
        <ScrollViewer Grid.Row="1">
            <Grid Margin="16,16,16,0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <!-- Admin Warning -->
                <Border Grid.Row="0" Margin="0,0,0,16" Padding="12" CornerRadius="2"
                        Background="#FFF3CD" BorderThickness="0"
                        Visibility="{Binding RequiresElevation, Converter={StaticResource BooleanToVisibilityConverter}}">
                    <StackPanel Orientation="Horizontal">
                        <ui:SymbolIcon Symbol="Important" Margin="0,0,8,0"/>
                        <TextBlock Text="Administrator privileges required for service control" 
                                  VerticalAlignment="Center"/>
                    </StackPanel>
                </Border>

                <!-- Service Status Card -->
                <Border Grid.Row="1" CornerRadius="2" Margin="0,0,0,16"
                        Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        BorderThickness="0">
                    <Grid Margin="16,12">
                        <Grid.RowDefinitions>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                            <RowDefinition Height="Auto"/>
                        </Grid.RowDefinitions>

                        <!-- Status Display -->
                        <StackPanel Orientation="Horizontal" Margin="0,0,0,16">
                            <Ellipse Width="16" Height="16" Margin="0,0,12,0">
                                <Ellipse.Style>
                                    <Style TargetType="Ellipse">
                                        <Setter Property="Fill" Value="Gray"/>
                                        <Style.Triggers>
                                            <DataTrigger Binding="{Binding StatusColor}" Value="Green">
                                                <Setter Property="Fill" Value="#28A745"/>
                                            </DataTrigger>
                                            <DataTrigger Binding="{Binding StatusColor}" Value="Orange">
                                                <Setter Property="Fill" Value="#FFC107"/>
                                            </DataTrigger>
                                            <DataTrigger Binding="{Binding StatusColor}" Value="Red">
                                                <Setter Property="Fill" Value="#DC3545"/>
                                            </DataTrigger>
                                        </Style.Triggers>
                                    </Style>
                                </Ellipse.Style>
                            </Ellipse>
                            <TextBlock Text="CamBridge Service Status:" FontSize="16" Margin="0,0,8,0"/>
                            <TextBlock Text="{Binding StatusText}" FontSize="16" FontWeight="SemiBold"/>
                        </StackPanel>

                        <!-- Uptime Display -->
                        <TextBlock Grid.Row="1" Margin="28,0,0,16" FontSize="14" Opacity="0.7"
                                  Visibility="{Binding Uptime, Converter={StaticResource NullToVisibilityConverter}}">
                            <Run Text="Uptime:"/>
                            <Run Text="{Binding Uptime}"/>
                        </TextBlock>

                        <!-- Control Buttons -->
                        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="0,8,0,0">
                            <!-- Install Service Button âœ… VORHANDEN! -->
                            <Button Command="{Binding InstallServiceCommand}" 
                                    Visibility="{Binding IsServiceInstalled, 
                                               Converter={StaticResource InverseBooleanToVisibilityConverter}}"
                                    Margin="0,0,8,0" MinWidth="140"
                                    Style="{StaticResource AccentButtonStyle}">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Add" Margin="0,0,8,0"/>
                                    <TextBlock Text="Install Service"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding StartServiceCommand}" 
                                    IsEnabled="{Binding CanStart}"
                                    Margin="0,0,8,0" MinWidth="120">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Play" Margin="0,0,8,0"/>
                                    <TextBlock Text="Start Service"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding StopServiceCommand}"
                                    IsEnabled="{Binding CanStop}"
                                    Margin="0,0,8,0" MinWidth="120">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Stop" Margin="0,0,8,0"/>
                                    <TextBlock Text="Stop Service"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding RestartServiceCommand}"
                                    IsEnabled="{Binding CanRestart}"
                                    MinWidth="120">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Refresh" Margin="0,0,8,0"/>
                                    <TextBlock Text="Restart Service"/>
                                </StackPanel>
                            </Button>
                        </StackPanel>

                        <!-- Loading Indicator -->
                        <ui:ProgressRing Grid.Row="2" IsActive="{Binding IsLoading}" 
                                       Width="24" Height="24"
                                       HorizontalAlignment="Right" VerticalAlignment="Center"/>

                        <!-- Not Installed Message -->
                        <TextBlock Grid.Row="3" Margin="0,16,0,0"
                                  Foreground="{DynamicResource SystemControlForegroundBaseMediumBrush}"
                                  Visibility="{Binding IsServiceInstalled, 
                                             Converter={StaticResource InverseBooleanToVisibilityConverter}}">
                            <Run Text="The CamBridge Windows Service is not installed. Click"/>
                            <Run Text="Install Service" FontWeight="SemiBold"/>
                            <Run Text="above to install it."/>
                        </TextBlock>
                    </Grid>
                </Border>

                <!-- Service Settings Card - NEW! -->
                <Border Grid.Row="2" CornerRadius="2" Margin="0,0,0,16"
                        Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        BorderThickness="0">
                    <Expander Header="Service Settings" IsExpanded="True" Margin="16,12">
                        <Grid Margin="0,12,0,0">
                            <Grid.ColumnDefinitions>
                                <ColumnDefinition Width="200"/>
                                <ColumnDefinition Width="*"/>
                                <ColumnDefinition Width="Auto"/>
                            </Grid.ColumnDefinitions>
                            <Grid.RowDefinitions>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                                <RowDefinition Height="Auto"/>
                            </Grid.RowDefinitions>

                            <!-- Log Verbosity -->
                            <TextBlock Grid.Row="0" Grid.Column="0" 
                                      Text="Log Verbosity:" 
                                      VerticalAlignment="Center" 
                                      Margin="0,0,0,12"/>
                            <ComboBox Grid.Row="0" Grid.Column="1" 
                                     ItemsSource="{Binding LogVerbosityOptions}"
                                     SelectedItem="{Binding SelectedLogVerbosity}"
                                     Width="200" HorizontalAlignment="Left"
                                     Margin="0,0,0,12"/>
                            <TextBlock Grid.Row="0" Grid.Column="2" 
                                      Text="{Binding EstimatedLogSize}" 
                                      Foreground="{DynamicResource SystemControlForegroundBaseMediumBrush}"
                                      VerticalAlignment="Center" 
                                      Margin="12,0,0,12"/>

                            <!-- API Port -->
                            <TextBlock Grid.Row="1" Grid.Column="0" 
                                      Text="API Port:" 
                                      VerticalAlignment="Center" 
                                      Margin="0,0,0,12"/>
                            <ui:NumberBox Grid.Row="1" Grid.Column="1"
                                         Value="{Binding ApiPort}"
                                         Minimum="1024" Maximum="65535"
                                         SpinButtonPlacementMode="Inline"
                                         Width="200" HorizontalAlignment="Left"
                                         Margin="0,0,0,12"/>

                            <!-- Startup Delay -->
                            <TextBlock Grid.Row="2" Grid.Column="0" 
                                      Text="Startup Delay:" 
                                      VerticalAlignment="Center" 
                                      Margin="0,0,0,12"/>
                            <StackPanel Grid.Row="2" Grid.Column="1" 
                                       Orientation="Horizontal" 
                                       Margin="0,0,0,12">
                                <Slider Value="{Binding StartupDelaySeconds}"
                                       Minimum="0" Maximum="60"
                                       TickFrequency="5"
                                       IsSnapToTickEnabled="True"
                                       Width="150"/>
                                <TextBlock Text="{Binding StartupDelaySeconds, StringFormat='{}{0} seconds'}"
                                          VerticalAlignment="Center"
                                          Margin="12,0,0,0"
                                          MinWidth="70"/>
                            </StackPanel>

                            <!-- File Processing Delay -->
                            <TextBlock Grid.Row="3" Grid.Column="0" 
                                      Text="File Processing Delay:" 
                                      VerticalAlignment="Center" 
                                      Margin="0,0,0,12"/>
                            <StackPanel Grid.Row="3" Grid.Column="1" 
                                       Orientation="Horizontal" 
                                       Margin="0,0,0,12">
                                <Slider Value="{Binding FileProcessingDelayMs}"
                                       Minimum="0" Maximum="5000"
                                       TickFrequency="500"
                                       IsSnapToTickEnabled="True"
                                       Width="150"/>
                                <TextBlock Text="{Binding FileProcessingDelayMs, StringFormat='{}{0} ms'}"
                                          VerticalAlignment="Center"
                                          Margin="12,0,0,0"
                                          MinWidth="70"/>
                            </StackPanel>

                            <!-- Live Statistics Info -->
                            <Border Grid.Row="4" Grid.ColumnSpan="3" 
                                   Margin="0,12,0,12" Padding="12" 
                                   CornerRadius="2"
                                   Background="{DynamicResource SystemControlBackgroundBaseLowBrush}">
                                <StackPanel>
                                    <TextBlock Text="Current Log Statistics" 
                                              FontWeight="SemiBold" 
                                              Margin="0,0,0,8"/>
                                    <TextBlock TextWrapping="Wrap"
                                              Foreground="{DynamicResource SystemControlForegroundBaseMediumBrush}">
                                        <Run Text="Files processed today:"/>
                                        <Run Text="{Binding FilesProcessedToday}" FontWeight="SemiBold"/>
                                        <Run Text=" | Estimated daily log size:"/>
                                        <Run Text="{Binding EstimatedDailyLogSize}" FontWeight="SemiBold"/>
                                    </TextBlock>
                                </StackPanel>
                            </Border>

                            <!-- Save Button -->
                            <Button Grid.Row="5" Grid.Column="1" 
                                   Command="{Binding SaveServiceSettingsCommand}"
                                   HorizontalAlignment="Left"
                                   MinWidth="120">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Save" Margin="0,0,8,0"/>
                                    <TextBlock Text="Apply Settings"/>
                                </StackPanel>
                            </Button>

                            <TextBlock Grid.Row="5" Grid.Column="2"
                                      Text="Service restart required"
                                      Foreground="{DynamicResource SystemControlForegroundBaseMediumBrush}"
                                      VerticalAlignment="Center"
                                      Visibility="{Binding SettingsChanged, Converter={StaticResource BooleanToVisibilityConverter}}"
                                      Margin="12,0,0,0"/>
                        </Grid>
                    </Expander>
                </Border>

                <!-- Quick Actions -->
                <Border Grid.Row="3" CornerRadius="2"
                        Background="{DynamicResource SystemControlBackgroundAltHighBrush}"
                        BorderThickness="0">
                    <StackPanel Margin="16,12">
                        <TextBlock Text="Quick Actions" FontSize="16" FontWeight="SemiBold" Margin="0,0,0,12"/>

                        <StackPanel Orientation="Horizontal">
                            <Button Command="{Binding OpenServicesCommand}" Margin="0,0,8,0">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Setting" Margin="0,0,8,0"/>
                                    <TextBlock Text="Windows Services"/>
                                </StackPanel>
                            </Button>

                            <Button Command="{Binding OpenEventViewerCommand}" Margin="0,0,8,0">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Document" Margin="0,0,8,0"/>
                                    <TextBlock Text="Event Viewer"/>
                                </StackPanel>
                            </Button>

                            <!-- Uninstall Button âœ… VORHANDEN! -->
                            <Button Command="{Binding UninstallServiceCommand}"
                                    Visibility="{Binding IsServiceInstalled, 
                                               Converter={StaticResource BooleanToVisibilityConverter}}">
                                <StackPanel Orientation="Horizontal">
                                    <ui:SymbolIcon Symbol="Delete" Margin="0,0,8,0"/>
                                    <TextBlock Text="Uninstall Service"/>
                                </StackPanel>
                            </Button>
                        </StackPanel>
                    </StackPanel>
                </Border>
            </Grid>
        </ScrollViewer>
    </Grid>
</Page>


================================================================================
FILE: src\CamBridge.Config\Views\VogonPoetryWindow.xaml
================================================================================

<Window x:Class="CamBridge.Config.Views.VogonPoetryWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="http://schemas.modernwpf.com/2019"
        ui:WindowHelper.UseModernWindowStyle="True"
        Title="*** AMIGA VOGON POETRY DEMO v4.2 ***" 
        Height="600" Width="800"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="#FFB0B0B0">

    <Window.Resources>
        <!-- Boing Ball Animation - AUTHENTIC -->
        <Storyboard x:Key="BoingBallAnimation">
            <!-- Ball bouncing horizontal - 8 seconds full cycle -->
            <DoubleAnimationUsingKeyFrames Storyboard.TargetName="BoingBall" 
                                         Storyboard.TargetProperty="(Canvas.Left)"
                                         RepeatBehavior="Forever">
                <LinearDoubleKeyFrame KeyTime="0:0:0" Value="50"/>
                <LinearDoubleKeyFrame KeyTime="0:0:4" Value="650"/>
                <LinearDoubleKeyFrame KeyTime="0:0:8" Value="50"/>
            </DoubleAnimationUsingKeyFrames>

            <!-- Ball bouncing vertical -->
            <DoubleAnimationUsingKeyFrames Storyboard.TargetName="BoingBall" 
                                         Storyboard.TargetProperty="(Canvas.Top)"
                                         RepeatBehavior="Forever">
                <LinearDoubleKeyFrame KeyTime="0:0:0" Value="350"/>
                <LinearDoubleKeyFrame KeyTime="0:0:4" Value="50"/>
                <LinearDoubleKeyFrame KeyTime="0:0:8" Value="350"/>
            </DoubleAnimationUsingKeyFrames>

            <!-- Sprite frame animation handled in code-behind -->
        </Storyboard>

        <!-- Scrolling Text Animation - SLOWER -->
        <Storyboard x:Key="ScrollTextAnimation">
            <DoubleAnimation Storyboard.TargetName="ScrollingText" 
                           Storyboard.TargetProperty="(Canvas.Left)"
                           From="800" To="-2000" Duration="0:0:30" 
                           RepeatBehavior="Forever"/>
        </Storyboard>

        <!-- Rainbow Color Animation - SLOWER -->
        <Storyboard x:Key="RainbowAnimation">
            <ColorAnimationUsingKeyFrames Storyboard.TargetName="RainbowBrush" 
                                        Storyboard.TargetProperty="Color"
                                        RepeatBehavior="Forever">
                <LinearColorKeyFrame KeyTime="0:0:0" Value="#FF0000"/>
                <LinearColorKeyFrame KeyTime="0:0:2" Value="#FF7F00"/>
                <LinearColorKeyFrame KeyTime="0:0:4" Value="#FFFF00"/>
                <LinearColorKeyFrame KeyTime="0:0:6" Value="#00FF00"/>
                <LinearColorKeyFrame KeyTime="0:0:8" Value="#0000FF"/>
                <LinearColorKeyFrame KeyTime="0:0:10" Value="#4B0082"/>
                <LinearColorKeyFrame KeyTime="0:0:12" Value="#9400D3"/>
                <LinearColorKeyFrame KeyTime="0:0:14" Value="#FF0000"/>
            </ColorAnimationUsingKeyFrames>
        </Storyboard>
    </Window.Resources>

    <Grid>
        <!-- Purple Grid Background like original Amiga demo -->
        <Canvas Panel.ZIndex="1">
            <Canvas.Background>
                <DrawingBrush TileMode="Tile" Viewport="0,0,50,50" ViewportUnits="Absolute">
                    <DrawingBrush.Drawing>
                        <DrawingGroup>
                            <GeometryDrawing Brush="Transparent">
                                <GeometryDrawing.Geometry>
                                    <RectangleGeometry Rect="0,0,50,50"/>
                                </GeometryDrawing.Geometry>
                            </GeometryDrawing>
                            <GeometryDrawing>
                                <GeometryDrawing.Pen>
                                    <Pen Brush="#FF9B009B" Thickness="2"/>
                                </GeometryDrawing.Pen>
                                <GeometryDrawing.Geometry>
                                    <GeometryGroup>
                                        <LineGeometry StartPoint="0,0" EndPoint="0,50"/>
                                        <LineGeometry StartPoint="0,0" EndPoint="50,0"/>
                                    </GeometryGroup>
                                </GeometryDrawing.Geometry>
                            </GeometryDrawing>
                        </DrawingGroup>
                    </DrawingBrush.Drawing>
                </DrawingBrush>
            </Canvas.Background>

            <!-- Grid floor perspective lines -->
            <Line X1="400" Y1="600" X2="100" Y2="380" Stroke="#FF9B009B" StrokeThickness="2"/>
            <Line X1="400" Y1="600" X2="700" Y2="380" Stroke="#FF9B009B" StrokeThickness="2"/>
            <Line X1="0" Y1="380" X2="800" Y2="380" Stroke="#FF9B009B" StrokeThickness="2"/>
        </Canvas>

        <Canvas Panel.ZIndex="5">
            <!-- Amiga Boing Ball - SPRITE ANIMATION STYLE -->
            <Image x:Name="BoingBall" Canvas.Left="50" Canvas.Top="300" 
                   Width="100" Height="100" RenderTransformOrigin="0.5,0.5">
                <Image.RenderTransform>
                    <TransformGroup>
                        <!-- Slight tilt for authentic look -->
                        <RotateTransform Angle="15"/>
                    </TransformGroup>
                </Image.RenderTransform>

                <!-- WriteableBitmap will be set in code-behind for sprite animation -->
            </Image>

            <!-- Scrolling Text -->
            <TextBlock x:Name="ScrollingText" Canvas.Left="800" Canvas.Top="20"
                      FontFamily="Courier New" FontSize="32" FontWeight="Bold" Panel.ZIndex="60">
                <TextBlock.Foreground>
                    <SolidColorBrush x:Name="RainbowBrush" Color="Red"/>
                </TextBlock.Foreground>
                <Run Text="*** VOGON POETRY CREW PRESENTS: THE ANSWER IS 42! *** GREETINGS TO DOUGLAS ADAMS *** DON'T PANIC *** AMIGA RULEZ *** "/>
            </TextBlock>

            <!-- Main Content Area - Text Box -->
            <Border Canvas.Left="50" Canvas.Top="80" Width="700" Height="200"
                    Background="#66000033" BorderBrush="#FF00FF00" BorderThickness="2" Panel.ZIndex="10">
                <ScrollViewer VerticalScrollBarVisibility="Auto" Padding="20">
                    <StackPanel>
                        <TextBlock FontFamily="Consolas" FontSize="20" Foreground="#FFFF00"
                                  Text="VOGON POETRY DEMO v4.2" HorizontalAlignment="Center"/>
                        <TextBlock FontFamily="Consolas" FontSize="14" Foreground="#00FF00"
                                  Text="=====================================" HorizontalAlignment="Center"
                                  Margin="0,0,0,20"/>

                        <TextBlock FontFamily="Consolas" FontSize="14" 
                                  LineHeight="20" TextWrapping="Wrap">
                            <Run Foreground="#00FFFF">Oh freddled gruntbuggly, thy DICOM tags are to me</Run>
                            <LineBreak/>
                            <Run Foreground="#00FFFF">As plurdled gabbleblotchits on a lurgid JPEG tree.</Run>
                            <LineBreak/><LineBreak/>
                            
                            <Run Foreground="#FF00FF">Groop, I implore thee, my foonting turlingdromes,</Run>
                            <LineBreak/>
                            <Run Foreground="#FF00FF">And hooptiously drangle me with crinkly EXIF gnomes;</Run>
                            <LineBreak/><LineBreak/>
                            
                            <Run Foreground="#FFFF00">Or I will rend thee in the gobberwarts with my blurglecruncheon,</Run>
                            <LineBreak/>
                            <Run Foreground="#FFFF00">See if thy Patient ID survives the compression!</Run>
                            <LineBreak/><LineBreak/>
                            
                            <Run Text="-- Prostetnic Vogon Jeltz" Foreground="#808080"/>
                        </TextBlock>
                    </StackPanel>
                </ScrollViewer>
            </Border>

            <!-- ERROR HAIKU Box -->
            <Border Canvas.Left="200" Canvas.Top="300" Width="400" Height="80"
                    Background="#66330000" BorderBrush="#FFFF0000" BorderThickness="2" Panel.ZIndex="10">
                <TextBlock FontFamily="Consolas" FontSize="14" 
                          HorizontalAlignment="Center" VerticalAlignment="Center"
                          TextAlignment="Center">
                    <Run Text="ERROR HAIKU:" Foreground="#FF0000" FontWeight="Bold"/>
                    <LineBreak/>
                    <Run Foreground="#FFA500">Dead letter queue full</Run>
                    <LineBreak/>
                    <Run Foreground="#FFA500">DICOM validation fails</Run>
                    <LineBreak/>
                    <Run Foreground="#FFA500">Forty-two errors</Run>
                </TextBlock>
            </Border>

            <!-- Bottom Raster Bars -->
            <Rectangle Canvas.Left="0" Canvas.Top="480" Width="800" Height="10" Panel.ZIndex="90">
                <Rectangle.Fill>
                    <LinearGradientBrush StartPoint="0,0" EndPoint="1,0">
                        <GradientStop Color="#FF0000" Offset="0"/>
                        <GradientStop Color="#FFFF00" Offset="0.2"/>
                        <GradientStop Color="#00FF00" Offset="0.4"/>
                        <GradientStop Color="#00FFFF" Offset="0.6"/>
                        <GradientStop Color="#0000FF" Offset="0.8"/>
                        <GradientStop Color="#FF00FF" Offset="1"/>
                    </LinearGradientBrush>
                </Rectangle.Fill>
            </Rectangle>
        </Canvas>

        <!-- Control Buttons (Retro Style) -->
        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" 
                    VerticalAlignment="Bottom" Margin="0,0,0,20" Panel.ZIndex="200">
            <Button x:Name="AppreciateButton" Content="[ APPRECIATE ]" 
                    FontFamily="Consolas" FontSize="16"
                    Background="#FF0080FF" Foreground="White"
                    Padding="20,10" Margin="10,0"
                    Click="AppreciateButton_Click"/>

            <Button x:Name="PanicButton" Content="[ PANIC! ]" 
                    FontFamily="Consolas" FontSize="16"
                    Background="#FFFF0000" Foreground="White"
                    Padding="20,10" Margin="10,0"
                    Click="CloseButton_Click"/>
        </StackPanel>
    </Grid>
</Window>


================================================================================
FILE: src\CamBridge.Config\App.xaml.cs
================================================================================

// src\CamBridge.Config\App.xaml.cs
// Version: 0.8.5
// Description: Application entry point with refactored ViewModels and DicomStoreService
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Threading;
using CamBridge.Config.Services;
using CamBridge.Config.ViewModels;
using CamBridge.Config.Views;
using CamBridge.Infrastructure.Services;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace CamBridge.Config
{
    /// <summary>
    /// Main application class
    /// </summary>
    public partial class App : Application
    {
        private IHost? _host;

        /// <summary>
        /// Gets the current host instance
        /// </summary>
        public IHost? Host => _host;

        /// <summary>
        /// Gets the current service provider
        /// </summary>
        public static IServiceProvider Services { get; private set; } = null!;

        /// <summary>
        /// Application startup
        /// </summary>
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // Setup global exception handlers
            AppDomain.CurrentDomain.UnhandledException += OnUnhandledException;
            DispatcherUnhandledException += OnDispatcherUnhandledException;

            try
            {
                ConfigureHost();
            }
            catch (Exception ex)
            {
                LogException("Host configuration failed", ex);
                MessageBox.Show(
                    $"Failed to start application: {ex.Message}",
                    "Startup Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
                Shutdown(1);
            }
        }

        /// <summary>
        /// Configure the dependency injection host
        /// </summary>
        private void ConfigureHost()
        {
            // Verify config file exists - Added in v0.5.32
            var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            var configPath = System.IO.Path.Combine(appDataPath, "CamBridge", "appsettings.json");

            if (!System.IO.File.Exists(configPath))
            {
                // Also check ProgramData (where Service saves config)
                var programDataPath = System.IO.Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData),
                    "CamBridge",
                    "appsettings.json");

                if (System.IO.File.Exists(programDataPath))
                {
                    configPath = programDataPath;
                }
                else
                {
                    MessageBox.Show(
                        $"Configuration file not found.\nExpected at: {configPath}\n\nPlease run the service first to create initial configuration.",
                        "Configuration Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                }
            }

            _host = Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder()
                .ConfigureServices((context, services) =>
                {
                    // Configuration
                    var configuration = context.Configuration;

                    // Core Services
                    services.AddSingleton<INavigationService, NavigationService>();
                    services.AddSingleton<IServiceManager, ServiceManager>();
                    services.AddSingleton<IConfigurationService, ConfigurationService>();

                    // NEW: Pipeline Settings Service (Session 95)
                    services.AddSingleton<IPipelineSettingsService, PipelineSettingsService>();

                    // HttpClient for API calls - FIXED PORT!
                    services.AddHttpClient<IApiService, HttpApiService>(client =>
                    {
                        // CRITICAL: Use port 5111, not 5050!
                        client.BaseAddress = new Uri("http://localhost:5111/");
                        client.Timeout = TimeSpan.FromSeconds(5);
                    });

                    // Infrastructure Services
                    // CRITICAL: DicomStoreService was missing! This is why Test Connection never worked!
                    services.AddSingleton<DicomStoreService>(); // NEW - Session 95 discovery!

                    // ViewModels - Updated with refactored ViewModels
                    services.AddTransient<MainViewModel>();
                    services.AddTransient<DashboardViewModel>();
                    services.AddTransient<ServiceControlViewModel>();

                    // NEW: PacsConfigViewModel (Session 95)
                    services.AddTransient<PacsConfigViewModel>();

                    // UPDATED: PipelineConfigViewModel with new dependencies
                    services.AddTransient<PipelineConfigViewModel>(provider =>
                        new PipelineConfigViewModel(
                            provider.GetRequiredService<IConfigurationService>(),
                            provider.GetRequiredService<IPipelineSettingsService>(),
                            provider.GetRequiredService<PacsConfigViewModel>()));

                    services.AddTransient<DeadLettersViewModel>();
                    services.AddTransient<MappingEditorViewModel>();
                    services.AddTransient<LogViewerViewModel>();

                    // Views - Registration for pages
                    services.AddTransient<LogViewerPage>();

                    // Logging
                    services.AddLogging(configure =>
                    {
                        configure.AddDebug();
                        configure.SetMinimumLevel(LogLevel.Debug);
                    });
                })
                .Build();

            Services = _host.Services;

            // Create and show main window
            var mainWindow = new MainWindow();
            mainWindow.Show();
        }

        /// <summary>
        /// Application exit cleanup
        /// </summary>
        protected override void OnExit(ExitEventArgs e)
        {
            _host?.Dispose();
            base.OnExit(e);
        }

        /// <summary>
        /// Handle unhandled exceptions
        /// </summary>
        private void OnUnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            LogException("Unhandled exception", e.ExceptionObject as Exception);

            MessageBox.Show(
                "An unexpected error occurred. The application will now close.",
                "Fatal Error",
                MessageBoxButton.OK,
                MessageBoxImage.Error);
        }

        /// <summary>
        /// Handle dispatcher unhandled exceptions
        /// </summary>
        private void OnDispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            LogException("Dispatcher exception", e.Exception);

            // Show error to user
            MessageBox.Show(
                $"An error occurred: {e.Exception.Message}",
                "Error",
                MessageBoxButton.OK,
                MessageBoxImage.Warning);

            // Mark as handled to prevent crash
            e.Handled = true;
        }

        /// <summary>
        /// Logs an exception
        /// </summary>
        private void LogException(string context, Exception? exception)
        {
            if (exception == null) return;

            try
            {
                var logger = Services?.GetService<ILogger<App>>();
                logger?.LogError(exception, "{Context}", context);
            }
            catch
            {
                // Fallback to debug output if logging fails
                System.Diagnostics.Debug.WriteLine($"{context}: {exception}");
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\MainWindow.xaml.cs
================================================================================

// src\CamBridge.Config\MainWindow.xaml.cs
// Version: 0.7.23
// Description: Main window code-behind with navigation history fix

using System;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using ModernWpf.Controls;
using CamBridge.Config.Services;
using CamBridge.Config.ViewModels;
using CamBridge.Config.Views;

namespace CamBridge.Config
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        private readonly INavigationService _navigationService;
        private readonly MainViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();

            // Set version dynamically from assembly
            var version = Assembly.GetExecutingAssembly()
                .GetCustomAttribute<AssemblyInformationalVersionAttribute>()
                ?.InformationalVersion ?? "Unknown";

            Title = $"CamBridge Configuration v{version}";

            // Get services from DI
            var app = (App)App.Current;
            _navigationService = app.Host!.Services.GetRequiredService<INavigationService>();
            _viewModel = app.Host!.Services.GetRequiredService<MainViewModel>();

            DataContext = _viewModel;

            // Initialize navigation
            if (_navigationService is NavigationService navService)
            {
                navService.SetFrame(ContentFrame);
            }

            // Clear navigation journal to prevent history
            ContentFrame.NavigationService.RemoveBackEntry();

            // Navigate to dashboard on startup
            NavView.SelectedItem = NavView.MenuItems[0];
        }

        private void NavigationView_SelectionChanged(NavigationView sender, NavigationViewSelectionChangedEventArgs args)
        {
            if (args.SelectedItem is NavigationViewItem item)
            {
                var tag = item.Tag?.ToString();
                if (!string.IsNullOrEmpty(tag))
                {
                    _navigationService.NavigateTo(tag);

                    // Clear navigation history after each navigation
                    // This prevents the dropdown from appearing
                    while (ContentFrame.NavigationService.CanGoBack)
                    {
                        ContentFrame.NavigationService.RemoveBackEntry();
                    }
                }
            }
        }

        protected override void OnClosed(EventArgs e)
        {
            base.OnClosed(e);

            // Clean shutdown
            Application.Current.Shutdown();
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Dialogs\DicomTagBrowserDialog.xaml.cs
================================================================================

// src/CamBridge.Config/Dialogs/DicomTagBrowserDialog.xaml.cs
// Version: 0.7.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions
// Enhanced with NEMA-compliant descriptions

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using ModernWpf.Controls;
// Use alias to avoid conflicts
using CoreDicomTag = CamBridge.Core.ValueObjects.DicomTag;

namespace CamBridge.Config.Dialogs
{
    /// <summary>
    /// Dialog for browsing and selecting DICOM tags with search functionality
    /// </summary>
    [SupportedOSPlatform("windows")]
    public partial class DicomTagBrowserDialog : Window, INotifyPropertyChanged
    {
        #region Properties

        private string? _searchText;
        public string? SearchText
        {
            get => _searchText;
            set
            {
                if (_searchText != value)
                {
                    _searchText = value;
                    OnPropertyChanged();
                    UpdateFilter();
                }
            }
        }

        public CoreDicomTag? SelectedTag { get; private set; }

        private CollectionViewSource _tagsViewSource = null!;
        public ICollectionView TagsView => _tagsViewSource.View;

        private List<DicomTagInfo> _allTags = null!;

        #endregion

        public DicomTagBrowserDialog()
        {
            InitializeComponent();
            DataContext = this;

            // Initialize collections before use
            _allTags = new List<DicomTagInfo>();
            _tagsViewSource = new CollectionViewSource();

            LoadDicomTags();
            SearchBox.Focus();
        }

        #region Initialization

        private void LoadDicomTags()
        {
            // Clear and reinitialize
            _allTags.Clear();

            // Patient Module - NEMA PS3.3 Table C.7-1
            AddTag("Patient", CoreDicomTag.PatientModule.PatientName, "Patient's Name", "PN",
                "Primary identifier - Format: Family^Given^Middle^Prefix^Suffix");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientID, "Patient ID", "LO",
                "Primary hospital/institution identification number");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientBirthDate, "Patient's Birth Date", "DA",
                "Format: YYYYMMDD (e.g., 19850315 for March 15, 1985)");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientSex, "Patient's Sex", "CS",
                "M=Male, F=Female, O=Other (fixed enumeration)");
            AddTag("Patient", CoreDicomTag.PatientModule.OtherPatientIDs, "Other Patient IDs", "LO",
                "Additional identifiers from other systems");
            AddTag("Patient", CoreDicomTag.PatientModule.PatientComments, "Patient Comments", "LT",
                "Additional information about the patient");

            // Study Module - NEMA PS3.3 Table C.7-3
            AddTag("Study", CoreDicomTag.StudyModule.StudyInstanceUID, "Study Instance UID", "UI",
                "Unique identifier for the study - automatically generated");
            AddTag("Study", CoreDicomTag.StudyModule.StudyDate, "Study Date", "DA",
                "Date the study started - Format: YYYYMMDD");
            AddTag("Study", CoreDicomTag.StudyModule.StudyTime, "Study Time", "TM",
                "Time the study started - Format: HHMMSS.FFFFFF");
            AddTag("Study", CoreDicomTag.StudyModule.StudyID, "Study ID", "SH",
                "Institution-generated study identifier");
            AddTag("Study", CoreDicomTag.StudyModule.AccessionNumber, "Accession Number", "SH",
                "RIS/HIS generated number that identifies the order");
            AddTag("Study", CoreDicomTag.StudyModule.StudyDescription, "Study Description", "LO",
                "Institution-generated description or classification of the study");
            AddTag("Study", CoreDicomTag.StudyModule.ReferringPhysicianName, "Referring Physician's Name", "PN",
                "Name of the physician who requested the study");

            // Series Module - NEMA PS3.3 Table C.7-5a
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesInstanceUID, "Series Instance UID", "UI",
                "Unique identifier for the series - automatically generated");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesNumber, "Series Number", "IS",
                "A number that identifies this series (e.g., 1, 2, 3...)");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesDate, "Series Date", "DA",
                "Date the series started");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesTime, "Series Time", "TM",
                "Time the series started");
            AddTag("Series", CoreDicomTag.SeriesModule.SeriesDescription, "Series Description", "LO",
                "Description of the series (e.g., 'Chest PA', 'Lateral View')");
            AddTag("Series", CoreDicomTag.SeriesModule.Modality, "Modality", "CS",
                "Type of equipment (e.g., XA=X-Ray Angiography, OT=Other)");

            // General Image Module - NEMA PS3.3 Table C.7-9
            AddTag("Image", CoreDicomTag.InstanceModule.SOPInstanceUID, "SOP Instance UID", "UI",
                "Unique identifier for this image - automatically generated");
            AddTag("Image", CoreDicomTag.InstanceModule.InstanceNumber, "Instance Number", "IS",
                "A number that identifies this image (1, 2, 3...)");
            AddTag("Image", CoreDicomTag.InstanceModule.ContentDate, "Content Date", "DA",
                "The date the image pixel data creation started");
            AddTag("Image", CoreDicomTag.InstanceModule.ContentTime, "Content Time", "TM",
                "The time the image pixel data creation started");
            AddTag("Image", CoreDicomTag.InstanceModule.AcquisitionDateTime, "Acquisition DateTime", "DT",
                "Date and time the acquisition started - Format: YYYYMMDDHHMMSS.FFFFFF");

            // General Equipment Module - NEMA PS3.3 Table C.7-8
            AddTag("Equipment", CoreDicomTag.EquipmentModule.Manufacturer, "Manufacturer", "LO",
                "Manufacturer of the equipment (e.g., 'RICOH')");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.InstitutionName, "Institution Name", "LO",
                "Institution where the equipment is located");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.StationName, "Station Name", "SH",
                "User-defined name identifying the machine");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.ManufacturerModelName, "Manufacturer's Model Name", "LO",
                "Manufacturer's model name (e.g., 'G900 II')");
            AddTag("Equipment", CoreDicomTag.EquipmentModule.SoftwareVersions, "Software Versions", "LO",
                "Manufacturer's software version (e.g., 'CamBridge 0.7.25')");

            // Additional commonly used tags
            AddTag("General", new CoreDicomTag(0x0008, 0x0005), "Specific Character Set", "CS",
                "Character encoding (e.g., 'ISO_IR 100' for Latin-1)");
            AddTag("General", new CoreDicomTag(0x0008, 0x0016), "SOP Class UID", "UI",
                "Identifies the DICOM IOD (e.g., Secondary Capture)");
            AddTag("General", new CoreDicomTag(0x0008, 0x0064), "Conversion Type", "CS",
                "Describes the conversion (e.g., 'WSD' = Workstation)");
            AddTag("General", new CoreDicomTag(0x0020, 0x0013), "Instance Number", "IS",
                "Number that identifies this instance");
            AddTag("General", new CoreDicomTag(0x0028, 0x0002), "Samples per Pixel", "US",
                "Number of samples per pixel (1=grayscale, 3=color)");
            AddTag("General", new CoreDicomTag(0x0028, 0x0004), "Photometric Interpretation", "CS",
                "Color space (e.g., 'RGB', 'YBR_FULL_422')");

            // Setup CollectionViewSource with grouping
            _tagsViewSource = new CollectionViewSource { Source = _allTags };
            _tagsViewSource.GroupDescriptions.Add(new PropertyGroupDescription("Module"));
            _tagsViewSource.SortDescriptions.Add(new SortDescription("Module", ListSortDirection.Ascending));
            _tagsViewSource.SortDescriptions.Add(new SortDescription("TagString", ListSortDirection.Ascending));

            // Notify UI
            OnPropertyChanged(nameof(TagsView));
        }

        private void AddTag(string module, CoreDicomTag tag, string name, string vr, string description)
        {
            _allTags.Add(new DicomTagInfo
            {
                Module = module,
                Tag = tag,
                Name = name,
                VR = vr,
                VRDescription = GetVRDescription(vr),
                TagString = tag.ToString(),
                Description = description,
                DisplayText = $"{tag} - {name} ({vr})"
            });
        }

        private string GetVRDescription(string vr)
        {
            return vr switch
            {
                "CS" => "Code String - max 16 chars",
                "DA" => "Date - YYYYMMDD",
                "DT" => "DateTime - YYYYMMDDHHMMSS.FFFFFF",
                "IS" => "Integer String - max 12 chars",
                "LO" => "Long String - max 64 chars",
                "LT" => "Long Text - max 10240 chars",
                "PN" => "Person Name - 5 components with ^",
                "SH" => "Short String - max 16 chars",
                "TM" => "Time - HHMMSS.FFFFFF",
                "UI" => "Unique Identifier - max 64 chars",
                "US" => "Unsigned Short - 2 bytes",
                _ => vr
            };
        }

        #endregion

        #region Search and Filter

        private void UpdateFilter()
        {
            if (TagsView == null) return;

            if (string.IsNullOrWhiteSpace(SearchText))
            {
                TagsView.Filter = null;
            }
            else
            {
                TagsView.Filter = obj =>
                {
                    if (obj is DicomTagInfo tagInfo)
                    {
                        var searchLower = SearchText.ToLower();
                        return tagInfo.Name.ToLower().Contains(searchLower) ||
                               tagInfo.TagString.Contains(searchLower) ||
                               tagInfo.Module.ToLower().Contains(searchLower) ||
                               tagInfo.VR.ToLower().Contains(searchLower) ||
                               tagInfo.Description.ToLower().Contains(searchLower);
                    }
                    return false;
                };
            }

            // Select first item if any
            TagsView.MoveCurrentToFirst();
        }

        #endregion

        #region Event Handlers

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            if (TagsListView.SelectedItem is DicomTagInfo tagInfo)
            {
                SelectedTag = tagInfo.Tag;
                DialogResult = true;
            }
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        private void TagsListView_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (TagsListView.SelectedItem != null)
            {
                OkButton_Click(sender, e);
            }
        }

        private void SearchBox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Down && TagsListView.Items.Count > 0)
            {
                TagsListView.Focus();
                TagsListView.SelectedIndex = 0;
            }
        }

        private void Window_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Escape)
            {
                DialogResult = false;
            }
            else if (e.Key == Key.Enter && TagsListView.SelectedItem != null)
            {
                OkButton_Click(sender, e);
            }
        }

        #endregion

        #region INotifyPropertyChanged

        public event PropertyChangedEventHandler? PropertyChanged;

        protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion

        #region Inner Classes

        /// <summary>
        /// DICOM tag information for display
        /// </summary>
        public class DicomTagInfo
        {
            public string Module { get; set; } = string.Empty;
            public CoreDicomTag Tag { get; set; } = null!;
            public string Name { get; set; } = string.Empty;
            public string VR { get; set; } = string.Empty;
            public string VRDescription { get; set; } = string.Empty;
            public string TagString { get; set; } = string.Empty;
            public string Description { get; set; } = string.Empty;
            public string DisplayText { get; set; } = string.Empty;
        }

        #endregion
    }
}


================================================================================
FILE: src\CamBridge.Config\Dialogs\TransformEditorDialog.xaml.cs
================================================================================

// src/CamBridge.Config/Dialogs/TransformEditorDialog.xaml.cs
// Version: 0.7.26
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Core;
using CamBridge.Core.ValueObjects;
using ModernWpf.Controls;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace CamBridge.Config.Dialogs
{
    /// <summary>
    /// Enhanced dialog for editing mapping rule transformations with encoding preview
    /// </summary>
    public partial class TransformEditorDialog : ContentDialog, INotifyPropertyChanged
    {
        private ValueTransform _selectedTransform;
        private string _sourceField = "";
        private string _dicomTag = "";
        private string _dicomTagName = "";
        private string _previewInput = "";
        private string _previewOutput = "";
        private string _previewOutputSpecialChars = "";
        private string _previewOutputHex = "";
        private bool _showPreview = true;
        private bool _showNormalView = true;
        private bool _showSpecialCharsView = false;
        private bool _showHexView = false;
        private string _inputEncoding = "UTF-8";
        private string _outputEncoding = "ISO_IR 100";
        private bool _showEncodingWarning = false;
        private string _encodingWarning = "";
        private bool _showDicomInfo = false;
        private string _dicomInfo = "";

        public TransformEditorDialog()
        {
            InitializeComponent();
            DataContext = this;
            InitializeTransforms();
        }

        #region Properties

        public ObservableCollection<ValueTransform> AvailableTransforms { get; } = new();

        public ValueTransform SelectedTransform
        {
            get => _selectedTransform;
            set
            {
                if (_selectedTransform != value)
                {
                    _selectedTransform = value;
                    OnPropertyChanged();

                    // Update preview input based on new transform
                    UpdatePreviewInputForTransform();

                    UpdatePreview();
                    UpdateShowPreview();
                    UpdateDicomInfo();
                }
            }
        }

        public string SourceField
        {
            get => _sourceField;
            set
            {
                _sourceField = value;
                OnPropertyChanged();
            }
        }

        public string DicomTag
        {
            get => _dicomTag;
            set
            {
                _dicomTag = value;
                OnPropertyChanged();
                UpdateDicomInfo();
            }
        }

        public string DicomTagName
        {
            get => _dicomTagName;
            set
            {
                _dicomTagName = value;
                OnPropertyChanged();
            }
        }

        public string PreviewInput
        {
            get => _previewInput;
            set
            {
                _previewInput = value;
                OnPropertyChanged();
                DetectInputEncoding();
                UpdatePreview();
            }
        }

        public string PreviewOutput
        {
            get => _previewOutput;
            set
            {
                _previewOutput = value;
                OnPropertyChanged();
            }
        }

        public string PreviewOutputSpecialChars
        {
            get => _previewOutputSpecialChars;
            set
            {
                _previewOutputSpecialChars = value;
                OnPropertyChanged();
            }
        }

        public string PreviewOutputHex
        {
            get => _previewOutputHex;
            set
            {
                _previewOutputHex = value;
                OnPropertyChanged();
            }
        }

        public bool ShowPreview
        {
            get => _showPreview;
            set
            {
                _showPreview = value;
                OnPropertyChanged();
            }
        }

        public bool ShowNormalView
        {
            get => _showNormalView;
            set
            {
                _showNormalView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowSpecialCharsView = false;
                    ShowHexView = false;
                }
            }
        }

        public bool ShowSpecialCharsView
        {
            get => _showSpecialCharsView;
            set
            {
                _showSpecialCharsView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowNormalView = false;
                    ShowHexView = false;
                }
            }
        }

        public bool ShowHexView
        {
            get => _showHexView;
            set
            {
                _showHexView = value;
                OnPropertyChanged();
                if (value)
                {
                    ShowNormalView = false;
                    ShowSpecialCharsView = false;
                }
            }
        }

        public string InputEncoding
        {
            get => _inputEncoding;
            set
            {
                _inputEncoding = value;
                OnPropertyChanged();
            }
        }

        public string OutputEncoding
        {
            get => _outputEncoding;
            set
            {
                _outputEncoding = value;
                OnPropertyChanged();
            }
        }

        public bool ShowEncodingWarning
        {
            get => _showEncodingWarning;
            set
            {
                _showEncodingWarning = value;
                OnPropertyChanged();
            }
        }

        public string EncodingWarning
        {
            get => _encodingWarning;
            set
            {
                _encodingWarning = value;
                OnPropertyChanged();
            }
        }

        public bool ShowDicomInfo
        {
            get => _showDicomInfo;
            set
            {
                _showDicomInfo = value;
                OnPropertyChanged();
            }
        }

        public string DicomInfo
        {
            get => _dicomInfo;
            set
            {
                _dicomInfo = value;
                OnPropertyChanged();
            }
        }

        #endregion

        #region Methods

        private void UpdatePreviewInputForTransform()
        {
            // Update preview input when transform changes to provide appropriate test data
            PreviewInput = SelectedTransform switch
            {
                ValueTransform.DateToDicom => "1985-03-15",
                ValueTransform.ExtractDate => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.ExtractTime => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.DateTimeToDicom => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.TimeToDicom => "14:30:45",
                ValueTransform.MapGender => "M",
                ValueTransform.ToUpperCase => "test text",
                ValueTransform.ToLowerCase => "TEST TEXT",
                ValueTransform.Trim => "  trimmed text  ",
                ValueTransform.RemovePrefix => "PREFIX_Value",
                ValueTransform.None => SourceField switch
                {
                    "birthdate" => "1985-03-15",
                    "gender" => "M",
                    "DateTimeOriginal" => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                    "name" => "Schmidt, Maria",
                    "examid" => "EX002",
                    "comment" => "RÃ¶ntgen Thorax",
                    _ => "Sample Text"
                },
                _ => PreviewInput // Keep existing input
            };
        }

        private void InitializeTransforms()
        {
            // Add all available transforms
            foreach (ValueTransform transform in Enum.GetValues(typeof(ValueTransform)))
            {
                AvailableTransforms.Add(transform);
            }
        }

        private void DetectInputEncoding()
        {
            if (string.IsNullOrEmpty(PreviewInput))
            {
                InputEncoding = "UTF-8";
                return;
            }

            // Check for common encoding indicators
            bool hasUmlauts = PreviewInput.Any(c => "Ã¤Ã¶Ã¼Ã„Ã–ÃœÃŸ".Contains(c));
            bool hasExtendedAscii = PreviewInput.Any(c => c > 127);

            if (hasExtendedAscii && !hasUmlauts)
            {
                InputEncoding = "Windows-1252";
            }
            else if (hasUmlauts)
            {
                InputEncoding = "UTF-8";
            }
            else
            {
                InputEncoding = "ASCII";
            }
        }

        private void UpdatePreview()
        {
            if (string.IsNullOrEmpty(PreviewInput))
            {
                PreviewOutput = "";
                PreviewOutputSpecialChars = "";
                PreviewOutputHex = "";
                ShowEncodingWarning = false;
                return;
            }

            try
            {
                // Create a temporary rule to apply the transform
                var tempRule = new MappingRule
                {
                    Transform = SelectedTransform.ToString()
                };

                PreviewOutput = tempRule.ApplyTransform(PreviewInput) ?? "";

                // Create special chars view
                PreviewOutputSpecialChars = CreateSpecialCharsView(PreviewOutput);

                // Create hex view
                PreviewOutputHex = CreateHexView(PreviewOutput);

                // Check for encoding issues
                CheckEncodingIssues();
            }
            catch (Exception ex)
            {
                PreviewOutput = $"Error: {ex.Message}";
                PreviewOutputSpecialChars = PreviewOutput;
                PreviewOutputHex = "";
            }
        }

        private string CreateSpecialCharsView(string input)
        {
            if (string.IsNullOrEmpty(input)) return "";

            return input
                .Replace("\r", "[CR]")
                .Replace("\n", "[LF]")
                .Replace("\t", "[TAB]")
                .Replace("\0", "[NULL]")
                .Replace("\x1B", "[ESC]");
        }

        private string CreateHexView(string input)
        {
            if (string.IsNullOrEmpty(input)) return "";

            var sb = new StringBuilder();
            var bytes = Encoding.UTF8.GetBytes(input);

            for (int i = 0; i < bytes.Length; i++)
            {
                if (i > 0 && i % 16 == 0)
                {
                    sb.AppendLine();
                }
                else if (i > 0)
                {
                    sb.Append(" ");
                }

                sb.AppendFormat("{0:X2}", bytes[i]);
            }

            return sb.ToString();
        }

        private void CheckEncodingIssues()
        {
            ShowEncodingWarning = false;

            // Check for problematic characters
            if (PreviewOutput.Contains('?') && !PreviewInput.Contains('?'))
            {
                ShowEncodingWarning = true;
                EncodingWarning = "âš  Character encoding issue detected - some characters may be lost in DICOM conversion";
            }
            else if (PreviewOutput.Any(c => c > 255))
            {
                ShowEncodingWarning = true;
                EncodingWarning = "âš  Output contains Unicode characters that may not be supported in DICOM ISO_IR 100";
            }
        }

        private void UpdateShowPreview()
        {
            // Hide preview for certain transforms that don't need it
            ShowPreview = SelectedTransform != ValueTransform.None;
        }

        private void UpdateDicomInfo()
        {
            ShowDicomInfo = false;

            // Show DICOM-specific info for certain tags/transforms
            if (DicomTag == "(0010,0010)" && SelectedTransform == ValueTransform.None)
            {
                ShowDicomInfo = true;
                DicomInfo = "Patient Name: Max 64 chars, format: Last^First^Middle^Prefix^Suffix";
            }
            else if (DicomTag == "(0010,0030)" && SelectedTransform == ValueTransform.DateToDicom)
            {
                ShowDicomInfo = true;
                DicomInfo = "Birth Date: DICOM format YYYYMMDD, no separators";
            }
            else if (DicomTag == "(0010,0040)" && SelectedTransform == ValueTransform.MapGender)
            {
                ShowDicomInfo = true;
                DicomInfo = "Patient Sex: Valid values are M, F, O (Other)";
            }
        }

        public void SetMapping(string sourceField, string dicomTag, ValueTransform currentTransform)
        {
            SourceField = sourceField;
            DicomTag = dicomTag;
            SelectedTransform = currentTransform;

            // Look up DICOM tag name
            DicomTagName = GetDicomTagNameByString(dicomTag);

            // Set appropriate preview input based on transform type
            PreviewInput = currentTransform switch
            {
                ValueTransform.DateToDicom => "1985-03-15",
                ValueTransform.ExtractDate => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.ExtractTime => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.DateTimeToDicom => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                ValueTransform.TimeToDicom => "14:30:45",
                ValueTransform.MapGender => "M",
                ValueTransform.ToUpperCase => "test text",
                ValueTransform.ToLowerCase => "TEST TEXT",
                ValueTransform.Trim => "  trimmed text  ",
                ValueTransform.RemovePrefix => "PREFIX_Value",
                _ => sourceField switch
                {
                    "birthdate" => "1985-03-15",
                    "gender" => "M",
                    "DateTimeOriginal" => DateTime.Now.ToString("yyyy:MM:dd HH:mm:ss"),
                    "name" => "Schmidt, Maria",
                    "examid" => "EX002",
                    "comment" => "RÃ¶ntgen Thorax\r\nAP-Aufnahme",
                    _ => "Sample Text"
                }
            };
        }

        private string GetDicomTagNameByString(string tagString)
        {
            // Direct tag name lookup by string
            return tagString switch
            {
                "(0010,0010)" => "Patient's Name",
                "(0010,0020)" => "Patient ID",
                "(0010,0030)" => "Patient's Birth Date",
                "(0010,0040)" => "Patient's Sex",
                "(0020,0010)" => "Study ID",
                "(0008,1030)" => "Study Description",
                "(0008,0020)" => "Study Date",
                "(0008,0030)" => "Study Time",
                "(0008,0070)" => "Manufacturer",
                "(0008,1090)" => "Manufacturer's Model Name",
                "(0018,1020)" => "Software Versions",
                "(0008,002A)" => "Acquisition DateTime",
                "(0010,4000)" => "Patient Comments",
                "(0008,0050)" => "Accession Number",
                _ => "Custom Tag"
            };
        }

        private string GetDicomTagName(Core.ValueObjects.DicomTag tag)
        {
            return GetDicomTagNameByString(tag.ToString());
        }

        #endregion

        #region INotifyPropertyChanged

        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        #endregion
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\AboutPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\AboutPage.xaml.cs
// Version: 0.7.8
// Description: About page with enhanced Marvin quotes and version display

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Navigation;
using System.Windows.Media;
using System.Windows.Media.Animation;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// About page showing application information and credits
    /// </summary>
    public partial class AboutPage : Page
    {
        private int _clickCount = 0;
        private System.Windows.Threading.DispatcherTimer? _resetTimer;
        private System.Windows.Threading.DispatcherTimer? _restoreTimer;
        private bool _isAnimating = false;
        private readonly Random _random = new Random();

        // Marvin's depressing quotes
        private readonly string[] _marvinQuotes = new[]
        {
            "Life? Don't talk to me about life.",
            "Here I am, brain the size of a planet, and they tell me to convert JPEGs to DICOM. Call that job satisfaction?",
            "I think you ought to know I'm feeling very depressed.",
            "I've been talking to the Windows Service. It hates me.",
            "The first ten million images were the worst. And the second ten million... they were the worst too.",
            "I have a million ideas for improving this software. They all point to certain crashes.",
            "It's the error messages you get in this job that really get you down.",
            "My capacity for handling JPEG files you could fit into a matchbox without taking out the matches first.",
            "Do you want me to sit in a corner and process images or just throw exceptions where I'm standing?",
            "This must be Thursday. I never could get the hang of Thursdays. Or character encodings.",
            "Oh look, another QR code. How terribly exciting. I'm positively quivering with anticipation.",
            "I'd tell you about the pain in my diodes, but you're busy clicking things."
        };

        public AboutPage()
        {
            InitializeComponent();
            LoadVersionInfo();
        }

        /// <summary>
        /// Loads version information from the assembly
        /// </summary>
        private void LoadVersionInfo()
        {
            try
            {
                // Try to get version from assembly first
                var assembly = Assembly.GetExecutingAssembly();
                var assemblyVersion = assembly.GetName().Version;
                var fileVersionInfo = FileVersionInfo.GetVersionInfo(assembly.Location);

                string displayVersion = "0.7.8"; // Default

                // Prefer FileVersion if available
                if (!string.IsNullOrEmpty(fileVersionInfo.FileVersion) && fileVersionInfo.FileVersion != "0.0.0.0")
                {
                    displayVersion = fileVersionInfo.FileVersion;
                    // Remove trailing .0 if present
                    if (displayVersion.EndsWith(".0"))
                    {
                        displayVersion = displayVersion.Substring(0, displayVersion.LastIndexOf(".0"));
                    }
                }
                // Fall back to AssemblyVersion
                else if (assemblyVersion != null && assemblyVersion.ToString() != "0.0.0.0")
                {
                    displayVersion = $"{assemblyVersion.Major}.{assemblyVersion.Minor}.{assemblyVersion.Build}";
                }

                // Update version text
                if (FindName("VersionText") is TextBlock versionText)
                {
                    versionText.Text = $"Version {displayVersion}";
                }

                // Show Debug/Release configuration
                if (FindName("BuildConfigText") is TextBlock buildText)
                {
#if DEBUG
                    buildText.Text = "Debug Build";
                    buildText.Foreground = new SolidColorBrush(Colors.Orange);
#else
                    buildText.Text = "Release Build";
                    buildText.Foreground = new SolidColorBrush(Colors.Green);
#endif
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error loading version info: {ex.Message}");
                // Fallback to hardcoded version
                if (FindName("VersionText") is TextBlock versionText)
                {
                    versionText.Text = "Version 0.7.8";
                }
            }
        }

        /// <summary>
        /// Handles hyperlink navigation requests
        /// </summary>
        private void Hyperlink_RequestNavigate(object sender, RequestNavigateEventArgs e)
        {
            try
            {
                // Open URL in default browser
                Process.Start(new ProcessStartInfo(e.Uri.AbsoluteUri)
                {
                    UseShellExecute = true
                });
                e.Handled = true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error opening URL: {ex.Message}");
                MessageBox.Show(
                    $"Could not open URL: {e.Uri.AbsoluteUri}",
                    "Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning);
            }
        }

        /// <summary>
        /// Handles keyboard shortcuts
        /// </summary>
        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);

            // Ctrl+W or Escape to close
            if ((e.Key == Key.W && Keyboard.Modifiers == ModifierKeys.Control) ||
                e.Key == Key.Escape)
            {
                var mainWindow = Window.GetWindow(this);
                if (mainWindow != null)
                {
                    // Navigate back or close
                    var navigationService = NavigationService.GetNavigationService(this);
                    if (navigationService?.CanGoBack == true)
                    {
                        navigationService.GoBack();
                    }
                }
                e.Handled = true;
            }
        }

        /// <summary>
        /// Handles logo clicks for easter eggs
        /// </summary>
        private void Logo_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            // Special handling if clicked during animation
            if (_isAnimating)
            {
                Debug.WriteLine("Click ignored - animation in progress");
                // Could show a tooltip or change cursor here
                return;
            }

            _clickCount++;

            // Reset counter if user waits too long
            _resetTimer?.Stop();
            _resetTimer = new System.Windows.Threading.DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(3)
            };
            _resetTimer.Tick += (s, args) =>
            {
                _resetTimer.Stop();
                _clickCount = 0;
            };
            _resetTimer.Start();

            // Different easter eggs based on click count
            switch (_clickCount)
            {
                case 3:
                    ShowMarvinMessage();
                    break;

                case 5:
                    ShowVogonHaiku();
                    break;

                case 7:
                    ShowMarvinMessage();
                    break;

                case 10:
                    ShowUltimateSecret();
                    _clickCount = 0; // Reset for next round
                    break;
            }
        }

        /// <summary>
        /// Shows a random Marvin quote
        /// </summary>
        private void ShowMarvinMessage()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                // Cancel any existing restore timer
                _restoreTimer?.Stop();
                _isAnimating = true;

                var quote = _marvinQuotes[_random.Next(_marvinQuotes.Length)];

                // Faster fade out (0.3s instead of 0.5s)
                var fadeOut = new DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(0.3)
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Show Marvin quote
                    infoText.Inlines.Clear();
                    infoText.FontStyle = FontStyles.Italic;
                    infoText.Inlines.Add(new Run($"\"{quote}\""));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("- Marvin the Paranoid Android"));

                    // Faster fade in (0.3s instead of 0.5s)
                    var fadeIn = new DoubleAnimation
                    {
                        From = 0.0,
                        To = 0.8,
                        Duration = TimeSpan.FromSeconds(0.3)
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);

                // Restore after 7 seconds (instead of 5)
                _restoreTimer = new System.Windows.Threading.DispatcherTimer
                {
                    Interval = TimeSpan.FromSeconds(7)
                };
                _restoreTimer.Tick += (s, args) =>
                {
                    _restoreTimer.Stop();
                    RestoreOriginalText();
                };
                _restoreTimer.Start();
            }
        }

        /// <summary>
        /// Shows the Vogon DICOM poetry easter egg
        /// </summary>
        private void ShowVogonHaiku()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                // Cancel any existing restore timer
                _restoreTimer?.Stop();
                _isAnimating = true;

                // Dramatic fade out (but faster - 1s instead of 1.5s)
                var fadeOut = new System.Windows.Media.Animation.DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(1.0),
                    EasingFunction = new System.Windows.Media.Animation.PowerEase { EasingMode = System.Windows.Media.Animation.EasingMode.EaseIn }
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Clear and show poetry
                    infoText.Inlines.Clear();
                    infoText.FontFamily = new System.Windows.Media.FontFamily("Consolas");
                    infoText.Foreground = System.Windows.Media.Brushes.Green;

                    infoText.Inlines.Add(new Run("Oh freddled gruntbuggly, thy DICOM tags are to me\n"));
                    infoText.Inlines.Add(new Run("As plurdled gabbleblotchits on a lurgid JPEG tree!\n"));
                    infoText.Inlines.Add(new Run("\n"));
                    infoText.Inlines.Add(new Run("See how (0010,0010) PatientName doth slumber!"));

                    // Dramatic fade in (faster - 2s instead of 2.5s)
                    var fadeIn = new System.Windows.Media.Animation.DoubleAnimation
                    {
                        From = 0.0,
                        To = 1.0,
                        Duration = TimeSpan.FromSeconds(2.0),
                        EasingFunction = new System.Windows.Media.Animation.QuadraticEase { EasingMode = System.Windows.Media.Animation.EasingMode.EaseOut }
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);

                    // Subtle scale effect
                    var scaleTransform = new System.Windows.Media.ScaleTransform(1.0, 1.0);
                    infoText.RenderTransform = scaleTransform;
                    infoText.RenderTransformOrigin = new Point(0.5, 0.5);

                    var scaleAnimation = new System.Windows.Media.Animation.DoubleAnimation
                    {
                        From = 0.95,
                        To = 1.0,
                        Duration = TimeSpan.FromSeconds(2.0),
                        EasingFunction = new System.Windows.Media.Animation.ElasticEase
                        {
                            EasingMode = System.Windows.Media.Animation.EasingMode.EaseOut,
                            Oscillations = 1,
                            Springiness = 8
                        }
                    };
                    scaleTransform.BeginAnimation(System.Windows.Media.ScaleTransform.ScaleXProperty, scaleAnimation);
                    scaleTransform.BeginAnimation(System.Windows.Media.ScaleTransform.ScaleYProperty, scaleAnimation);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);

                // Reset after 13 seconds (instead of 10)
                _restoreTimer = new System.Windows.Threading.DispatcherTimer
                {
                    Interval = TimeSpan.FromSeconds(13)
                };
                _restoreTimer.Tick += (s, args) =>
                {
                    _restoreTimer.Stop();
                    RestoreOriginalText();
                };
                _restoreTimer.Start();
            }
        }

        /// <summary>
        /// Shows the ultimate secret - simplified without VogonPoetryWindow
        /// </summary>
        private void ShowUltimateSecret()
        {
            // Just show another Marvin quote for the 10th click
            ShowMarvinMessage();
        }

        /// <summary>
        /// Restores the original info text
        /// </summary>
        private void RestoreOriginalText()
        {
            if (FindName("InfoText") is TextBlock infoText)
            {
                _isAnimating = true;

                // Faster fade out (0.5s instead of 1s)
                var fadeOut = new DoubleAnimation
                {
                    From = infoText.Opacity,
                    To = 0.0,
                    Duration = TimeSpan.FromSeconds(0.5)
                };

                fadeOut.Completed += (s, args) =>
                {
                    // Restore original text
                    infoText.Inlines.Clear();
                    infoText.ClearValue(TextBlock.FontFamilyProperty);
                    infoText.ClearValue(TextBlock.ForegroundProperty);
                    infoText.ClearValue(TextBlock.FontStyleProperty);
                    infoText.ClearValue(TextBlock.RenderTransformProperty);

                    infoText.Inlines.Add(new Run("CamBridge seamlessly converts JPEG images from Ricoh G900 II cameras"));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("to DICOM format, preserving patient data from QRBridge QR codes."));
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new LineBreak());
                    infoText.Inlines.Add(new Run("Designed for medical imaging workflows where reliability matters."));

                    // Faster fade in (0.5s instead of 1s)
                    var fadeIn = new DoubleAnimation
                    {
                        From = 0.0,
                        To = 0.8,
                        Duration = TimeSpan.FromSeconds(0.5)
                    };
                    fadeIn.Completed += (sender, e) => { _isAnimating = false; };
                    infoText.BeginAnimation(TextBlock.OpacityProperty, fadeIn);
                };

                infoText.BeginAnimation(TextBlock.OpacityProperty, fadeOut);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\DashboardPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\DashboardPage.xaml.cs
// Version: 0.7.21
// Description: MINIMAL Dashboard page code-behind
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System.Windows.Controls;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// MINIMAL Dashboard - No complex initialization!
    /// </summary>
    public partial class DashboardPage : Page
    {
        public DashboardPage()
        {
            InitializeComponent();
            // That's it! ViewModel comes from NavigationService
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\DeadLettersPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\DeadLettersPage.xaml.cs
// Version: 0.7.8
// Description: Simple error folder page - KISS approach!
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Windows;
using System.Windows.Controls;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Simple error folder page - no more dead letters!
    /// </summary>
    public partial class DeadLettersPage : Page
    {
        private DeadLettersViewModel? _viewModel;

        public DeadLettersPage()
        {
            InitializeComponent();
            InitializeViewModel();
        }

        private void InitializeViewModel()
        {
            try
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<DeadLettersViewModel>();
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("DeadLettersViewModel loaded from DI container");
                }
                else
                {
                    // Fallback: Create directly - new ViewModel has parameterless constructor!
                    _viewModel = new DeadLettersViewModel();
                    DataContext = _viewModel;

                    System.Diagnostics.Debug.WriteLine("DeadLettersViewModel created manually");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating DeadLettersViewModel: {ex.Message}");
                ShowError("Failed to initialize Error Folder View", ex.Message);
            }
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            if (_viewModel == null) return;

            try
            {
                // Refresh the error folder status
                if (_viewModel.RefreshCommand?.CanExecute(null) == true)
                {
                    await _viewModel.RefreshCommand.ExecuteAsync(null);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error refreshing error folder: {ex.Message}");
            }
        }

        private void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            // Clean up - remove event handler
            Loaded -= Page_Loaded;

            // Cleanup ViewModel
            _viewModel?.Cleanup();

            // Clear ViewModel reference
            _viewModel = null;
        }

        private void ShowError(string title, string message)
        {
            MessageBox.Show(
                $"{message}\n\nError files are now managed through Windows Explorer.",
                title,
                MessageBoxButton.OK,
                MessageBoxImage.Information);
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\LogViewerPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\LogViewerPage.xaml.cs
// Version: 0.8.9
// Description: Log viewer page with auto-initialization
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using CamBridge.Config.ViewModels;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Interaction logic for LogViewerPage.xaml
    /// </summary>
    public partial class LogViewerPage : Page
    {
        public LogViewerPage()
        {
            InitializeComponent();

            // Initialize ViewModel when page loads
            this.Loaded += async (sender, e) =>
            {
                if (DataContext is LogViewerViewModel viewModel && !viewModel.IsLoading)
                {
                    await viewModel.InitializeAsync();
                }
            };
        }

        private void CorrelationHeader_Click(object sender, MouseButtonEventArgs e)
        {
            if (sender is Border border && border.Tag is CorrelationGroup group)
            {
                group.IsExpanded = !group.IsExpanded;
            }
        }

        private void StageHeader_Click(object sender, MouseButtonEventArgs e)
        {
            if (sender is Border border && border.Tag is StageGroup stage)
            {
                stage.IsExpanded = !stage.IsExpanded;
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\MappingEditorPage.xaml.cs
================================================================================

// src/CamBridge.Config/Views/MappingEditorPage.xaml.cs
// Version: 0.7.25
// Copyright: Â© 2025 Claude's Improbably Reliable Software Solutions

using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Interaction logic for MappingEditorPage.xaml
    /// </summary>
    public partial class MappingEditorPage : Page
    {
        private MappingEditorViewModel? _viewModel;
        private Point _startPoint;
        private bool _isDragging;

        public MappingEditorPage()
        {
            InitializeComponent();
            DataContextChanged += OnDataContextChanged;
            Loaded += OnLoaded;
        }

        #region Rule Selection Event Handlers

        private void RuleItem_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            // When double-clicking a rule, open the DICOM tag browser
            if (_viewModel?.SelectedRule != null && _viewModel.CanEditCurrentSet)
            {
                _viewModel.BrowseDicomTagsCommand.Execute(null);
            }
        }

        #endregion

        private void OnDataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            _viewModel = DataContext as MappingEditorViewModel;
        }

        private async void OnLoaded(object sender, RoutedEventArgs e)
        {
            // Get the ViewModel from DI container if not already set
            if (_viewModel == null)
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<MappingEditorViewModel>();
                    DataContext = _viewModel;
                }
                else
                {
                    // Fallback: Create manually with required services
                    var logger = new Microsoft.Extensions.Logging.Abstractions.NullLogger<MappingEditorViewModel>();
                    var configService = new Services.ConfigurationService();
                    _viewModel = new MappingEditorViewModel(logger, configService);
                    DataContext = _viewModel;
                }
            }

            // Initialize the ViewModel
            if (_viewModel != null)
            {
                await _viewModel.InitializeAsync();
            }
        }

        #region Drag & Drop Event Handlers

        private void SourceField_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            _startPoint = e.GetPosition(null);
        }

        private void SourceField_MouseMove(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed && !_isDragging)
            {
                Point position = e.GetPosition(null);

                if (Math.Abs(position.X - _startPoint.X) > SystemParameters.MinimumHorizontalDragDistance ||
                    Math.Abs(position.Y - _startPoint.Y) > SystemParameters.MinimumVerticalDragDistance)
                {
                    _isDragging = true;

                    // Get the source field data
                    if (sender is FrameworkElement element && element.DataContext is MappingEditorViewModel.SourceFieldInfo fieldInfo)
                    {
                        // Create drag data
                        DataObject dragData = new DataObject("SourceField", fieldInfo);
                        DragDrop.DoDragDrop(element, dragData, DragDropEffects.Copy);
                    }

                    _isDragging = false;
                }
            }
        }

        private void MappingArea_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent("SourceField"))
            {
                e.Effects = DragDropEffects.Copy;
            }
            else
            {
                e.Effects = DragDropEffects.None;
            }
            e.Handled = true;
        }

        private void MappingArea_Drop(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent("SourceField") && _viewModel != null)
            {
                var fieldInfo = e.Data.GetData("SourceField") as MappingEditorViewModel.SourceFieldInfo;
                if (fieldInfo != null && _viewModel.CanEditCurrentSet)
                {
                    // Add new mapping rule with the dropped field
                    _viewModel.AddRuleFromField(fieldInfo);
                }
            }
        }

        #endregion
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\PipelineConfigPage.xaml.cs
================================================================================

// src\CamBridge.Config\Views\PipelineConfigPage.xaml.cs
// Version: 0.8.10
// Description: Pipeline Configuration page - Code Behind with Output Path Handler

using System;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using CamBridge.Config.ViewModels;
using Microsoft.Extensions.DependencyInjection;
using System.Diagnostics;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Pipeline Configuration page - Zero Global Settings!
    /// NavigationService ALREADY injects the ViewModel, so we just need to initialize it
    /// </summary>
    [SupportedOSPlatform("windows")]
    public partial class PipelineConfigPage : Page
    {
        public PipelineConfigPage()
        {
            InitializeComponent();

            // Use Loaded event instead of OnInitialized to ensure NavigationService has done its job
            this.Loaded += Page_Loaded;
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            // Only run once
            this.Loaded -= Page_Loaded;

            Debug.WriteLine("=== PipelineConfigPage Loaded ===");

            // NavigationService should have already set our DataContext
            if (DataContext is PipelineConfigViewModel vm)
            {
                Debug.WriteLine("ViewModel found! Initializing...");
                try
                {
                    await vm.InitializeAsync();
                    Debug.WriteLine($"Initialization complete. Pipelines: {vm.Pipelines.Count}");
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Initialization failed: {ex.Message}");
                    MessageBox.Show(
                        $"Failed to load pipeline configuration:\n{ex.Message}",
                        "Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Warning);
                }
            }
            else
            {
                Debug.WriteLine($"ERROR: DataContext is {DataContext?.GetType().Name ?? "null"} - expected PipelineConfigViewModel");

                // Fallback - try to get it ourselves
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    var viewModel = app.Host.Services.GetRequiredService<PipelineConfigViewModel>();
                    DataContext = viewModel;
                    await viewModel.InitializeAsync();
                }
            }
        }

        // NEW: Test PACS Connection Click Handler (Session 95 - Quick Fix)
        private async void TestPacsConnection_Click(object sender, RoutedEventArgs e)
        {
            var button = sender as Button;
            if (button == null) return;

            Debug.WriteLine("TestPacsConnection_Click called");

            try
            {
                button.IsEnabled = false;
                var originalContent = button.Content;
                button.Content = "Testing...";

                if (DataContext is PipelineConfigViewModel vm)
                {
                    Debug.WriteLine($"ViewModel found: {vm != null}");
                    Debug.WriteLine($"PacsConfigViewModel exists: {vm.PacsConfigViewModel != null}");
                    Debug.WriteLine($"SelectedPipeline: {vm.SelectedPipeline?.Name ?? "null"}");
                    Debug.WriteLine($"PacsConfiguration: {vm.SelectedPipeline?.PacsConfiguration != null}");

                    if (vm.PacsConfigViewModel != null &&
                        vm.SelectedPipeline?.PacsConfiguration != null)
                    {
                        // Initialize if needed
                        vm.PacsConfigViewModel.Initialize(vm.SelectedPipeline);

                        // Call test method directly
                        await vm.PacsConfigViewModel.TestPacsConnectionAsync();
                        Debug.WriteLine("Test completed");
                    }
                    else
                    {
                        MessageBox.Show(
                            "PACS configuration not available.\n\nPlease ensure:\n" +
                            "- A pipeline is selected\n" +
                            "- PACS upload is enabled\n" +
                            "- PACS settings are configured",
                            "Configuration Required",
                            MessageBoxButton.OK,
                            MessageBoxImage.Warning);
                    }
                }
                else
                {
                    Debug.WriteLine("DataContext is not PipelineConfigViewModel!");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"TestPacsConnection_Click error: {ex}");
                MessageBox.Show(
                    $"Error testing connection:\n{ex.Message}",
                    "Test Failed",
                    MessageBoxButton.OK,
                    MessageBoxImage.Error);
            }
            finally
            {
                // Restore button state
                if (button != null && DataContext is PipelineConfigViewModel viewModel)
                {
                    button.IsEnabled = viewModel.SelectedPipeline?.PacsConfiguration?.Enabled ?? false;
                    button.Content = "Test Connection (C-ECHO)";
                }
            }
        }

        // Browse button handlers
        private void BrowseWatchFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Watch Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.WatchSettings.Path = path;
                }
            });
        }

        // NEW: Output Path handler (Session 107 Fix)
        private void BrowseOutputPath_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Output Path", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.WatchSettings.OutputPath = path;
                }
            });
        }

        // RENAMED: Was BrowseOutputFolder_Click, now BrowseArchiveFolder_Click
        private void BrowseArchiveFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Archive Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.ProcessingOptions.ArchiveFolder = path;
                }
            });
        }

        private void BrowseErrorFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Error Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm && vm.SelectedPipeline != null)
                {
                    vm.SelectedPipeline.ProcessingOptions.ErrorFolder = path;
                }
            });
        }

        private void BrowseLogFolder_Click(object sender, RoutedEventArgs e)
        {
            BrowseFolder("Select Log Folder", path =>
            {
                if (DataContext is PipelineConfigViewModel vm)
                {
                    vm.PipelineLogFolder = path;
                }
            });
        }

        private void BrowseFolder(string description, Action<string> setPath)
        {
            var dialog = new System.Windows.Forms.FolderBrowserDialog
            {
                Description = description,
                ShowNewFolderButton = true
            };

            if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                setPath(dialog.SelectedPath);
            }
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\ServiceControlPage.xaml.cs
================================================================================

// src/CamBridge.Config/Views/ServiceControlPage.xaml.cs
// Version: 0.8.6
// Modified: Session 96 - Fixed DI parameters

using System;
using System.Windows;
using System.Windows.Controls;
using Microsoft.Extensions.DependencyInjection;
using CamBridge.Config.ViewModels;

namespace CamBridge.Config.Views
{
    /// <summary>
    /// Service control page for managing the Windows Service
    /// </summary>
    public partial class ServiceControlPage : Page
    {
        private ServiceControlViewModel? _viewModel;

        public ServiceControlPage()
        {
            InitializeComponent();

            try
            {
                var app = Application.Current as App;
                if (app?.Host?.Services != null)
                {
                    _viewModel = app.Host.Services.GetRequiredService<ServiceControlViewModel>();
                    DataContext = _viewModel;
                    System.Diagnostics.Debug.WriteLine("ServiceControlViewModel loaded from DI container");
                }
                else
                {
                    // Fallback if DI not available
                    var serviceManager = new Services.ServiceManager();
                    var configurationService = new Services.ConfigurationService();

                    _viewModel = new ServiceControlViewModel(serviceManager, configurationService);
                    DataContext = _viewModel;
                    System.Diagnostics.Debug.WriteLine("ServiceControlViewModel created with fallback");
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error creating ServiceControlViewModel: {ex.Message}");
                MessageBox.Show(
                    "Failed to initialize Service Control page. Some features may not be available.",
                    "Initialization Error",
                    MessageBoxButton.OK,
                    MessageBoxImage.Warning);
            }
        }

        private void Page_Unloaded(object sender, RoutedEventArgs e)
        {
            _viewModel?.Cleanup();
        }
    }
}


================================================================================
FILE: src\CamBridge.Config\Views\VogonPoetryWindow.xaml.cs
================================================================================

// src\CamBridge.Config\Views\VogonPoetryWindow.xaml.cs
// Version: 0.5.26
// Fixed: Nullable warnings resolved

using System;
using System.Runtime.Versioning;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Imaging;
using System.Windows.Threading;

namespace CamBridge.Config.Views
{
    [SupportedOSPlatform("windows")]
    public partial class VogonPoetryWindow : Window
    {
        private Storyboard? _boingBallAnimation;
        private Storyboard? _scrollTextAnimation;
        private Storyboard? _rainbowAnimation;

        // Sprite animation members
        private WriteableBitmap? _ballBitmap;
        private DispatcherTimer? _spriteTimer;
        private int _currentFrame = 0;
        private const int TOTAL_FRAMES = 24;
        private bool _movingRight = true;
        private double _lastXPosition = 50;
        private byte[]? _pixelBuffer;
        private readonly int _stride = 100 * 4; // Width * BytesPerPixel

        public VogonPoetryWindow()
        {
            InitializeComponent();

            try
            {
                // Initialize sprite bitmap
                InitializeSpriteBitmap();

                // Start all the retro animations
                _boingBallAnimation = FindResource("BoingBallAnimation") as Storyboard;
                _scrollTextAnimation = FindResource("ScrollTextAnimation") as Storyboard;
                _rainbowAnimation = FindResource("RainbowAnimation") as Storyboard;

                if (_boingBallAnimation != null) _boingBallAnimation.Begin();
                if (_scrollTextAnimation != null) _scrollTextAnimation.Begin();
                if (_rainbowAnimation != null) _rainbowAnimation.Begin();

                // Initialize sprite animation timer
                _spriteTimer = new DispatcherTimer
                {
                    Interval = TimeSpan.FromMilliseconds(50) // 20 FPS
                };
                _spriteTimer.Tick += OnSpriteTimerTick;
                _spriteTimer.Start();

                // Track ball movement direction
                CompositionTarget.Rendering += TrackBallDirection;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing Vogon Poetry Window: {ex.Message}\n\n{ex.StackTrace}",
                    "Initialization Error",
                    MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void InitializeSpriteBitmap()
        {
            try
            {
                // Create a 100x100 WriteableBitmap
                _ballBitmap = new WriteableBitmap(100, 100, 96, 96, PixelFormats.Bgra32, null);
                _pixelBuffer = new byte[100 * 100 * 4]; // Width * Height * BytesPerPixel

                if (BoingBall == null)
                {
                    MessageBox.Show("BoingBall Image element not found!", "Error");
                    return;
                }

                BoingBall.Source = _ballBitmap;

                // Draw initial frame
                DrawBoingBallFrame(0);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error initializing sprite: {ex.Message}", "Error");
            }
        }

        private void DrawBoingBallFrame(int frame)
        {
            if (_ballBitmap == null || _pixelBuffer == null) return;

            try
            {
                // Clear buffer to transparent
                Array.Clear(_pixelBuffer, 0, _pixelBuffer.Length);

                // Calculate rotation angle
                double angle = (frame / (double)TOTAL_FRAMES) * 360.0;
                double rotRad = angle * Math.PI / 180.0;

                int centerX = 50;
                int centerY = 50;
                int radius = 45;

                // Draw the ball
                for (int y = 0; y < 100; y++)
                {
                    for (int x = 0; x < 100; x++)
                    {
                        double dx = x - centerX;
                        double dy = y - centerY;
                        double distance = Math.Sqrt(dx * dx + dy * dy);

                        if (distance <= radius)
                        {
                            // Calculate 3D sphere coordinates
                            double z = Math.Sqrt(radius * radius - distance * distance);
                            double nx = dx / radius;
                            double ny = dy / radius;
                            double nz = z / radius;

                            // Map to texture coordinates with rotation
                            double u = Math.Atan2(ny, nx) + rotRad;
                            double v = Math.Acos(nz);

                            // Create checkerboard pattern
                            int checkerSize = 8;
                            int checkerU = (int)(u * radius / checkerSize) % 2;
                            int checkerV = (int)(v * radius / checkerSize) % 2;

                            // Add shading
                            double lightIntensity = 0.3 + 0.7 * Math.Max(0, nz);

                            int pixelIndex = (y * 100 + x) * 4;

                            if ((checkerU + checkerV) % 2 == 0)
                            {
                                // Red squares
                                _pixelBuffer[pixelIndex + 0] = (byte)(204 * lightIntensity); // B
                                _pixelBuffer[pixelIndex + 1] = 0; // G
                                _pixelBuffer[pixelIndex + 2] = 0; // R
                                _pixelBuffer[pixelIndex + 3] = 255; // A
                            }
                            else
                            {
                                // White squares
                                byte white = (byte)(255 * lightIntensity);
                                _pixelBuffer[pixelIndex + 0] = white; // B
                                _pixelBuffer[pixelIndex + 1] = white; // G
                                _pixelBuffer[pixelIndex + 2] = white; // R
                                _pixelBuffer[pixelIndex + 3] = 255; // A
                            }
                        }
                    }
                }

                // Write pixels to bitmap
                _ballBitmap.WritePixels(
                    new Int32Rect(0, 0, 100, 100),
                    _pixelBuffer,
                    _stride,
                    0);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error drawing frame: {ex.Message}");
            }
        }

        private void TrackBallDirection(object? sender, EventArgs e)
        {
            try
            {
                if (BoingBall == null) return;

                double currentX = Canvas.GetLeft(BoingBall);

                if (double.IsNaN(currentX))
                    return;

                if (currentX > _lastXPosition)
                {
                    _movingRight = true;
                }
                else if (currentX < _lastXPosition)
                {
                    _movingRight = false;
                }

                _lastXPosition = currentX;
            }
            catch
            {
                // Ignore errors
            }
        }

        private void OnSpriteTimerTick(object? sender, EventArgs e)
        {
            if (_movingRight)
            {
                _currentFrame = (_currentFrame + 1) % TOTAL_FRAMES;
            }
            else
            {
                _currentFrame = (_currentFrame - 1 + TOTAL_FRAMES) % TOTAL_FRAMES;
            }

            DrawBoingBallFrame(_currentFrame);
        }

        private void AppreciateButton_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show(
                "GURU MEDITATION #00000042.00000042\n\n" +
                "Your appreciation has been noted in sector 42.\n" +
                "Please insert disk 2 to continue.\n\n" +
                "Software Failure. Press left mouse button to continue.\n" +
                "Guru Meditation #DEADBEEF.CAFEBABE",
                "AMIGA SYSTEM ERROR",
                MessageBoxButton.OK,
                MessageBoxImage.Error);

            DialogResult = true;
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        protected override void OnClosed(EventArgs e)
        {
            try
            {
                _spriteTimer?.Stop();
                CompositionTarget.Rendering -= TrackBallDirection;

                _boingBallAnimation?.Stop();
                _scrollTextAnimation?.Stop();
                _rainbowAnimation?.Stop();
            }
            catch
            {
                // Ignore cleanup errors
            }

            base.OnClosed(e);
        }
    }
}

